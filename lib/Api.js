// Generated by CoffeeScript 1.6.3
(function() {
  var Api, Finder, Loader, Translator, callsite, fs, path;

  if (typeof window !== 'undefined') {
    throw new Error('Translator API can not be used in browser.');
  }

  Loader = require('./Loaders/Loader');

  Translator = require('./Translator');

  fs = require('fs');

  path = require('path');

  callsite = require('callsite');

  Finder = require('fs-finder');

  Api = (function() {
    Api.prototype.configPath = null;

    Api.prototype.config = null;

    Api.prototype.translator = null;

    Api.prototype.loader = null;

    Api.prototype.language = 'en';

    Api.prototype.languages = null;

    function Api(configPath, language) {
      var stack;
      this.configPath = configPath;
      this.language = language != null ? language : this.language;
      if (this.configPath.charAt(0) === '.') {
        stack = callsite();
        this.configPath = path.join(path.dirname(stack[1].getFileName()), this.configPath);
      }
      this.configPath = path.normalize(this.configPath);
      this.config = JSON.parse(fs.readFileSync(this.configPath, {
        encoding: 'utf8'
      }));
      if (typeof this.config.path === 'undefined') {
        this.config.path = '.';
      }
      if (typeof this.config.loader === 'undefined') {
        this.config.loader = 'Json';
      }
      if (typeof this.config.languages === 'undefined') {
        this.config.languages = [];
      }
      if (this.config.path.charAt(0) === '.') {
        this.config.path = path.join(path.dirname(this.configPath), this.config.path);
      }
      this.translator = new Translator(this.configPath);
      this.loader = new (require('./Loaders/' + this.config.loader))(this.config.path);
    }

    Api.prototype.release = function() {
      return this.languages = null;
    };

    Api.prototype.getLanguages = function() {
      var file, language, _i, _j, _len, _len1, _ref, _ref1;
      if (this.languages === null) {
        this.languages = [];
        _ref = Finder.from(this.config.path).findFiles('.*.json');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          language = path.basename(file).split('.')[0];
          if (this.languages.indexOf(language) === -1) {
            this.languages.push(language);
          }
        }
        _ref1 = this.config.languages;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          language = _ref1[_j];
          if (this.languages.indexOf(language) === -1) {
            this.languages.push(language);
          }
        }
      }
      return this.languages;
    };

    Api.prototype.hasLanguage = function(language) {
      return this.getLanguages().indexOf(language) !== -1;
    };

    Api.prototype.addLanguage = function(language) {
      if (!this.hasLanguage(language)) {
        this.languages.push(language);
        this.config.languages.push(language);
        return fs.writeFileSync(this.configPath, JSON.stringify(this.config, null, '\t'));
      }
    };

    Api.prototype.getDictionaries = function() {
      var dir, file, name, result, _i, _len, _ref;
      result = [];
      _ref = Finder.from(this.config.path).findFiles(this.language + '.*.json');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        name = path.relative(this.config.path, file);
        dir = path.dirname(name);
        name = path.basename(name, path.extname(name)).replace(new RegExp('^' + this.language + '\.'), '');
        result.push(path.join(dir, name));
      }
      return this.createTree(result);
    };

    Api.prototype.addDictionary = function(dictionary) {
      var info, _path;
      info = this.translator.getMessageInfo(dictionary + '.buf');
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      if (fs.existsSync(_path)) {
        throw new Error("Dictionary '" + dictionary + "' already exists.");
      }
      return fs.writeFileSync(_path, '{}');
    };

    Api.prototype.renameDictionary = function(oldName, newName) {
      var info, newInfo, newPath, _path;
      info = this.translator.getMessageInfo(oldName + '.buf');
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      if (!fs.existsSync(_path)) {
        throw new Error("Dictionary '" + oldName + "' does not exists.");
      }
      newInfo = this.translator.getMessageInfo(newName + '.buf');
      newPath = this.loader.getFileSystemPath(newInfo.path, newInfo.category, this.language);
      if (fs.existsSync(newPath)) {
        throw new Error("Dictionary '" + newName + "' already exists.");
      }
      return fs.renameSync(_path, newPath);
    };

    Api.prototype.removeDictionary = function(dictionary) {
      var info, _path;
      info = this.translator.getMessageInfo(dictionary + '.buf');
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      if (!fs.existsSync(_path)) {
        throw new Error("Dictionary '" + dictionary + "' does not exists.");
      }
      return fs.unlinkSync(_path);
    };

    Api.prototype.getTranslations = function(dictionary) {
      var files, info, _path;
      info = this.translator.getMessageInfo(dictionary + '.buf');
      files = this.translator.loadCategory(info.path, info.category, this.language);
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      delete require.cache[_path];
      return files;
    };

    Api.prototype.addTranslation = function(dictionary, name, translation) {
      var data, info, _path;
      info = this.translator.getMessageInfo(dictionary + '.' + name);
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      data = this.getTranslations(dictionary);
      if (typeof data[info.name] !== 'undefined') {
        throw new Error("Translation '" + name + "' already exists in '" + dictionary + "' dictionary.");
      }
      data[info.name] = translation;
      data = JSON.stringify(data, null, '\t');
      return fs.writeFileSync(_path, data);
    };

    Api.prototype.editTranslation = function(dictionary, name, translation) {
      var data, info, _path;
      info = this.translator.getMessageInfo(dictionary + '.' + name);
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      data = this.getTranslations(dictionary);
      if (typeof data[info.name] === 'undefined') {
        throw new Error("Translation '" + name + "' does not exists in '" + dictionary + "' dictionary.");
      }
      data[info.name] = translation;
      data = JSON.stringify(data, null, '\t');
      return fs.writeFileSync(_path, data);
    };

    Api.prototype.renameTranslation = function(dictionary, oldName, newName) {
      var data, info, _path;
      info = this.translator.getMessageInfo(dictionary + '.' + oldName);
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      data = this.getTranslations(dictionary);
      if (typeof data[info.name] === 'undefined') {
        throw new Error("Translation '" + oldName + "' does not exists in '" + dictionary + "' dictionary.");
      }
      if (typeof data[newName] !== 'undefined') {
        throw new Error("Translation '" + newName + "' already exists in '" + dictionary + "' dictionary.");
      }
      data[newName] = data[oldName];
      delete data[oldName];
      data = JSON.stringify(data, null, '\t');
      return fs.writeFileSync(_path, data);
    };

    Api.prototype.removeTranslation = function(dictionary, name) {
      var data, info, _path;
      info = this.translator.getMessageInfo(dictionary + '.' + name);
      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
      data = this.getTranslations(dictionary);
      delete data[name];
      data = JSON.stringify(data, null, '\t');
      return fs.writeFileSync(_path, data);
    };

    Api.prototype.createTree = function(paths) {
      var buf, count, part, parts, result, _i, _j, _len, _len1, _path;
      result = {};
      count = 0;
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        _path = paths[_i];
        parts = _path.split(path.sep);
        buf = result;
        for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
          part = parts[_j];
          if (typeof buf[part] === 'undefined') {
            buf[part] = {};
          }
          buf = buf[part];
        }
        count++;
      }
      return result;
    };

    return Api;

  })();

  module.exports = Api;

}).call(this);
