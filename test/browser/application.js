(function() {
	var __r__c__ = this;
	/** Generated by SimQ **/
	/** modules **/
	
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var SUPPORTED, arrayIndexOf, cache, creating, modules, require, resolve, stats;
	
	  if (!this.require) {
	    SUPPORTED = ['js', 'json', 'ts', 'coffee', 'eco'];
	    modules = {};
	    stats = {};
	    cache = {};
	    creating = [];
	    require = function(name, parent) {
	      var fullName, m;
	      if (parent == null) {
	        parent = null;
	      }
	      fullName = resolve(name, parent);
	      if (typeof cache[fullName] === 'undefined') {
	        m = {
	          exports: {},
	          id: fullName,
	          filename: fullName,
	          loaded: false,
	          parent: null,
	          children: null
	        };
	        if (arrayIndexOf(creating, fullName) === -1) {
	          creating.push(fullName);
	          modules[fullName].apply(window, [m.exports, m]);
	          creating.splice(arrayIndexOf(creating, fullName));
	          cache[fullName] = m;
	        }
	        m.loaded = true;
	      } else {
	        m = cache[fullName];
	      }
	      if (typeof stats[fullName] === 'undefined') {
	        stats[fullName] = {
	          atime: null,
	          mtime: null,
	          ctime: null
	        };
	      }
	      stats[fullName].atime = new Date;
	      return m.exports;
	    };
	    resolve = function(name, parent) {
	      var ext, num, original, part, parts, prev, result, _i, _j, _k, _len, _len1, _len2;
	      if (parent == null) {
	        parent = null;
	      }
	      original = name;
	      if (parent !== null && name[0] === '.') {
	        num = parent.lastIndexOf('/');
	        if (num !== -1) {
	          parent = parent.substr(0, num);
	        }
	        name = parent + '/' + name;
	      }
	      parts = name.split('/');
	      result = [];
	      prev = null;
	      for (_i = 0, _len = parts.length; _i < _len; _i++) {
	        part = parts[_i];
	        if (part === '.' || part === '') {
	          continue;
	        } else if (part === '..' && prev) {
	          result.pop();
	        } else {
	          result.push(part);
	        }
	        prev = part;
	      }
	      name = result.join('/');
	      if ((original[0] === '/') || (parent !== null && parent[0] === '/' && original[0] === '.')) {
	        name = '/' + name;
	      }
	      if (typeof modules[name] !== 'undefined') {
	        return name;
	      }
	      for (_j = 0, _len1 = SUPPORTED.length; _j < _len1; _j++) {
	        ext = SUPPORTED[_j];
	        if (typeof modules[name + '.' + ext] !== 'undefined') {
	          return name + '.' + ext;
	        }
	      }
	      for (_k = 0, _len2 = SUPPORTED.length; _k < _len2; _k++) {
	        ext = SUPPORTED[_k];
	        if (typeof modules[name + '/index.' + ext] !== 'undefined') {
	          return name + '/index.' + ext;
	        }
	      }
	      throw new Error("Module " + original + " was not found.");
	    };
	    arrayIndexOf = function(array, search) {
	      var element, i, _i, _len;
	      if (typeof Array.prototype.indexOf !== 'undefined') {
	        return array.indexOf(search);
	      }
	      if (array.length === 0) {
	        return -1;
	      }
	      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
	        element = array[i];
	        if (element === search) {
	          return i;
	        }
	      }
	      return -1;
	    };
	    this.require = function(name, parent) {
	      if (parent == null) {
	        parent = null;
	      }
	      return require(name, parent);
	    };
	    this.require.simq = true;
	    this.require.version = 1;
	    this.require.resolve = function(name, parent) {
	      if (parent == null) {
	        parent = null;
	      }
	      return resolve(name, parent);
	    };
	    this.require.define = function(bundleOrName, obj) {
	      var m, name, _results;
	      if (obj == null) {
	        obj = null;
	      }
	      if (typeof bundleOrName === 'string') {
	        return modules[bundleOrName] = obj;
	      } else {
	        _results = [];
	        for (name in bundleOrName) {
	          m = bundleOrName[name];
	          _results.push(modules[name] = m);
	        }
	        return _results;
	      }
	    };
	    this.require.release = function() {
	      var name, _results;
	      _results = [];
	      for (name in cache) {
	        _results.push(delete cache[name]);
	      }
	      return _results;
	    };
	    this.require.getStats = function(name, parent) {
	      var fullName;
	      if (parent == null) {
	        parent = null;
	      }
	      fullName = resolve(name, parent);
	      if (fullName === null) {
	        throw new Error('Module ' + name + ' was not found.');
	      }
	      if (typeof stats[fullName] === 'undefined') {
	        stats[fullName] = {
	          atime: null,
	          mtime: null,
	          ctime: null
	        };
	      }
	      return stats[fullName];
	    };
	    this.require.__setStats = function(bundle) {
	      var data, name, _results;
	      _results = [];
	      for (name in bundle) {
	        data = bundle[name];
	        _results.push(stats[name] = {
	          atime: new Date(data.atime),
	          mtime: new Date(data.mtime),
	          ctime: new Date(data.ctime)
	        });
	      }
	      return _results;
	    };
	    this.require.cache = cache;
	  }
	
	  return this.require.define;
	
	}).call(this)({
	 '/lib/Loaders/Loader.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/Loaders/Loader.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Loaders/Loader.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/Loaders/Loader.js';
		var __dirname = '/lib/Loaders';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Loaders/Loader.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Loader;
		
		  Loader = (function() {
		    function Loader() {}
		
		    Loader.prototype.load = function() {
		      throw new Error('Translator loader: you have to implement method load.');
		    };
		
		    Loader.prototype.save = function() {
		      throw new Error('Translator loader: you have to implement method save.');
		    };
		
		    Loader.prototype.getFileSystemPath = function() {
		      throw new Error('Translator loader: you have to implement method getFileSystemPath.');
		    };
		
		    return Loader;
		
		  })();
		
		  module.exports = Loader;
		
		}).call(this);
		
	
	}, '/lib/Translator.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/Translator.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Translator.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/Translator.js';
		var __dirname = '/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Translator.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Args, Cache, JsonLoader, Loader, Storage, Translator, callsite, isBrowser, path, pluralForms;
		
		  Cache = require('cache-storage');
		
		  Storage = require('cache-storage/Storage/Storage');
		
		  Args = require('normalize-arguments');
		
		  path = require('./node/path');
		
		  pluralForms = require('./pluralForms');
		
		  Loader = require('./Loaders/Loader');
		
		  JsonLoader = require('./Loaders/Json');
		
		  isBrowser = typeof window !== 'undefined';
		
		  if (!isBrowser) {
		    callsite = require('callsite');
		  }
		
		  Translator = (function() {
		    Translator.prototype.loader = null;
		
		    Translator.prototype.language = null;
		
		    Translator.prototype.plurals = null;
		
		    Translator.prototype.replacements = null;
		
		    Translator.prototype.data = null;
		
		    Translator.prototype.cache = null;
		
		    function Translator(pathOrLoader) {
		      var config, data, language, stack, _config;
		      this.plurals = {};
		      this.replacements = {};
		      this.data = {};
		      if (!pathOrLoader) {
		        throw new Error('You have to set path to base directory or to config file or loader.');
		      }
		      if (typeof pathOrLoader === 'string') {
		        if (pathOrLoader.charAt(0) === '.' && isBrowser) {
		          throw new Error('Relative paths to dictionaries is not supported in browser.');
		        }
		        if (pathOrLoader.charAt(0) === '.') {
		          stack = callsite();
		          pathOrLoader = path.join(path.dirname(stack[1].getFileName()), pathOrLoader);
		        }
		        pathOrLoader = path.normalize(pathOrLoader);
		        config = {
		          path: pathOrLoader,
		          loader: 'Json'
		        };
		        if (pathOrLoader.match(/\.json$/) !== null) {
		          _config = require(pathOrLoader);
		          if (typeof _config.path !== 'undefined') {
		            config.path = _config.path;
		          }
		          if (typeof _config.loader !== 'undefined') {
		            config.loader = _config.loader;
		          }
		          if (config.path.charAt(0) === '.') {
		            config.path = path.join(path.dirname(pathOrLoader), config.path);
		          }
		        }
		        pathOrLoader = new (require('./Loaders/' + config.loader))(config.path);
		      }
		      this.setLoader(pathOrLoader);
		      for (language in pluralForms) {
		        data = pluralForms[language];
		        this.addPluralForm(language, data.count, data.form);
		      }
		    }
		
		    Translator.prototype.expand = function(main) {
		      var _this = this;
		      if (main == null) {
		        main = null;
		      }
		      if (main === null) {
		        main = isBrowser ? window : global;
		      }
		      main._ = function() {
		        return _this.translate.apply(_this, arguments);
		      };
		      main._m = function() {
		        return _this.translateMap.apply(_this, arguments);
		      };
		      main._p = function() {
		        return _this.translatePairs.apply(_this, arguments);
		      };
		      return main;
		    };
		
		    Translator.prototype.setLoader = function(loader) {
		      if (!(loader instanceof Loader)) {
		        throw new Error('Loader must be an instance of translator/Loaders/Loader.');
		      }
		      return this.loader = loader;
		    };
		
		    Translator.prototype.invalidate = function() {
		      return this.data = {};
		    };
		
		    Translator.prototype.setCacheStorage = function(cacheStorage) {
		      if (!cacheStorage instanceof Storage) {
		        throw new Error('Cache storage must be an instance of cache-storage/Storage/Storage.');
		      }
		      return this.cache = new Cache(cacheStorage, 'translator');
		    };
		
		    Translator.prototype.addPluralForm = function(language, count, form) {
		      this.plurals[language] = {
		        count: count,
		        form: form
		      };
		      return this;
		    };
		
		    Translator.prototype.addReplacement = function(search, replacement) {
		      this.replacements[search] = replacement;
		      return this;
		    };
		
		    Translator.prototype.removeReplacement = function(search) {
		      if (typeof this.replacements[search] === 'undefined') {
		        throw new Error('Replacement ' + search + ' was not found.');
		      }
		      delete this.replacements[search];
		      return this;
		    };
		
		    Translator.prototype.loadCategory = function(_path, name, language) {
		      var categoryName, conds, data, file;
		      if (language == null) {
		        language = this.language;
		      }
		      categoryName = _path + '/' + name;
		      if (typeof this.data[categoryName] === 'undefined') {
		        if (this.cache === null) {
		          data = this.loader.load(_path, name, language);
		          data = this.normalizeTranslations(data);
		        } else {
		          data = this.cache.load(language + ':' + categoryName);
		          if (data === null) {
		            data = this.loader.load(_path, name, language);
		            data = this.normalizeTranslations(data);
		            conds = {};
		            if (typeof window === 'undefined' || (typeof window !== 'undefined' && window.require.simq === true && typeof window.require.version !== 'undefined' && parseInt(window.require.version.replace(/\./g, '')) >= 510)) {
		              _path = this.loader.getFileSystemPath(_path, name, language);
		              if (_path !== null) {
		                conds.files = [_path];
		              }
		            }
		            this.cache.save(language + ':' + categoryName, data, conds);
		          } else {
		            file = this.loader.load(_path, name, language);
		            data = this.normalizeTranslations(file);
		          }
		        }
		        this.data[categoryName] = data;
		      }
		      return this.data[categoryName];
		    };
		
		    Translator.prototype.normalizeTranslations = function(translations) {
		      var buf, list, match, name, result, sub, t, translation, _i, _j, _len, _len1;
		      result = {};
		      for (name in translations) {
		        translation = translations[name];
		        list = false;
		        if ((match = name.match(/^--\s(.*)/)) !== null) {
		          name = match[1];
		          list = true;
		        }
		        if (typeof translation === 'string') {
		          result[name] = [translation];
		        } else if (Object.prototype.toString.call(translation) === '[object Array]') {
		          result[name] = [];
		          for (_i = 0, _len = translation.length; _i < _len; _i++) {
		            t = translation[_i];
		            if (typeof t === 'object') {
		              buf = [];
		              for (_j = 0, _len1 = t.length; _j < _len1; _j++) {
		                sub = t[_j];
		                if (/^\#.*\#$/.test(sub) === false) {
		                  buf.push(sub);
		                }
		              }
		              result[name].push(buf);
		            } else {
		              if (/^\#.*\#$/.test(t) === false) {
		                if (list === true && typeof t !== 'object') {
		                  t = [t];
		                }
		                result[name].push(t);
		              }
		            }
		          }
		        }
		      }
		      return result;
		    };
		
		    Translator.prototype.hasTranslation = function(message, language) {
		      if (language == null) {
		        language = this.language;
		      }
		      return this.findTranslation(message, language) !== null;
		    };
		
		    Translator.prototype.findTranslation = function(message, language) {
		      var data, info;
		      if (language == null) {
		        language = this.language;
		      }
		      info = this.getMessageInfo(message);
		      data = this.loadCategory(info.path, info.category, language);
		      if (typeof data[info.name] === 'undefined') {
		        return null;
		      } else {
		        return data[info.name];
		      }
		    };
		
		    Translator.prototype.translate = function(message, count, args) {
		      var language, match, num, params, translation;
		      if (count == null) {
		        count = null;
		      }
		      if (args == null) {
		        args = {};
		      }
		      params = Args(arguments, [Args.any, Args.number(null), Args.object({})]);
		      message = params[0];
		      count = params[1];
		      args = params[2];
		      language = this.language;
		      if (typeof message !== 'string') {
		        return message;
		      }
		      if (count !== null) {
		        args.count = count;
		      }
		      if ((match = message.match(/^\:(.*)\:$/)) !== null) {
		        message = match[1];
		        if ((match = message.match(/^[a-z]+\|(.*)$/)) !== null) {
		          message = match[1];
		        }
		      } else {
		        if ((match = message.match(/^([a-z]+)\|(.*)$/)) !== null) {
		          language = match[1];
		          message = match[2];
		        }
		        if (language === null) {
		          throw new Error('You have to set language');
		        }
		        num = null;
		        if ((match = message.match(/(.+)\[(\d+)\]$/)) !== null) {
		          message = match[1];
		          num = parseInt(match[2]);
		        }
		        message = this.applyReplacements(message, args);
		        translation = this.findTranslation(message, language);
		        if (num !== null) {
		          if (!this.isList(translation)) {
		            throw new Error('Translation ' + message + ' is not a list.');
		          }
		          if (typeof translation[num] === 'undefined') {
		            throw new Error('Item ' + num + ' was not found in ' + message + ' translation.');
		          }
		          translation = translation[num];
		        }
		        if (translation !== null) {
		          message = this.pluralize(message, translation, count, language);
		        }
		      }
		      message = this.prepareTranslation(message, args);
		      return message;
		    };
		
		    Translator.prototype.translatePairs = function(message, key, value, count, args) {
		      var i, k, result, _i, _len;
		      if (count == null) {
		        count = null;
		      }
		      if (args == null) {
		        args = {};
		      }
		      key = "" + message + "." + key;
		      value = "" + message + "." + value;
		      key = this.translate(key, count, args);
		      value = this.translate(value, count, args);
		      if (Object.prototype.toString.call(key) !== '[object Array]' || Object.prototype.toString.call(value) !== '[object Array]') {
		        throw new Error('Translations are not arrays.');
		      }
		      if (key.length !== value.length) {
		        throw new Error('Keys and values translations have not got the same length.');
		      }
		      result = {};
		      for (i = _i = 0, _len = key.length; _i < _len; i = ++_i) {
		        k = key[i];
		        result[k] = value[i];
		      }
		      return result;
		    };
		
		    Translator.prototype.translateMap = function(list, count, args, base) {
		      var i, k, m, params, type, _i, _len;
		      if (count == null) {
		        count = null;
		      }
		      if (args == null) {
		        args = {};
		      }
		      if (base == null) {
		        base = null;
		      }
		      type = Object.prototype.toString.call(list);
		      if (type !== '[object Array]' && type !== '[object Object]') {
		        throw new Error('Translate map is only for arrays and objects.');
		      }
		      params = Args(arguments, [Args.oneOf([Args.array, Args.object]), Args.number(null), Args.object({}), Args.string(null)]);
		      list = params[0];
		      count = params[1];
		      args = params[2];
		      base = params[3];
		      base = base !== null ? base + '.' : '';
		      if (type === '[object Array]') {
		        for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
		          m = list[i];
		          list[i] = this.translate(base + m, count, args);
		        }
		      } else {
		        for (k in list) {
		          m = list[k];
		          list[k] = this.translate(base + m, count, args);
		        }
		      }
		      return list;
		    };
		
		    Translator.prototype.isList = function(translation) {
		      return Object.prototype.toString.call(translation[0]) === '[object Array]';
		    };
		
		    Translator.prototype.pluralize = function(message, translation, count, language) {
		      var n, plural, pluralForm, result, t, _i, _j, _len, _len1;
		      if (count == null) {
		        count = null;
		      }
		      if (language == null) {
		        language = this.language;
		      }
		      if (count !== null) {
		        if (typeof translation[0] === 'string') {
		          pluralForm = 'n=' + count + ';plural=+(' + this.plurals[language].form + ');';
		          n = null;
		          plural = null;
		          eval(pluralForm);
		          message = plural !== null && typeof translation[plural] !== 'undefined' ? translation[plural] : translation[0];
		        } else {
		          result = [];
		          for (_i = 0, _len = translation.length; _i < _len; _i++) {
		            t = translation[_i];
		            result.push(this.pluralize(message, t, count, language));
		          }
		          message = result;
		        }
		      } else {
		        if (typeof translation[0] === 'string') {
		          message = translation[0];
		        } else {
		          message = [];
		          for (_j = 0, _len1 = translation.length; _j < _len1; _j++) {
		            t = translation[_j];
		            message.push(t[0]);
		          }
		        }
		      }
		      return message;
		    };
		
		    Translator.prototype.prepareTranslation = function(message, args) {
		      var m, result, _i, _len;
		      if (args == null) {
		        args = {};
		      }
		      if (typeof message === 'string') {
		        message = this.applyReplacements(message, args);
		      } else {
		        result = [];
		        for (_i = 0, _len = message.length; _i < _len; _i++) {
		          m = message[_i];
		          result.push(this.prepareTranslation(m, args));
		        }
		        message = result;
		      }
		      return message;
		    };
		
		    Translator.prototype.applyReplacements = function(message, args) {
		      var name, pattern, replacements, value;
		      if (args == null) {
		        args = {};
		      }
		      replacements = this.replacements;
		      for (name in args) {
		        value = args[name];
		        replacements[name] = value;
		      }
		      for (name in replacements) {
		        value = replacements[name];
		        if (value !== false) {
		          pattern = new RegExp('%' + name + '%', 'g');
		          message = message.replace(pattern, value);
		        }
		      }
		      return message;
		    };
		
		    Translator.prototype.getMessageInfo = function(message) {
		      var category, name, num, result, _path;
		      num = message.lastIndexOf('.');
		      _path = message.substr(0, num);
		      name = message.substr(num + 1);
		      num = _path.lastIndexOf('.');
		      category = _path.substr(num + 1);
		      _path = _path.substr(0, num).replace(/\./g, '/');
		      result = {
		        path: _path,
		        category: category,
		        name: name
		      };
		      return result;
		    };
		
		    return Translator;
		
		  })();
		
		  module.exports = Translator;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Cache.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Cache.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Cache.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Cache.js';
		var __dirname = 'cache-storage/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Cache.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Cache;
		
		  Cache = (function() {
		    Cache.FILES = 'files';
		
		    Cache.TAGS = 'tags';
		
		    Cache.EXPIRE = 'expire';
		
		    Cache.ITEMS = 'items';
		
		    Cache.PRIORITY = 'priority';
		
		    Cache.ALL = 'all';
		
		    Cache.TIME_FORMAT = 'YYYY-MM-DD HH:mm';
		
		    Cache.prototype.storage = null;
		
		    Cache.prototype.namespace = null;
		
		    function Cache(storage, namespace) {
		      this.storage = storage;
		      this.namespace = namespace;
		      if (!(this.storage instanceof require('./Storage/Storage'))) {
		        throw new Error('Cache: storage must be instance of cache-storage/Storage/Storage');
		      }
		      this.storage.cache = this;
		    }
		
		    Cache.prototype.generateKey = function(key) {
		      var ch, hash, i, max, _i;
		      hash = 0;
		      if (key.length === 0) {
		        return hash;
		      }
		      max = key.length - 1;
		      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
		        ch = key.charCodeAt(i);
		        hash = ((hash << 5) - hash) + ch;
		        hash |= 0;
		      }
		      return hash;
		    };
		
		    Cache.prototype.load = function(key, fallback) {
		      var data;
		      if (fallback == null) {
		        fallback = null;
		      }
		      data = this.storage.read(this.generateKey(key));
		      if (data === null && fallback !== null) {
		        return this.save(key, fallback);
		      }
		      return data;
		    };
		
		    Cache.prototype.save = function(key, data, dependencies) {
		      if (dependencies == null) {
		        dependencies = {};
		      }
		      key = this.generateKey(key);
		      if (Object.prototype.toString.call(data) === '[object Function]') {
		        data = data();
		      }
		      if (data === null) {
		        this.storage.remove(key);
		      } else {
		        this.storage.write(key, data, this.storage.parseDependencies(dependencies));
		      }
		      return data;
		    };
		
		    Cache.prototype.remove = function(key) {
		      return this.save(key, null);
		    };
		
		    Cache.prototype.clean = function(conditions) {
		      this.storage.clean(conditions);
		      return this;
		    };
		
		    return Cache;
		
		  })();
		
		  module.exports = Cache;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/Storage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/Storage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/Storage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/Storage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/Storage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Cache, Storage, checkFilesSupport, fs, isWindow, moment, path;
		
		  isWindow = typeof window === 'undefined' ? false : true;
		
		  if (!isWindow) {
		    fs = require('fs');
		    path = require('path');
		  }
		
		  moment = require('moment');
		
		  Cache = require('../Cache');
		
		  checkFilesSupport = function() {
		    var version;
		    if (isWindow && window.require.simq !== true) {
		      throw new Error('Files meta information can be used in browser only with simq.');
		    }
		    if (isWindow) {
		      version = window.require.version;
		      if (typeof version === 'undefined' || parseInt(version.replace(/\./g, '')) < 510) {
		        throw new Error('File method information is supported only with simq@5.1.0 and later.');
		      }
		    }
		  };
		
		  Storage = (function() {
		    Storage.prototype.cache = null;
		
		    function Storage() {
		      if (typeof this.getData === 'undefined' || typeof this.getMeta === 'undefined' || typeof this.writeData === 'undefined') {
		        throw new Error('Cache storage: you have to implement methods getData, getMeta and writeData.');
		      }
		    }
		
		    Storage.prototype.read = function(key) {
		      var data;
		      data = this.getData();
		      if (typeof data[key] === 'undefined') {
		        return null;
		      } else {
		        if (this.verify(this.findMeta(key))) {
		          return data[key];
		        } else {
		          this.remove(key);
		          return null;
		        }
		      }
		    };
		
		    Storage.prototype.write = function(key, data, dependencies) {
		      var all, meta;
		      if (dependencies == null) {
		        dependencies = {};
		      }
		      all = this.getData();
		      all[key] = data;
		      meta = this.getMeta();
		      meta[key] = dependencies;
		      this.writeData(all, meta);
		      return this;
		    };
		
		    Storage.prototype.remove = function(key) {
		      var data, meta;
		      data = this.getData();
		      meta = this.getMeta();
		      if (typeof data[key] !== 'undefined') {
		        delete data[key];
		        delete meta[key];
		      }
		      this.writeData(data, meta);
		      return this;
		    };
		
		    Storage.prototype.clean = function(conditions) {
		      var key, tag, type, typeFn, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
		      typeFn = Object.prototype.toString;
		      type = typeFn.call(conditions);
		      if (conditions === Cache.ALL) {
		        this.writeData({}, {});
		      } else if (type === '[object Object]') {
		        if (typeof conditions[Cache.TAGS] !== 'undefined') {
		          if (typeFn(conditions[Cache.TAGS]) === '[object String]') {
		            conditions[Cache.TAGS] = [conditions[Cache.TAGS]];
		          }
		          _ref = conditions[Cache.TAGS];
		          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		            tag = _ref[_i];
		            _ref1 = this.findKeysByTag(tag);
		            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
		              key = _ref1[_j];
		              this.remove(key);
		            }
		          }
		        }
		        if (typeof conditions[Cache.PRIORITY] !== 'undefined') {
		          _ref2 = this.findKeysByPriority(conditions[Cache.PRIORITY]);
		          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
		            key = _ref2[_k];
		            this.remove(key);
		          }
		        }
		      }
		      return this;
		    };
		
		    Storage.prototype.findMeta = function(key) {
		      var meta;
		      meta = this.getMeta();
		      if (typeof meta[key] !== 'undefined') {
		        return meta[key];
		      } else {
		        return null;
		      }
		    };
		
		    Storage.prototype.findKeysByTag = function(tag) {
		      var key, meta, metas, result;
		      metas = this.getMeta();
		      result = [];
		      for (key in metas) {
		        meta = metas[key];
		        if (typeof meta[Cache.TAGS] !== 'undefined' && meta[Cache.TAGS].indexOf(tag) !== -1) {
		          result.push(key);
		        }
		      }
		      return result;
		    };
		
		    Storage.prototype.findKeysByPriority = function(priority) {
		      var key, meta, metas, result;
		      metas = this.getMeta();
		      result = [];
		      for (key in metas) {
		        meta = metas[key];
		        if (typeof meta[Cache.PRIORITY] !== 'undefined' && meta[Cache.PRIORITY] <= priority) {
		          result.push(key);
		        }
		      }
		      return result;
		    };
		
		    Storage.prototype.verify = function(meta) {
		      var file, item, mtime, time, typefn, _i, _len, _ref, _ref1, _ref2;
		      typefn = Object.prototype.toString;
		      if (typefn.call(meta) === '[object Object]') {
		        if (typeof meta[Cache.FILES] !== 'undefined') {
		          checkFilesSupport();
		          if (isWindow) {
		            _ref = meta[Cache.FILES];
		            for (file in _ref) {
		              time = _ref[file];
		              mtime = window.require.getStats(file).mtime;
		              if (mtime === null) {
		                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
		              }
		              if (window.require.getStats(file).mtime.getTime() !== time) {
		                return false;
		              }
		            }
		          } else {
		            _ref1 = meta[Cache.FILES];
		            for (file in _ref1) {
		              time = _ref1[file];
		              if ((new Date(fs.statSync(file).mtime)).getTime() !== time) {
		                return false;
		              }
		            }
		          }
		        }
		        if (typeof meta[Cache.EXPIRE] !== 'undefined') {
		          if (moment().valueOf() >= meta[Cache.EXPIRE]) {
		            return false;
		          }
		        }
		        if (typeof meta[Cache.ITEMS] !== 'undefined') {
		          _ref2 = meta[Cache.ITEMS];
		          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
		            item = _ref2[_i];
		            item = this.findMeta(item);
		            if ((item === null) || (item !== null && this.verify(item) === false)) {
		              return false;
		            }
		          }
		        }
		      }
		      return true;
		    };
		
		    Storage.prototype.parseDependencies = function(dependencies) {
		      var file, files, i, item, mtime, result, time, typefn, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
		      typefn = Object.prototype.toString;
		      result = {};
		      if (typefn.call(dependencies) === '[object Object]') {
		        if (typeof dependencies[Cache.FILES] !== 'undefined') {
		          checkFilesSupport();
		          files = {};
		          if (isWindow) {
		            _ref = dependencies[Cache.FILES];
		            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		              file = _ref[_i];
		              mtime = window.require.getStats(file).mtime;
		              if (mtime === null) {
		                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
		              }
		              file = window.require.resolve(file);
		              files[file] = mtime.getTime();
		            }
		          } else {
		            _ref1 = dependencies[Cache.FILES];
		            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
		              file = _ref1[_j];
		              file = path.resolve(file);
		              files[file] = (new Date(fs.statSync(file).mtime)).getTime();
		            }
		          }
		          result[Cache.FILES] = files;
		        }
		        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
		          switch (typefn.call(dependencies[Cache.EXPIRE])) {
		            case '[object String]':
		              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
		              break;
		            case '[object Object]':
		              time = moment().add(dependencies[Cache.EXPIRE]);
		              break;
		            default:
		              throw new Error('Expire format is not valid');
		          }
		          result[Cache.EXPIRE] = time.valueOf();
		        }
		        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
		          result[Cache.ITEMS] = [];
		          _ref2 = dependencies[Cache.ITEMS];
		          for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
		            item = _ref2[i];
		            result[Cache.ITEMS].push(this.cache.generateKey(item));
		          }
		        }
		        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
		          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
		        }
		        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
		          result[Cache.TAGS] = dependencies[Cache.TAGS];
		        }
		      }
		      return result;
		    };
		
		    return Storage;
		
		  })();
		
		  module.exports = Storage;
		
		}).call(this);
		
	
	}, 'moment/moment.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'moment/moment.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/moment.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'moment/moment.js';
		var __dirname = 'moment';
		var process = {cwd: function() {return '/';}, argv: ['node', 'moment/moment.js'], env: {}};
	
		/** code **/
		//! moment.js
		//! version : 2.5.1
		//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
		//! license : MIT
		//! momentjs.com
		
		(function (undefined) {
		
		    /************************************
		        Constants
		    ************************************/
		
		    var moment,
		        VERSION = "2.5.1",
		        global = this,
		        round = Math.round,
		        i,
		
		        YEAR = 0,
		        MONTH = 1,
		        DATE = 2,
		        HOUR = 3,
		        MINUTE = 4,
		        SECOND = 5,
		        MILLISECOND = 6,
		
		        // internal storage for language config files
		        languages = {},
		
		        // moment internal properties
		        momentProperties = {
		            _isAMomentObject: null,
		            _i : null,
		            _f : null,
		            _l : null,
		            _strict : null,
		            _isUTC : null,
		            _offset : null,  // optional. Combine with _isUTC
		            _pf : null,
		            _lang : null  // optional
		        },
		
		        // check for nodeJS
		        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),
		
		        // ASP.NET json date format regex
		        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
		        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
		
		        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
		        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
		        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
		
		        // format tokens
		        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
		        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
		
		        // parsing token regexes
		        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
		        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
		        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
		        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
		        parseTokenDigits = /\d+/, // nonzero number of digits
		        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
		        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
		        parseTokenT = /T/i, // T (ISO separator)
		        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
		
		        //strict parsing regexes
		        parseTokenOneDigit = /\d/, // 0 - 9
		        parseTokenTwoDigits = /\d\d/, // 00 - 99
		        parseTokenThreeDigits = /\d{3}/, // 000 - 999
		        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
		        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
		        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf
		
		        // iso 8601 regex
		        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
		        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		
		        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
		
		        isoDates = [
		            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
		            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
		            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
		            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
		            ['YYYY-DDD', /\d{4}-\d{3}/]
		        ],
		
		        // iso time formats and regexes
		        isoTimes = [
		            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
		            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
		            ['HH:mm', /(T| )\d\d:\d\d/],
		            ['HH', /(T| )\d\d/]
		        ],
		
		        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
		        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
		
		        // getter and setter names
		        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
		        unitMillisecondFactors = {
		            'Milliseconds' : 1,
		            'Seconds' : 1e3,
		            'Minutes' : 6e4,
		            'Hours' : 36e5,
		            'Days' : 864e5,
		            'Months' : 2592e6,
		            'Years' : 31536e6
		        },
		
		        unitAliases = {
		            ms : 'millisecond',
		            s : 'second',
		            m : 'minute',
		            h : 'hour',
		            d : 'day',
		            D : 'date',
		            w : 'week',
		            W : 'isoWeek',
		            M : 'month',
		            y : 'year',
		            DDD : 'dayOfYear',
		            e : 'weekday',
		            E : 'isoWeekday',
		            gg: 'weekYear',
		            GG: 'isoWeekYear'
		        },
		
		        camelFunctions = {
		            dayofyear : 'dayOfYear',
		            isoweekday : 'isoWeekday',
		            isoweek : 'isoWeek',
		            weekyear : 'weekYear',
		            isoweekyear : 'isoWeekYear'
		        },
		
		        // format function strings
		        formatFunctions = {},
		
		        // tokens to ordinalize and pad
		        ordinalizeTokens = 'DDD w W M D d'.split(' '),
		        paddedTokens = 'M D H h m s w W'.split(' '),
		
		        formatTokenFunctions = {
		            M    : function () {
		                return this.month() + 1;
		            },
		            MMM  : function (format) {
		                return this.lang().monthsShort(this, format);
		            },
		            MMMM : function (format) {
		                return this.lang().months(this, format);
		            },
		            D    : function () {
		                return this.date();
		            },
		            DDD  : function () {
		                return this.dayOfYear();
		            },
		            d    : function () {
		                return this.day();
		            },
		            dd   : function (format) {
		                return this.lang().weekdaysMin(this, format);
		            },
		            ddd  : function (format) {
		                return this.lang().weekdaysShort(this, format);
		            },
		            dddd : function (format) {
		                return this.lang().weekdays(this, format);
		            },
		            w    : function () {
		                return this.week();
		            },
		            W    : function () {
		                return this.isoWeek();
		            },
		            YY   : function () {
		                return leftZeroFill(this.year() % 100, 2);
		            },
		            YYYY : function () {
		                return leftZeroFill(this.year(), 4);
		            },
		            YYYYY : function () {
		                return leftZeroFill(this.year(), 5);
		            },
		            YYYYYY : function () {
		                var y = this.year(), sign = y >= 0 ? '+' : '-';
		                return sign + leftZeroFill(Math.abs(y), 6);
		            },
		            gg   : function () {
		                return leftZeroFill(this.weekYear() % 100, 2);
		            },
		            gggg : function () {
		                return leftZeroFill(this.weekYear(), 4);
		            },
		            ggggg : function () {
		                return leftZeroFill(this.weekYear(), 5);
		            },
		            GG   : function () {
		                return leftZeroFill(this.isoWeekYear() % 100, 2);
		            },
		            GGGG : function () {
		                return leftZeroFill(this.isoWeekYear(), 4);
		            },
		            GGGGG : function () {
		                return leftZeroFill(this.isoWeekYear(), 5);
		            },
		            e : function () {
		                return this.weekday();
		            },
		            E : function () {
		                return this.isoWeekday();
		            },
		            a    : function () {
		                return this.lang().meridiem(this.hours(), this.minutes(), true);
		            },
		            A    : function () {
		                return this.lang().meridiem(this.hours(), this.minutes(), false);
		            },
		            H    : function () {
		                return this.hours();
		            },
		            h    : function () {
		                return this.hours() % 12 || 12;
		            },
		            m    : function () {
		                return this.minutes();
		            },
		            s    : function () {
		                return this.seconds();
		            },
		            S    : function () {
		                return toInt(this.milliseconds() / 100);
		            },
		            SS   : function () {
		                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
		            },
		            SSS  : function () {
		                return leftZeroFill(this.milliseconds(), 3);
		            },
		            SSSS : function () {
		                return leftZeroFill(this.milliseconds(), 3);
		            },
		            Z    : function () {
		                var a = -this.zone(),
		                    b = "+";
		                if (a < 0) {
		                    a = -a;
		                    b = "-";
		                }
		                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
		            },
		            ZZ   : function () {
		                var a = -this.zone(),
		                    b = "+";
		                if (a < 0) {
		                    a = -a;
		                    b = "-";
		                }
		                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
		            },
		            z : function () {
		                return this.zoneAbbr();
		            },
		            zz : function () {
		                return this.zoneName();
		            },
		            X    : function () {
		                return this.unix();
		            },
		            Q : function () {
		                return this.quarter();
		            }
		        },
		
		        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
		
		    function defaultParsingFlags() {
		        // We need to deep clone this object, and es5 standard is not very
		        // helpful.
		        return {
		            empty : false,
		            unusedTokens : [],
		            unusedInput : [],
		            overflow : -2,
		            charsLeftOver : 0,
		            nullInput : false,
		            invalidMonth : null,
		            invalidFormat : false,
		            userInvalidated : false,
		            iso: false
		        };
		    }
		
		    function padToken(func, count) {
		        return function (a) {
		            return leftZeroFill(func.call(this, a), count);
		        };
		    }
		    function ordinalizeToken(func, period) {
		        return function (a) {
		            return this.lang().ordinal(func.call(this, a), period);
		        };
		    }
		
		    while (ordinalizeTokens.length) {
		        i = ordinalizeTokens.pop();
		        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
		    }
		    while (paddedTokens.length) {
		        i = paddedTokens.pop();
		        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
		    }
		    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
		
		
		    /************************************
		        Constructors
		    ************************************/
		
		    function Language() {
		
		    }
		
		    // Moment prototype object
		    function Moment(config) {
		        checkOverflow(config);
		        extend(this, config);
		    }
		
		    // Duration Constructor
		    function Duration(duration) {
		        var normalizedInput = normalizeObjectUnits(duration),
		            years = normalizedInput.year || 0,
		            months = normalizedInput.month || 0,
		            weeks = normalizedInput.week || 0,
		            days = normalizedInput.day || 0,
		            hours = normalizedInput.hour || 0,
		            minutes = normalizedInput.minute || 0,
		            seconds = normalizedInput.second || 0,
		            milliseconds = normalizedInput.millisecond || 0;
		
		        // representation for dateAddRemove
		        this._milliseconds = +milliseconds +
		            seconds * 1e3 + // 1000
		            minutes * 6e4 + // 1000 * 60
		            hours * 36e5; // 1000 * 60 * 60
		        // Because of dateAddRemove treats 24 hours as different from a
		        // day when working around DST, we need to store them separately
		        this._days = +days +
		            weeks * 7;
		        // It is impossible translate months into days without knowing
		        // which months you are are talking about, so we have to store
		        // it separately.
		        this._months = +months +
		            years * 12;
		
		        this._data = {};
		
		        this._bubble();
		    }
		
		    /************************************
		        Helpers
		    ************************************/
		
		
		    function extend(a, b) {
		        for (var i in b) {
		            if (b.hasOwnProperty(i)) {
		                a[i] = b[i];
		            }
		        }
		
		        if (b.hasOwnProperty("toString")) {
		            a.toString = b.toString;
		        }
		
		        if (b.hasOwnProperty("valueOf")) {
		            a.valueOf = b.valueOf;
		        }
		
		        return a;
		    }
		
		    function cloneMoment(m) {
		        var result = {}, i;
		        for (i in m) {
		            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
		                result[i] = m[i];
		            }
		        }
		
		        return result;
		    }
		
		    function absRound(number) {
		        if (number < 0) {
		            return Math.ceil(number);
		        } else {
		            return Math.floor(number);
		        }
		    }
		
		    // left zero fill a number
		    // see http://jsperf.com/left-zero-filling for performance comparison
		    function leftZeroFill(number, targetLength, forceSign) {
		        var output = '' + Math.abs(number),
		            sign = number >= 0;
		
		        while (output.length < targetLength) {
		            output = '0' + output;
		        }
		        return (sign ? (forceSign ? '+' : '') : '-') + output;
		    }
		
		    // helper function for _.addTime and _.subtractTime
		    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
		        var milliseconds = duration._milliseconds,
		            days = duration._days,
		            months = duration._months,
		            minutes,
		            hours;
		
		        if (milliseconds) {
		            mom._d.setTime(+mom._d + milliseconds * isAdding);
		        }
		        // store the minutes and hours so we can restore them
		        if (days || months) {
		            minutes = mom.minute();
		            hours = mom.hour();
		        }
		        if (days) {
		            mom.date(mom.date() + days * isAdding);
		        }
		        if (months) {
		            mom.month(mom.month() + months * isAdding);
		        }
		        if (milliseconds && !ignoreUpdateOffset) {
		            moment.updateOffset(mom);
		        }
		        // restore the minutes and hours after possibly changing dst
		        if (days || months) {
		            mom.minute(minutes);
		            mom.hour(hours);
		        }
		    }
		
		    // check if is an array
		    function isArray(input) {
		        return Object.prototype.toString.call(input) === '[object Array]';
		    }
		
		    function isDate(input) {
		        return  Object.prototype.toString.call(input) === '[object Date]' ||
		                input instanceof Date;
		    }
		
		    // compare two arrays, return the number of differences
		    function compareArrays(array1, array2, dontConvert) {
		        var len = Math.min(array1.length, array2.length),
		            lengthDiff = Math.abs(array1.length - array2.length),
		            diffs = 0,
		            i;
		        for (i = 0; i < len; i++) {
		            if ((dontConvert && array1[i] !== array2[i]) ||
		                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
		                diffs++;
		            }
		        }
		        return diffs + lengthDiff;
		    }
		
		    function normalizeUnits(units) {
		        if (units) {
		            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
		            units = unitAliases[units] || camelFunctions[lowered] || lowered;
		        }
		        return units;
		    }
		
		    function normalizeObjectUnits(inputObject) {
		        var normalizedInput = {},
		            normalizedProp,
		            prop;
		
		        for (prop in inputObject) {
		            if (inputObject.hasOwnProperty(prop)) {
		                normalizedProp = normalizeUnits(prop);
		                if (normalizedProp) {
		                    normalizedInput[normalizedProp] = inputObject[prop];
		                }
		            }
		        }
		
		        return normalizedInput;
		    }
		
		    function makeList(field) {
		        var count, setter;
		
		        if (field.indexOf('week') === 0) {
		            count = 7;
		            setter = 'day';
		        }
		        else if (field.indexOf('month') === 0) {
		            count = 12;
		            setter = 'month';
		        }
		        else {
		            return;
		        }
		
		        moment[field] = function (format, index) {
		            var i, getter,
		                method = moment.fn._lang[field],
		                results = [];
		
		            if (typeof format === 'number') {
		                index = format;
		                format = undefined;
		            }
		
		            getter = function (i) {
		                var m = moment().utc().set(setter, i);
		                return method.call(moment.fn._lang, m, format || '');
		            };
		
		            if (index != null) {
		                return getter(index);
		            }
		            else {
		                for (i = 0; i < count; i++) {
		                    results.push(getter(i));
		                }
		                return results;
		            }
		        };
		    }
		
		    function toInt(argumentForCoercion) {
		        var coercedNumber = +argumentForCoercion,
		            value = 0;
		
		        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
		            if (coercedNumber >= 0) {
		                value = Math.floor(coercedNumber);
		            } else {
		                value = Math.ceil(coercedNumber);
		            }
		        }
		
		        return value;
		    }
		
		    function daysInMonth(year, month) {
		        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
		    }
		
		    function daysInYear(year) {
		        return isLeapYear(year) ? 366 : 365;
		    }
		
		    function isLeapYear(year) {
		        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
		    }
		
		    function checkOverflow(m) {
		        var overflow;
		        if (m._a && m._pf.overflow === -2) {
		            overflow =
		                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
		                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
		                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
		                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
		                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
		                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
		                -1;
		
		            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
		                overflow = DATE;
		            }
		
		            m._pf.overflow = overflow;
		        }
		    }
		
		    function isValid(m) {
		        if (m._isValid == null) {
		            m._isValid = !isNaN(m._d.getTime()) &&
		                m._pf.overflow < 0 &&
		                !m._pf.empty &&
		                !m._pf.invalidMonth &&
		                !m._pf.nullInput &&
		                !m._pf.invalidFormat &&
		                !m._pf.userInvalidated;
		
		            if (m._strict) {
		                m._isValid = m._isValid &&
		                    m._pf.charsLeftOver === 0 &&
		                    m._pf.unusedTokens.length === 0;
		            }
		        }
		        return m._isValid;
		    }
		
		    function normalizeLanguage(key) {
		        return key ? key.toLowerCase().replace('_', '-') : key;
		    }
		
		    // Return a moment from input, that is local/utc/zone equivalent to model.
		    function makeAs(input, model) {
		        return model._isUTC ? moment(input).zone(model._offset || 0) :
		            moment(input).local();
		    }
		
		    /************************************
		        Languages
		    ************************************/
		
		
		    extend(Language.prototype, {
		
		        set : function (config) {
		            var prop, i;
		            for (i in config) {
		                prop = config[i];
		                if (typeof prop === 'function') {
		                    this[i] = prop;
		                } else {
		                    this['_' + i] = prop;
		                }
		            }
		        },
		
		        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
		        months : function (m) {
		            return this._months[m.month()];
		        },
		
		        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
		        monthsShort : function (m) {
		            return this._monthsShort[m.month()];
		        },
		
		        monthsParse : function (monthName) {
		            var i, mom, regex;
		
		            if (!this._monthsParse) {
		                this._monthsParse = [];
		            }
		
		            for (i = 0; i < 12; i++) {
		                // make the regex if we don't have it already
		                if (!this._monthsParse[i]) {
		                    mom = moment.utc([2000, i]);
		                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
		                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
		                }
		                // test the regex
		                if (this._monthsParse[i].test(monthName)) {
		                    return i;
		                }
		            }
		        },
		
		        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
		        weekdays : function (m) {
		            return this._weekdays[m.day()];
		        },
		
		        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
		        weekdaysShort : function (m) {
		            return this._weekdaysShort[m.day()];
		        },
		
		        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
		        weekdaysMin : function (m) {
		            return this._weekdaysMin[m.day()];
		        },
		
		        weekdaysParse : function (weekdayName) {
		            var i, mom, regex;
		
		            if (!this._weekdaysParse) {
		                this._weekdaysParse = [];
		            }
		
		            for (i = 0; i < 7; i++) {
		                // make the regex if we don't have it already
		                if (!this._weekdaysParse[i]) {
		                    mom = moment([2000, 1]).day(i);
		                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
		                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
		                }
		                // test the regex
		                if (this._weekdaysParse[i].test(weekdayName)) {
		                    return i;
		                }
		            }
		        },
		
		        _longDateFormat : {
		            LT : "h:mm A",
		            L : "MM/DD/YYYY",
		            LL : "MMMM D YYYY",
		            LLL : "MMMM D YYYY LT",
		            LLLL : "dddd, MMMM D YYYY LT"
		        },
		        longDateFormat : function (key) {
		            var output = this._longDateFormat[key];
		            if (!output && this._longDateFormat[key.toUpperCase()]) {
		                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
		                    return val.slice(1);
		                });
		                this._longDateFormat[key] = output;
		            }
		            return output;
		        },
		
		        isPM : function (input) {
		            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
		            // Using charAt should be more compatible.
		            return ((input + '').toLowerCase().charAt(0) === 'p');
		        },
		
		        _meridiemParse : /[ap]\.?m?\.?/i,
		        meridiem : function (hours, minutes, isLower) {
		            if (hours > 11) {
		                return isLower ? 'pm' : 'PM';
		            } else {
		                return isLower ? 'am' : 'AM';
		            }
		        },
		
		        _calendar : {
		            sameDay : '[Today at] LT',
		            nextDay : '[Tomorrow at] LT',
		            nextWeek : 'dddd [at] LT',
		            lastDay : '[Yesterday at] LT',
		            lastWeek : '[Last] dddd [at] LT',
		            sameElse : 'L'
		        },
		        calendar : function (key, mom) {
		            var output = this._calendar[key];
		            return typeof output === 'function' ? output.apply(mom) : output;
		        },
		
		        _relativeTime : {
		            future : "in %s",
		            past : "%s ago",
		            s : "a few seconds",
		            m : "a minute",
		            mm : "%d minutes",
		            h : "an hour",
		            hh : "%d hours",
		            d : "a day",
		            dd : "%d days",
		            M : "a month",
		            MM : "%d months",
		            y : "a year",
		            yy : "%d years"
		        },
		        relativeTime : function (number, withoutSuffix, string, isFuture) {
		            var output = this._relativeTime[string];
		            return (typeof output === 'function') ?
		                output(number, withoutSuffix, string, isFuture) :
		                output.replace(/%d/i, number);
		        },
		        pastFuture : function (diff, output) {
		            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
		            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
		        },
		
		        ordinal : function (number) {
		            return this._ordinal.replace("%d", number);
		        },
		        _ordinal : "%d",
		
		        preparse : function (string) {
		            return string;
		        },
		
		        postformat : function (string) {
		            return string;
		        },
		
		        week : function (mom) {
		            return weekOfYear(mom, this._week.dow, this._week.doy).week;
		        },
		
		        _week : {
		            dow : 0, // Sunday is the first day of the week.
		            doy : 6  // The week that contains Jan 1st is the first week of the year.
		        },
		
		        _invalidDate: 'Invalid date',
		        invalidDate: function () {
		            return this._invalidDate;
		        }
		    });
		
		    // Loads a language definition into the `languages` cache.  The function
		    // takes a key and optionally values.  If not in the browser and no values
		    // are provided, it will load the language file module.  As a convenience,
		    // this function also returns the language values.
		    function loadLang(key, values) {
		        values.abbr = key;
		        if (!languages[key]) {
		            languages[key] = new Language();
		        }
		        languages[key].set(values);
		        return languages[key];
		    }
		
		    // Remove a language from the `languages` cache. Mostly useful in tests.
		    function unloadLang(key) {
		        delete languages[key];
		    }
		
		    // Determines which language definition to use and returns it.
		    //
		    // With no parameters, it will return the global language.  If you
		    // pass in a language key, such as 'en', it will return the
		    // definition for 'en', so long as 'en' has already been loaded using
		    // moment.lang.
		    function getLangDefinition(key) {
		        var i = 0, j, lang, next, split,
		            get = function (k) {
		                if (!languages[k] && hasModule) {
		                    try {
		                        require('./lang/' + k);
		                    } catch (e) { }
		                }
		                return languages[k];
		            };
		
		        if (!key) {
		            return moment.fn._lang;
		        }
		
		        if (!isArray(key)) {
		            //short-circuit everything else
		            lang = get(key);
		            if (lang) {
		                return lang;
		            }
		            key = [key];
		        }
		
		        //pick the language from the array
		        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
		        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
		        while (i < key.length) {
		            split = normalizeLanguage(key[i]).split('-');
		            j = split.length;
		            next = normalizeLanguage(key[i + 1]);
		            next = next ? next.split('-') : null;
		            while (j > 0) {
		                lang = get(split.slice(0, j).join('-'));
		                if (lang) {
		                    return lang;
		                }
		                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
		                    //the next array item is better than a shallower substring of this one
		                    break;
		                }
		                j--;
		            }
		            i++;
		        }
		        return moment.fn._lang;
		    }
		
		    /************************************
		        Formatting
		    ************************************/
		
		
		    function removeFormattingTokens(input) {
		        if (input.match(/\[[\s\S]/)) {
		            return input.replace(/^\[|\]$/g, "");
		        }
		        return input.replace(/\\/g, "");
		    }
		
		    function makeFormatFunction(format) {
		        var array = format.match(formattingTokens), i, length;
		
		        for (i = 0, length = array.length; i < length; i++) {
		            if (formatTokenFunctions[array[i]]) {
		                array[i] = formatTokenFunctions[array[i]];
		            } else {
		                array[i] = removeFormattingTokens(array[i]);
		            }
		        }
		
		        return function (mom) {
		            var output = "";
		            for (i = 0; i < length; i++) {
		                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
		            }
		            return output;
		        };
		    }
		
		    // format date using native date object
		    function formatMoment(m, format) {
		
		        if (!m.isValid()) {
		            return m.lang().invalidDate();
		        }
		
		        format = expandFormat(format, m.lang());
		
		        if (!formatFunctions[format]) {
		            formatFunctions[format] = makeFormatFunction(format);
		        }
		
		        return formatFunctions[format](m);
		    }
		
		    function expandFormat(format, lang) {
		        var i = 5;
		
		        function replaceLongDateFormatTokens(input) {
		            return lang.longDateFormat(input) || input;
		        }
		
		        localFormattingTokens.lastIndex = 0;
		        while (i >= 0 && localFormattingTokens.test(format)) {
		            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
		            localFormattingTokens.lastIndex = 0;
		            i -= 1;
		        }
		
		        return format;
		    }
		
		
		    /************************************
		        Parsing
		    ************************************/
		
		
		    // get the regex to find the next token
		    function getParseRegexForToken(token, config) {
		        var a, strict = config._strict;
		        switch (token) {
		        case 'DDDD':
		            return parseTokenThreeDigits;
		        case 'YYYY':
		        case 'GGGG':
		        case 'gggg':
		            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
		        case 'Y':
		        case 'G':
		        case 'g':
		            return parseTokenSignedNumber;
		        case 'YYYYYY':
		        case 'YYYYY':
		        case 'GGGGG':
		        case 'ggggg':
		            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
		        case 'S':
		            if (strict) { return parseTokenOneDigit; }
		            /* falls through */
		        case 'SS':
		            if (strict) { return parseTokenTwoDigits; }
		            /* falls through */
		        case 'SSS':
		            if (strict) { return parseTokenThreeDigits; }
		            /* falls through */
		        case 'DDD':
		            return parseTokenOneToThreeDigits;
		        case 'MMM':
		        case 'MMMM':
		        case 'dd':
		        case 'ddd':
		        case 'dddd':
		            return parseTokenWord;
		        case 'a':
		        case 'A':
		            return getLangDefinition(config._l)._meridiemParse;
		        case 'X':
		            return parseTokenTimestampMs;
		        case 'Z':
		        case 'ZZ':
		            return parseTokenTimezone;
		        case 'T':
		            return parseTokenT;
		        case 'SSSS':
		            return parseTokenDigits;
		        case 'MM':
		        case 'DD':
		        case 'YY':
		        case 'GG':
		        case 'gg':
		        case 'HH':
		        case 'hh':
		        case 'mm':
		        case 'ss':
		        case 'ww':
		        case 'WW':
		            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
		        case 'M':
		        case 'D':
		        case 'd':
		        case 'H':
		        case 'h':
		        case 'm':
		        case 's':
		        case 'w':
		        case 'W':
		        case 'e':
		        case 'E':
		            return parseTokenOneOrTwoDigits;
		        default :
		            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
		            return a;
		        }
		    }
		
		    function timezoneMinutesFromString(string) {
		        string = string || "";
		        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
		            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
		            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
		            minutes = +(parts[1] * 60) + toInt(parts[2]);
		
		        return parts[0] === '+' ? -minutes : minutes;
		    }
		
		    // function to convert string input to date
		    function addTimeToArrayFromToken(token, input, config) {
		        var a, datePartArray = config._a;
		
		        switch (token) {
		        // MONTH
		        case 'M' : // fall through to MM
		        case 'MM' :
		            if (input != null) {
		                datePartArray[MONTH] = toInt(input) - 1;
		            }
		            break;
		        case 'MMM' : // fall through to MMMM
		        case 'MMMM' :
		            a = getLangDefinition(config._l).monthsParse(input);
		            // if we didn't find a month name, mark the date as invalid.
		            if (a != null) {
		                datePartArray[MONTH] = a;
		            } else {
		                config._pf.invalidMonth = input;
		            }
		            break;
		        // DAY OF MONTH
		        case 'D' : // fall through to DD
		        case 'DD' :
		            if (input != null) {
		                datePartArray[DATE] = toInt(input);
		            }
		            break;
		        // DAY OF YEAR
		        case 'DDD' : // fall through to DDDD
		        case 'DDDD' :
		            if (input != null) {
		                config._dayOfYear = toInt(input);
		            }
		
		            break;
		        // YEAR
		        case 'YY' :
		            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
		            break;
		        case 'YYYY' :
		        case 'YYYYY' :
		        case 'YYYYYY' :
		            datePartArray[YEAR] = toInt(input);
		            break;
		        // AM / PM
		        case 'a' : // fall through to A
		        case 'A' :
		            config._isPm = getLangDefinition(config._l).isPM(input);
		            break;
		        // 24 HOUR
		        case 'H' : // fall through to hh
		        case 'HH' : // fall through to hh
		        case 'h' : // fall through to hh
		        case 'hh' :
		            datePartArray[HOUR] = toInt(input);
		            break;
		        // MINUTE
		        case 'm' : // fall through to mm
		        case 'mm' :
		            datePartArray[MINUTE] = toInt(input);
		            break;
		        // SECOND
		        case 's' : // fall through to ss
		        case 'ss' :
		            datePartArray[SECOND] = toInt(input);
		            break;
		        // MILLISECOND
		        case 'S' :
		        case 'SS' :
		        case 'SSS' :
		        case 'SSSS' :
		            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
		            break;
		        // UNIX TIMESTAMP WITH MS
		        case 'X':
		            config._d = new Date(parseFloat(input) * 1000);
		            break;
		        // TIMEZONE
		        case 'Z' : // fall through to ZZ
		        case 'ZZ' :
		            config._useUTC = true;
		            config._tzm = timezoneMinutesFromString(input);
		            break;
		        case 'w':
		        case 'ww':
		        case 'W':
		        case 'WW':
		        case 'd':
		        case 'dd':
		        case 'ddd':
		        case 'dddd':
		        case 'e':
		        case 'E':
		            token = token.substr(0, 1);
		            /* falls through */
		        case 'gg':
		        case 'gggg':
		        case 'GG':
		        case 'GGGG':
		        case 'GGGGG':
		            token = token.substr(0, 2);
		            if (input) {
		                config._w = config._w || {};
		                config._w[token] = input;
		            }
		            break;
		        }
		    }
		
		    // convert an array to a date.
		    // the array should mirror the parameters below
		    // note: all values past the year are optional and will default to the lowest possible value.
		    // [year, month, day , hour, minute, second, millisecond]
		    function dateFromConfig(config) {
		        var i, date, input = [], currentDate,
		            yearToUse, fixYear, w, temp, lang, weekday, week;
		
		        if (config._d) {
		            return;
		        }
		
		        currentDate = currentDateArray(config);
		
		        //compute day of the year from weeks and weekdays
		        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
		            fixYear = function (val) {
		                var int_val = parseInt(val, 10);
		                return val ?
		                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
		                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
		            };
		
		            w = config._w;
		            if (w.GG != null || w.W != null || w.E != null) {
		                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
		            }
		            else {
		                lang = getLangDefinition(config._l);
		                weekday = w.d != null ?  parseWeekday(w.d, lang) :
		                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);
		
		                week = parseInt(w.w, 10) || 1;
		
		                //if we're parsing 'd', then the low day numbers may be next week
		                if (w.d != null && weekday < lang._week.dow) {
		                    week++;
		                }
		
		                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
		            }
		
		            config._a[YEAR] = temp.year;
		            config._dayOfYear = temp.dayOfYear;
		        }
		
		        //if the day of the year is set, figure out what it is
		        if (config._dayOfYear) {
		            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];
		
		            if (config._dayOfYear > daysInYear(yearToUse)) {
		                config._pf._overflowDayOfYear = true;
		            }
		
		            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
		            config._a[MONTH] = date.getUTCMonth();
		            config._a[DATE] = date.getUTCDate();
		        }
		
		        // Default to current date.
		        // * if no year, month, day of month are given, default to today
		        // * if day of month is given, default month and year
		        // * if month is given, default only year
		        // * if year is given, don't default anything
		        for (i = 0; i < 3 && config._a[i] == null; ++i) {
		            config._a[i] = input[i] = currentDate[i];
		        }
		
		        // Zero out whatever was not defaulted, including time
		        for (; i < 7; i++) {
		            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
		        }
		
		        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
		        input[HOUR] += toInt((config._tzm || 0) / 60);
		        input[MINUTE] += toInt((config._tzm || 0) % 60);
		
		        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
		    }
		
		    function dateFromObject(config) {
		        var normalizedInput;
		
		        if (config._d) {
		            return;
		        }
		
		        normalizedInput = normalizeObjectUnits(config._i);
		        config._a = [
		            normalizedInput.year,
		            normalizedInput.month,
		            normalizedInput.day,
		            normalizedInput.hour,
		            normalizedInput.minute,
		            normalizedInput.second,
		            normalizedInput.millisecond
		        ];
		
		        dateFromConfig(config);
		    }
		
		    function currentDateArray(config) {
		        var now = new Date();
		        if (config._useUTC) {
		            return [
		                now.getUTCFullYear(),
		                now.getUTCMonth(),
		                now.getUTCDate()
		            ];
		        } else {
		            return [now.getFullYear(), now.getMonth(), now.getDate()];
		        }
		    }
		
		    // date from string and format string
		    function makeDateFromStringAndFormat(config) {
		
		        config._a = [];
		        config._pf.empty = true;
		
		        // This array is used to make a Date, either with `new Date` or `Date.UTC`
		        var lang = getLangDefinition(config._l),
		            string = '' + config._i,
		            i, parsedInput, tokens, token, skipped,
		            stringLength = string.length,
		            totalParsedInputLength = 0;
		
		        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];
		
		        for (i = 0; i < tokens.length; i++) {
		            token = tokens[i];
		            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
		            if (parsedInput) {
		                skipped = string.substr(0, string.indexOf(parsedInput));
		                if (skipped.length > 0) {
		                    config._pf.unusedInput.push(skipped);
		                }
		                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
		                totalParsedInputLength += parsedInput.length;
		            }
		            // don't parse if it's not a known token
		            if (formatTokenFunctions[token]) {
		                if (parsedInput) {
		                    config._pf.empty = false;
		                }
		                else {
		                    config._pf.unusedTokens.push(token);
		                }
		                addTimeToArrayFromToken(token, parsedInput, config);
		            }
		            else if (config._strict && !parsedInput) {
		                config._pf.unusedTokens.push(token);
		            }
		        }
		
		        // add remaining unparsed input length to the string
		        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
		        if (string.length > 0) {
		            config._pf.unusedInput.push(string);
		        }
		
		        // handle am pm
		        if (config._isPm && config._a[HOUR] < 12) {
		            config._a[HOUR] += 12;
		        }
		        // if is 12 am, change hours to 0
		        if (config._isPm === false && config._a[HOUR] === 12) {
		            config._a[HOUR] = 0;
		        }
		
		        dateFromConfig(config);
		        checkOverflow(config);
		    }
		
		    function unescapeFormat(s) {
		        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
		            return p1 || p2 || p3 || p4;
		        });
		    }
		
		    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
		    function regexpEscape(s) {
		        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
		    }
		
		    // date from string and array of format strings
		    function makeDateFromStringAndArray(config) {
		        var tempConfig,
		            bestMoment,
		
		            scoreToBeat,
		            i,
		            currentScore;
		
		        if (config._f.length === 0) {
		            config._pf.invalidFormat = true;
		            config._d = new Date(NaN);
		            return;
		        }
		
		        for (i = 0; i < config._f.length; i++) {
		            currentScore = 0;
		            tempConfig = extend({}, config);
		            tempConfig._pf = defaultParsingFlags();
		            tempConfig._f = config._f[i];
		            makeDateFromStringAndFormat(tempConfig);
		
		            if (!isValid(tempConfig)) {
		                continue;
		            }
		
		            // if there is any input that was not parsed add a penalty for that format
		            currentScore += tempConfig._pf.charsLeftOver;
		
		            //or tokens
		            currentScore += tempConfig._pf.unusedTokens.length * 10;
		
		            tempConfig._pf.score = currentScore;
		
		            if (scoreToBeat == null || currentScore < scoreToBeat) {
		                scoreToBeat = currentScore;
		                bestMoment = tempConfig;
		            }
		        }
		
		        extend(config, bestMoment || tempConfig);
		    }
		
		    // date from iso format
		    function makeDateFromString(config) {
		        var i, l,
		            string = config._i,
		            match = isoRegex.exec(string);
		
		        if (match) {
		            config._pf.iso = true;
		            for (i = 0, l = isoDates.length; i < l; i++) {
		                if (isoDates[i][1].exec(string)) {
		                    // match[5] should be "T" or undefined
		                    config._f = isoDates[i][0] + (match[6] || " ");
		                    break;
		                }
		            }
		            for (i = 0, l = isoTimes.length; i < l; i++) {
		                if (isoTimes[i][1].exec(string)) {
		                    config._f += isoTimes[i][0];
		                    break;
		                }
		            }
		            if (string.match(parseTokenTimezone)) {
		                config._f += "Z";
		            }
		            makeDateFromStringAndFormat(config);
		        }
		        else {
		            config._d = new Date(string);
		        }
		    }
		
		    function makeDateFromInput(config) {
		        var input = config._i,
		            matched = aspNetJsonRegex.exec(input);
		
		        if (input === undefined) {
		            config._d = new Date();
		        } else if (matched) {
		            config._d = new Date(+matched[1]);
		        } else if (typeof input === 'string') {
		            makeDateFromString(config);
		        } else if (isArray(input)) {
		            config._a = input.slice(0);
		            dateFromConfig(config);
		        } else if (isDate(input)) {
		            config._d = new Date(+input);
		        } else if (typeof(input) === 'object') {
		            dateFromObject(config);
		        } else {
		            config._d = new Date(input);
		        }
		    }
		
		    function makeDate(y, m, d, h, M, s, ms) {
		        //can't just apply() to create a date:
		        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
		        var date = new Date(y, m, d, h, M, s, ms);
		
		        //the date constructor doesn't accept years < 1970
		        if (y < 1970) {
		            date.setFullYear(y);
		        }
		        return date;
		    }
		
		    function makeUTCDate(y) {
		        var date = new Date(Date.UTC.apply(null, arguments));
		        if (y < 1970) {
		            date.setUTCFullYear(y);
		        }
		        return date;
		    }
		
		    function parseWeekday(input, language) {
		        if (typeof input === 'string') {
		            if (!isNaN(input)) {
		                input = parseInt(input, 10);
		            }
		            else {
		                input = language.weekdaysParse(input);
		                if (typeof input !== 'number') {
		                    return null;
		                }
		            }
		        }
		        return input;
		    }
		
		    /************************************
		        Relative Time
		    ************************************/
		
		
		    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
		    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
		        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
		    }
		
		    function relativeTime(milliseconds, withoutSuffix, lang) {
		        var seconds = round(Math.abs(milliseconds) / 1000),
		            minutes = round(seconds / 60),
		            hours = round(minutes / 60),
		            days = round(hours / 24),
		            years = round(days / 365),
		            args = seconds < 45 && ['s', seconds] ||
		                minutes === 1 && ['m'] ||
		                minutes < 45 && ['mm', minutes] ||
		                hours === 1 && ['h'] ||
		                hours < 22 && ['hh', hours] ||
		                days === 1 && ['d'] ||
		                days <= 25 && ['dd', days] ||
		                days <= 45 && ['M'] ||
		                days < 345 && ['MM', round(days / 30)] ||
		                years === 1 && ['y'] || ['yy', years];
		        args[2] = withoutSuffix;
		        args[3] = milliseconds > 0;
		        args[4] = lang;
		        return substituteTimeAgo.apply({}, args);
		    }
		
		
		    /************************************
		        Week of Year
		    ************************************/
		
		
		    // firstDayOfWeek       0 = sun, 6 = sat
		    //                      the day of the week that starts the week
		    //                      (usually sunday or monday)
		    // firstDayOfWeekOfYear 0 = sun, 6 = sat
		    //                      the first week is the week that contains the first
		    //                      of this day of the week
		    //                      (eg. ISO weeks use thursday (4))
		    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
		        var end = firstDayOfWeekOfYear - firstDayOfWeek,
		            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
		            adjustedMoment;
		
		
		        if (daysToDayOfWeek > end) {
		            daysToDayOfWeek -= 7;
		        }
		
		        if (daysToDayOfWeek < end - 7) {
		            daysToDayOfWeek += 7;
		        }
		
		        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
		        return {
		            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
		            year: adjustedMoment.year()
		        };
		    }
		
		    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
		    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
		        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
		
		        weekday = weekday != null ? weekday : firstDayOfWeek;
		        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
		        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
		
		        return {
		            year: dayOfYear > 0 ? year : year - 1,
		            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
		        };
		    }
		
		    /************************************
		        Top Level Functions
		    ************************************/
		
		    function makeMoment(config) {
		        var input = config._i,
		            format = config._f;
		
		        if (input === null) {
		            return moment.invalid({nullInput: true});
		        }
		
		        if (typeof input === 'string') {
		            config._i = input = getLangDefinition().preparse(input);
		        }
		
		        if (moment.isMoment(input)) {
		            config = cloneMoment(input);
		
		            config._d = new Date(+input._d);
		        } else if (format) {
		            if (isArray(format)) {
		                makeDateFromStringAndArray(config);
		            } else {
		                makeDateFromStringAndFormat(config);
		            }
		        } else {
		            makeDateFromInput(config);
		        }
		
		        return new Moment(config);
		    }
		
		    moment = function (input, format, lang, strict) {
		        var c;
		
		        if (typeof(lang) === "boolean") {
		            strict = lang;
		            lang = undefined;
		        }
		        // object construction must be done this way.
		        // https://github.com/moment/moment/issues/1423
		        c = {};
		        c._isAMomentObject = true;
		        c._i = input;
		        c._f = format;
		        c._l = lang;
		        c._strict = strict;
		        c._isUTC = false;
		        c._pf = defaultParsingFlags();
		
		        return makeMoment(c);
		    };
		
		    // creating with utc
		    moment.utc = function (input, format, lang, strict) {
		        var c;
		
		        if (typeof(lang) === "boolean") {
		            strict = lang;
		            lang = undefined;
		        }
		        // object construction must be done this way.
		        // https://github.com/moment/moment/issues/1423
		        c = {};
		        c._isAMomentObject = true;
		        c._useUTC = true;
		        c._isUTC = true;
		        c._l = lang;
		        c._i = input;
		        c._f = format;
		        c._strict = strict;
		        c._pf = defaultParsingFlags();
		
		        return makeMoment(c).utc();
		    };
		
		    // creating with unix timestamp (in seconds)
		    moment.unix = function (input) {
		        return moment(input * 1000);
		    };
		
		    // duration
		    moment.duration = function (input, key) {
		        var duration = input,
		            // matching against regexp is expensive, do it on demand
		            match = null,
		            sign,
		            ret,
		            parseIso;
		
		        if (moment.isDuration(input)) {
		            duration = {
		                ms: input._milliseconds,
		                d: input._days,
		                M: input._months
		            };
		        } else if (typeof input === 'number') {
		            duration = {};
		            if (key) {
		                duration[key] = input;
		            } else {
		                duration.milliseconds = input;
		            }
		        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
		            sign = (match[1] === "-") ? -1 : 1;
		            duration = {
		                y: 0,
		                d: toInt(match[DATE]) * sign,
		                h: toInt(match[HOUR]) * sign,
		                m: toInt(match[MINUTE]) * sign,
		                s: toInt(match[SECOND]) * sign,
		                ms: toInt(match[MILLISECOND]) * sign
		            };
		        } else if (!!(match = isoDurationRegex.exec(input))) {
		            sign = (match[1] === "-") ? -1 : 1;
		            parseIso = function (inp) {
		                // We'd normally use ~~inp for this, but unfortunately it also
		                // converts floats to ints.
		                // inp may be undefined, so careful calling replace on it.
		                var res = inp && parseFloat(inp.replace(',', '.'));
		                // apply sign while we're at it
		                return (isNaN(res) ? 0 : res) * sign;
		            };
		            duration = {
		                y: parseIso(match[2]),
		                M: parseIso(match[3]),
		                d: parseIso(match[4]),
		                h: parseIso(match[5]),
		                m: parseIso(match[6]),
		                s: parseIso(match[7]),
		                w: parseIso(match[8])
		            };
		        }
		
		        ret = new Duration(duration);
		
		        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
		            ret._lang = input._lang;
		        }
		
		        return ret;
		    };
		
		    // version number
		    moment.version = VERSION;
		
		    // default format
		    moment.defaultFormat = isoFormat;
		
		    // This function will be called whenever a moment is mutated.
		    // It is intended to keep the offset in sync with the timezone.
		    moment.updateOffset = function () {};
		
		    // This function will load languages and then set the global language.  If
		    // no arguments are passed in, it will simply return the current global
		    // language key.
		    moment.lang = function (key, values) {
		        var r;
		        if (!key) {
		            return moment.fn._lang._abbr;
		        }
		        if (values) {
		            loadLang(normalizeLanguage(key), values);
		        } else if (values === null) {
		            unloadLang(key);
		            key = 'en';
		        } else if (!languages[key]) {
		            getLangDefinition(key);
		        }
		        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
		        return r._abbr;
		    };
		
		    // returns language data
		    moment.langData = function (key) {
		        if (key && key._lang && key._lang._abbr) {
		            key = key._lang._abbr;
		        }
		        return getLangDefinition(key);
		    };
		
		    // compare moment object
		    moment.isMoment = function (obj) {
		        return obj instanceof Moment ||
		            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
		    };
		
		    // for typechecking Duration objects
		    moment.isDuration = function (obj) {
		        return obj instanceof Duration;
		    };
		
		    for (i = lists.length - 1; i >= 0; --i) {
		        makeList(lists[i]);
		    }
		
		    moment.normalizeUnits = function (units) {
		        return normalizeUnits(units);
		    };
		
		    moment.invalid = function (flags) {
		        var m = moment.utc(NaN);
		        if (flags != null) {
		            extend(m._pf, flags);
		        }
		        else {
		            m._pf.userInvalidated = true;
		        }
		
		        return m;
		    };
		
		    moment.parseZone = function (input) {
		        return moment(input).parseZone();
		    };
		
		    /************************************
		        Moment Prototype
		    ************************************/
		
		
		    extend(moment.fn = Moment.prototype, {
		
		        clone : function () {
		            return moment(this);
		        },
		
		        valueOf : function () {
		            return +this._d + ((this._offset || 0) * 60000);
		        },
		
		        unix : function () {
		            return Math.floor(+this / 1000);
		        },
		
		        toString : function () {
		            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
		        },
		
		        toDate : function () {
		            return this._offset ? new Date(+this) : this._d;
		        },
		
		        toISOString : function () {
		            var m = moment(this).utc();
		            if (0 < m.year() && m.year() <= 9999) {
		                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
		            } else {
		                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
		            }
		        },
		
		        toArray : function () {
		            var m = this;
		            return [
		                m.year(),
		                m.month(),
		                m.date(),
		                m.hours(),
		                m.minutes(),
		                m.seconds(),
		                m.milliseconds()
		            ];
		        },
		
		        isValid : function () {
		            return isValid(this);
		        },
		
		        isDSTShifted : function () {
		
		            if (this._a) {
		                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
		            }
		
		            return false;
		        },
		
		        parsingFlags : function () {
		            return extend({}, this._pf);
		        },
		
		        invalidAt: function () {
		            return this._pf.overflow;
		        },
		
		        utc : function () {
		            return this.zone(0);
		        },
		
		        local : function () {
		            this.zone(0);
		            this._isUTC = false;
		            return this;
		        },
		
		        format : function (inputString) {
		            var output = formatMoment(this, inputString || moment.defaultFormat);
		            return this.lang().postformat(output);
		        },
		
		        add : function (input, val) {
		            var dur;
		            // switch args to support add('s', 1) and add(1, 's')
		            if (typeof input === 'string') {
		                dur = moment.duration(+val, input);
		            } else {
		                dur = moment.duration(input, val);
		            }
		            addOrSubtractDurationFromMoment(this, dur, 1);
		            return this;
		        },
		
		        subtract : function (input, val) {
		            var dur;
		            // switch args to support subtract('s', 1) and subtract(1, 's')
		            if (typeof input === 'string') {
		                dur = moment.duration(+val, input);
		            } else {
		                dur = moment.duration(input, val);
		            }
		            addOrSubtractDurationFromMoment(this, dur, -1);
		            return this;
		        },
		
		        diff : function (input, units, asFloat) {
		            var that = makeAs(input, this),
		                zoneDiff = (this.zone() - that.zone()) * 6e4,
		                diff, output;
		
		            units = normalizeUnits(units);
		
		            if (units === 'year' || units === 'month') {
		                // average number of days in the months in the given dates
		                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
		                // difference in months
		                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
		                // adjust by taking difference in days, average number of days
		                // and dst in the given months.
		                output += ((this - moment(this).startOf('month')) -
		                        (that - moment(that).startOf('month'))) / diff;
		                // same as above but with zones, to negate all dst
		                output -= ((this.zone() - moment(this).startOf('month').zone()) -
		                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
		                if (units === 'year') {
		                    output = output / 12;
		                }
		            } else {
		                diff = (this - that);
		                output = units === 'second' ? diff / 1e3 : // 1000
		                    units === 'minute' ? diff / 6e4 : // 1000 * 60
		                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
		                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
		                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
		                    diff;
		            }
		            return asFloat ? output : absRound(output);
		        },
		
		        from : function (time, withoutSuffix) {
		            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
		        },
		
		        fromNow : function (withoutSuffix) {
		            return this.from(moment(), withoutSuffix);
		        },
		
		        calendar : function () {
		            // We want to compare the start of today, vs this.
		            // Getting start-of-today depends on whether we're zone'd or not.
		            var sod = makeAs(moment(), this).startOf('day'),
		                diff = this.diff(sod, 'days', true),
		                format = diff < -6 ? 'sameElse' :
		                    diff < -1 ? 'lastWeek' :
		                    diff < 0 ? 'lastDay' :
		                    diff < 1 ? 'sameDay' :
		                    diff < 2 ? 'nextDay' :
		                    diff < 7 ? 'nextWeek' : 'sameElse';
		            return this.format(this.lang().calendar(format, this));
		        },
		
		        isLeapYear : function () {
		            return isLeapYear(this.year());
		        },
		
		        isDST : function () {
		            return (this.zone() < this.clone().month(0).zone() ||
		                this.zone() < this.clone().month(5).zone());
		        },
		
		        day : function (input) {
		            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
		            if (input != null) {
		                input = parseWeekday(input, this.lang());
		                return this.add({ d : input - day });
		            } else {
		                return day;
		            }
		        },
		
		        month : function (input) {
		            var utc = this._isUTC ? 'UTC' : '',
		                dayOfMonth;
		
		            if (input != null) {
		                if (typeof input === 'string') {
		                    input = this.lang().monthsParse(input);
		                    if (typeof input !== 'number') {
		                        return this;
		                    }
		                }
		
		                dayOfMonth = this.date();
		                this.date(1);
		                this._d['set' + utc + 'Month'](input);
		                this.date(Math.min(dayOfMonth, this.daysInMonth()));
		
		                moment.updateOffset(this);
		                return this;
		            } else {
		                return this._d['get' + utc + 'Month']();
		            }
		        },
		
		        startOf: function (units) {
		            units = normalizeUnits(units);
		            // the following switch intentionally omits break keywords
		            // to utilize falling through the cases.
		            switch (units) {
		            case 'year':
		                this.month(0);
		                /* falls through */
		            case 'month':
		                this.date(1);
		                /* falls through */
		            case 'week':
		            case 'isoWeek':
		            case 'day':
		                this.hours(0);
		                /* falls through */
		            case 'hour':
		                this.minutes(0);
		                /* falls through */
		            case 'minute':
		                this.seconds(0);
		                /* falls through */
		            case 'second':
		                this.milliseconds(0);
		                /* falls through */
		            }
		
		            // weeks are a special case
		            if (units === 'week') {
		                this.weekday(0);
		            } else if (units === 'isoWeek') {
		                this.isoWeekday(1);
		            }
		
		            return this;
		        },
		
		        endOf: function (units) {
		            units = normalizeUnits(units);
		            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
		        },
		
		        isAfter: function (input, units) {
		            units = typeof units !== 'undefined' ? units : 'millisecond';
		            return +this.clone().startOf(units) > +moment(input).startOf(units);
		        },
		
		        isBefore: function (input, units) {
		            units = typeof units !== 'undefined' ? units : 'millisecond';
		            return +this.clone().startOf(units) < +moment(input).startOf(units);
		        },
		
		        isSame: function (input, units) {
		            units = units || 'ms';
		            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
		        },
		
		        min: function (other) {
		            other = moment.apply(null, arguments);
		            return other < this ? this : other;
		        },
		
		        max: function (other) {
		            other = moment.apply(null, arguments);
		            return other > this ? this : other;
		        },
		
		        zone : function (input) {
		            var offset = this._offset || 0;
		            if (input != null) {
		                if (typeof input === "string") {
		                    input = timezoneMinutesFromString(input);
		                }
		                if (Math.abs(input) < 16) {
		                    input = input * 60;
		                }
		                this._offset = input;
		                this._isUTC = true;
		                if (offset !== input) {
		                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
		                }
		            } else {
		                return this._isUTC ? offset : this._d.getTimezoneOffset();
		            }
		            return this;
		        },
		
		        zoneAbbr : function () {
		            return this._isUTC ? "UTC" : "";
		        },
		
		        zoneName : function () {
		            return this._isUTC ? "Coordinated Universal Time" : "";
		        },
		
		        parseZone : function () {
		            if (this._tzm) {
		                this.zone(this._tzm);
		            } else if (typeof this._i === 'string') {
		                this.zone(this._i);
		            }
		            return this;
		        },
		
		        hasAlignedHourOffset : function (input) {
		            if (!input) {
		                input = 0;
		            }
		            else {
		                input = moment(input).zone();
		            }
		
		            return (this.zone() - input) % 60 === 0;
		        },
		
		        daysInMonth : function () {
		            return daysInMonth(this.year(), this.month());
		        },
		
		        dayOfYear : function (input) {
		            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
		            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
		        },
		
		        quarter : function () {
		            return Math.ceil((this.month() + 1.0) / 3.0);
		        },
		
		        weekYear : function (input) {
		            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
		            return input == null ? year : this.add("y", (input - year));
		        },
		
		        isoWeekYear : function (input) {
		            var year = weekOfYear(this, 1, 4).year;
		            return input == null ? year : this.add("y", (input - year));
		        },
		
		        week : function (input) {
		            var week = this.lang().week(this);
		            return input == null ? week : this.add("d", (input - week) * 7);
		        },
		
		        isoWeek : function (input) {
		            var week = weekOfYear(this, 1, 4).week;
		            return input == null ? week : this.add("d", (input - week) * 7);
		        },
		
		        weekday : function (input) {
		            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
		            return input == null ? weekday : this.add("d", input - weekday);
		        },
		
		        isoWeekday : function (input) {
		            // behaves the same as moment#day except
		            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
		            // as a setter, sunday should belong to the previous week.
		            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
		        },
		
		        get : function (units) {
		            units = normalizeUnits(units);
		            return this[units]();
		        },
		
		        set : function (units, value) {
		            units = normalizeUnits(units);
		            if (typeof this[units] === 'function') {
		                this[units](value);
		            }
		            return this;
		        },
		
		        // If passed a language key, it will set the language for this
		        // instance.  Otherwise, it will return the language configuration
		        // variables for this instance.
		        lang : function (key) {
		            if (key === undefined) {
		                return this._lang;
		            } else {
		                this._lang = getLangDefinition(key);
		                return this;
		            }
		        }
		    });
		
		    // helper for adding shortcuts
		    function makeGetterAndSetter(name, key) {
		        moment.fn[name] = moment.fn[name + 's'] = function (input) {
		            var utc = this._isUTC ? 'UTC' : '';
		            if (input != null) {
		                this._d['set' + utc + key](input);
		                moment.updateOffset(this);
		                return this;
		            } else {
		                return this._d['get' + utc + key]();
		            }
		        };
		    }
		
		    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
		    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
		        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
		    }
		
		    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
		    makeGetterAndSetter('year', 'FullYear');
		
		    // add plural methods
		    moment.fn.days = moment.fn.day;
		    moment.fn.months = moment.fn.month;
		    moment.fn.weeks = moment.fn.week;
		    moment.fn.isoWeeks = moment.fn.isoWeek;
		
		    // add aliased format methods
		    moment.fn.toJSON = moment.fn.toISOString;
		
		    /************************************
		        Duration Prototype
		    ************************************/
		
		
		    extend(moment.duration.fn = Duration.prototype, {
		
		        _bubble : function () {
		            var milliseconds = this._milliseconds,
		                days = this._days,
		                months = this._months,
		                data = this._data,
		                seconds, minutes, hours, years;
		
		            // The following code bubbles up values, see the tests for
		            // examples of what that means.
		            data.milliseconds = milliseconds % 1000;
		
		            seconds = absRound(milliseconds / 1000);
		            data.seconds = seconds % 60;
		
		            minutes = absRound(seconds / 60);
		            data.minutes = minutes % 60;
		
		            hours = absRound(minutes / 60);
		            data.hours = hours % 24;
		
		            days += absRound(hours / 24);
		            data.days = days % 30;
		
		            months += absRound(days / 30);
		            data.months = months % 12;
		
		            years = absRound(months / 12);
		            data.years = years;
		        },
		
		        weeks : function () {
		            return absRound(this.days() / 7);
		        },
		
		        valueOf : function () {
		            return this._milliseconds +
		              this._days * 864e5 +
		              (this._months % 12) * 2592e6 +
		              toInt(this._months / 12) * 31536e6;
		        },
		
		        humanize : function (withSuffix) {
		            var difference = +this,
		                output = relativeTime(difference, !withSuffix, this.lang());
		
		            if (withSuffix) {
		                output = this.lang().pastFuture(difference, output);
		            }
		
		            return this.lang().postformat(output);
		        },
		
		        add : function (input, val) {
		            // supports only 2.0-style add(1, 's') or add(moment)
		            var dur = moment.duration(input, val);
		
		            this._milliseconds += dur._milliseconds;
		            this._days += dur._days;
		            this._months += dur._months;
		
		            this._bubble();
		
		            return this;
		        },
		
		        subtract : function (input, val) {
		            var dur = moment.duration(input, val);
		
		            this._milliseconds -= dur._milliseconds;
		            this._days -= dur._days;
		            this._months -= dur._months;
		
		            this._bubble();
		
		            return this;
		        },
		
		        get : function (units) {
		            units = normalizeUnits(units);
		            return this[units.toLowerCase() + 's']();
		        },
		
		        as : function (units) {
		            units = normalizeUnits(units);
		            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
		        },
		
		        lang : moment.fn.lang,
		
		        toIsoString : function () {
		            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
		            var years = Math.abs(this.years()),
		                months = Math.abs(this.months()),
		                days = Math.abs(this.days()),
		                hours = Math.abs(this.hours()),
		                minutes = Math.abs(this.minutes()),
		                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
		
		            if (!this.asSeconds()) {
		                // this is the same as C#'s (Noda) and python (isodate)...
		                // but not other JS (goog.date)
		                return 'P0D';
		            }
		
		            return (this.asSeconds() < 0 ? '-' : '') +
		                'P' +
		                (years ? years + 'Y' : '') +
		                (months ? months + 'M' : '') +
		                (days ? days + 'D' : '') +
		                ((hours || minutes || seconds) ? 'T' : '') +
		                (hours ? hours + 'H' : '') +
		                (minutes ? minutes + 'M' : '') +
		                (seconds ? seconds + 'S' : '');
		        }
		    });
		
		    function makeDurationGetter(name) {
		        moment.duration.fn[name] = function () {
		            return this._data[name];
		        };
		    }
		
		    function makeDurationAsGetter(name, factor) {
		        moment.duration.fn['as' + name] = function () {
		            return +this / factor;
		        };
		    }
		
		    for (i in unitMillisecondFactors) {
		        if (unitMillisecondFactors.hasOwnProperty(i)) {
		            makeDurationAsGetter(i, unitMillisecondFactors[i]);
		            makeDurationGetter(i.toLowerCase());
		        }
		    }
		
		    makeDurationAsGetter('Weeks', 6048e5);
		    moment.duration.fn.asMonths = function () {
		        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
		    };
		
		
		    /************************************
		        Default Lang
		    ************************************/
		
		
		    // Set default language, other languages will inherit from English.
		    moment.lang('en', {
		        ordinal : function (number) {
		            var b = number % 10,
		                output = (toInt(number % 100 / 10) === 1) ? 'th' :
		                (b === 1) ? 'st' :
		                (b === 2) ? 'nd' :
		                (b === 3) ? 'rd' : 'th';
		            return number + output;
		        }
		    });
		
		    /* EMBED_LANGUAGES */
		
		    /************************************
		        Exposing Moment
		    ************************************/
		
		    function makeGlobal(deprecate) {
		        var warned = false, local_moment = moment;
		        /*global ender:false */
		        if (typeof ender !== 'undefined') {
		            return;
		        }
		        // here, `this` means `window` in the browser, or `global` on the server
		        // add `moment` as a global object via a string identifier,
		        // for Closure Compiler "advanced" mode
		        if (deprecate) {
		            global.moment = function () {
		                if (!warned && console && console.warn) {
		                    warned = true;
		                    console.warn(
		                            "Accessing Moment through the global scope is " +
		                            "deprecated, and will be removed in an upcoming " +
		                            "release.");
		                }
		                return local_moment.apply(null, arguments);
		            };
		            extend(global.moment, local_moment);
		        } else {
		            global['moment'] = moment;
		        }
		    }
		
		    // CommonJS module is defined
		    if (hasModule) {
		        module.exports = moment;
		        makeGlobal(true);
		    } else if (typeof define === "function" && define.amd) {
		        define("moment", function (require, exports, module) {
		            if (module.config && module.config() && module.config().noGlobal !== true) {
		                // If user provided noGlobal, he is aware of global
		                makeGlobal(module.config().noGlobal === undefined);
		            }
		
		            return moment;
		        });
		    } else {
		        makeGlobal();
		    }
		}).call(this);
		
	
	}, 'cache-storage/Storage/Storage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/Storage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/Storage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/Storage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/Storage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/Storage');
	
	}, 'normalize-arguments/lib/Args.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'normalize-arguments/lib/Args.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'normalize-arguments/lib/Args.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'normalize-arguments/lib/Args.js';
		var __dirname = 'normalize-arguments/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'normalize-arguments/lib/Args.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var args, count, emptyArgument, expandArguments, exportFunc, fn, isFunction, name, type, types;
		
		  types = {
		    string: '[object String]',
		    number: '[object Number]',
		    'boolean': '[object Boolean]',
		    array: '[object Array]',
		    object: '[object Object]',
		    fn: '[object Function]'
		  };
		
		  exportFunc = {
		    string: function(d) {
		      return {
		        type: 'string',
		        d: d
		      };
		    },
		    number: function(d) {
		      return {
		        type: 'number',
		        d: d
		      };
		    },
		    'boolean': function(d) {
		      return {
		        type: 'boolean',
		        d: d
		      };
		    },
		    array: function(d) {
		      return {
		        type: 'array',
		        d: d
		      };
		    },
		    object: function(d) {
		      return {
		        type: 'object',
		        d: d
		      };
		    },
		    any: function(d) {
		      return {
		        type: 'any',
		        d: d
		      };
		    },
		    fn: function(d) {
		      return {
		        type: 'fn',
		        d: d
		      };
		    },
		    oneOf: function(list, d) {
		      var i, readable, t, type, _i, _len;
		      if (d == null) {
		        d = null;
		      }
		      readable = [];
		      for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
		        type = list[i];
		        t = type().type;
		        list[i] = types[t];
		        readable.push(t);
		      }
		      return {
		        type: 'oneOf',
		        d: d,
		        dCalled: arguments.length === 2,
		        types: list,
		        readable: readable
		      };
		    }
		  };
		
		  emptyArgument = {};
		
		  type = Object.prototype.toString;
		
		  isFunction = function(v) {
		    return type.call(v) === '[object Function]';
		  };
		
		  count = function(num) {
		    switch (num) {
		      case 1:
		        return 'st';
		      case 2:
		        return 'nd';
		      case 3:
		        return 'rd';
		      default:
		        return 'th';
		    }
		  };
		
		  expandArguments = function(params, expected) {
		    var actual, e, i, _i, _len;
		    if (params == null) {
		      params = [];
		    }
		    if (expected == null) {
		      expected = [];
		    }
		    for (i = _i = 0, _len = expected.length; _i < _len; i = ++_i) {
		      e = expected[i];
		      if (isFunction(e)) {
		        e = e();
		      }
		      actual = type.call(params[i]);
		      if (params[i] !== null && e.type !== 'any' && ((e.type === 'oneOf' && e.types.indexOf(actual) === -1) || (e.type !== 'oneOf' && types[e.type] !== actual))) {
		        params.splice(i, 0, emptyArgument);
		      }
		    }
		    return params;
		  };
		
		  args = function(params, expected) {
		    var e, expect, fn, i, last, must, num, param, _i, _len;
		    if (params == null) {
		      params = [];
		    }
		    if (expected == null) {
		      expected = [];
		    }
		    if (type.call(params) === '[object Arguments]') {
		      params = Array.prototype.slice.call(params);
		    }
		    params = expandArguments(params, expected);
		    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
		      param = params[i];
		      expect = null;
		      e = expected[i];
		      if (typeof e !== 'undefined') {
		        expect = isFunction(e) ? e().type : e.type;
		      }
		      if (param === emptyArgument) {
		        fn = isFunction(e);
		        if (fn || (!fn && e.type === 'oneOf' && e.dCalled === false)) {
		          if (fn) {
		            must = e().type;
		          } else {
		            if (e.readable.length === 1) {
		              must = e.readable[0];
		            } else {
		              last = e.readable.pop();
		              must = e.readable.join(', ') + ' or ' + last;
		            }
		          }
		          num = i + 1;
		          throw new Error(num + count(num) + ' argument must be ' + must);
		        }
		        params[i] = e.d;
		      }
		    }
		    return params;
		  };
		
		  for (name in exportFunc) {
		    fn = exportFunc[name];
		    args[name] = fn;
		  }
		
		  module.exports = args;
		
		}).call(this);
		
	
	}, '/lib/node/path.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/node/path.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/node/path.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/node/path.js';
		var __dirname = '/lib/node';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/node/path.js'], env: {}};
	
		/** code **/
		// Taken from https://github.com/joyent/node/blob/master/lib/path.js
		
		
		
		// resolves . and .. elements in a path array with directory names there
		// must be no slashes, empty elements, or device names (c:\) in the array
		// (so also no leading and trailing slashes - it does not distinguish
		// relative and absolute paths)
		function normalizeArray(parts, allowAboveRoot) {
			// if the path tries to go above the root, `up` ends up > 0
			var up = 0;
			for (var i = parts.length - 1; i >= 0; i--) {
				var last = parts[i];
				if (last === '.') {
					parts.splice(i, 1);
				} else if (last === '..') {
					parts.splice(i, 1);
					up++;
				} else if (up) {
					parts.splice(i, 1);
					up--;
				}
			}
		
			// if the path is allowed to go above the root, restore leading ..s
			if (allowAboveRoot) {
				for (; up--; up) {
					parts.unshift('..');
				}
			}
		
			return parts;
		}
		
		var splitPathRe =
			/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
		var splitPath = function(filename) {
			return splitPathRe.exec(filename).slice(1);
		};
		
		var isBrowser = typeof window !== 'undefined';
		
		if (!isBrowser) {
			var path = require('path');
		}
		
		exports.isAbsolute = function(_path) {
			if (isBrowser) {
				return _path.charAt(0) === '/';
			} else {
				return path.isAbsolute.call({}, _path);
			}
		};
		
		exports.normalize = function(_path) {
			if (isBrowser) {
				var isAbsolute = exports.isAbsolute(_path),
					trailingSlash = _path[_path.length - 1] === '/',
					segments = _path.split('/'),
					nonEmptySegments = [];
		
				// Normalize the path
				for (var i = 0; i < segments.length; i++) {
					if (segments[i]) {
						nonEmptySegments.push(segments[i]);
					}
				}
				_path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');
		
				if (!_path && !isAbsolute) {
					_path = '.';
				}
				if (_path && trailingSlash) {
					_path += '/';
				}
		
				return (isAbsolute ? '/' : '') + _path;
			} else {
				return path.normalize.call({}, _path);
			}
		};
		
		exports.join = function() {
			if (isBrowser) {
				var _path = '';
				for (var i = 0; i < arguments.length; i++) {
					var segment = arguments[i];
					if (typeof segment != 'string') {
						throw new TypeError('Arguments to path.join must be strings');
					}
					if (segment) {
						if (!_path) {
							_path += segment;
						} else {
							_path += '/' + segment;
						}
					}
				}
				return exports.normalize(_path);
			} else {
				return path.join.apply({}, arguments);
			}
		};
		
		exports.dirname = function(_path) {
			if (isBrowser) {
				var result = splitPath(_path),
					root = result[0],
					dir = result[1];
		
				if (!root && !dir) {
					// No dirname whatsoever
					return '.';
				}
		
				if (dir) {
					// It has a dirname, strip trailing slash
					dir = dir.substr(0, dir.length - 1);
				}
		
				return root + dir;
			} else {
				return path.dirname.call({}, _path);
			}
		};
	
	}, '/lib/pluralForms.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/pluralForms.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/pluralForms.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/pluralForms.json';
		var __dirname = '/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/pluralForms.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"ach": {"count": 2, "form": "(n > 1)"},
			"af": {"count": 2, "form": "(n != 1)"},
			"ak": {"count": 2, "form": "(n > 1)"},
			"am": {"count": 2, "form": "(n > 1)"},
			"an": {"count": 2, "form": "(n != 1)"},
			"ar": {"count": 2, "form": "(n==0 ? 0 : (n==1 ? 1 : (n==2 ? 2 : (n%100>=3 && n%100<=10 ? 3 : (n%100>=11 ? 4 : 5)))))"},
			"arn": {"count": 2, "form": "(n > 1)"},
			"ast": {"count": 2, "form": "(n != 1)"},
			"ay": {"count": 2, "form": "0"},
			"az": {"count": 2, "form": "(n != 1)"},
		
			"be": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"bg": {"count": 2, "form": "(n != 1)"},
			"bn": {"count": 2, "form": "(n != 1)"},
			"bo": {"count": 1, "form": "0"},
			"br": {"count": 2, "form": "(n > 1)"},
			"brx": {"count": 2, "form": "(n != 1)"},
			"bs": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
		
			"ca": {"count": 2, "form": "(n != 1)"},
			"cgg": {"count": 1, "form": "0"},
			"cs": {"count": 3, "form": "(n==1) ? 0 : ((n>=2 && n<=4) ? 1 : 2)"},
			"csb": {"count": 4, "form": "n==1 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)"},
			"cy": {"count": 4, "form": "(n==1) ? 0 : ((n==2) ? 1 : ((n != 8 && n != 11) ? 2 : 3))"},
		
			"da": {"count": 2, "form": "(n != 1)"},
			"de": {"count": 2, "form": "(n != 1)"},
			"doi": {"count": 2, "form": "(n != 1)"},
			"dz": {"count": 1, "form": "0"},
		
			"el": {"count": 2, "form": "(n != 1)"},
			"en": {"count": 2, "form": "(n != 1)"},
			"eo": {"count": 2, "form": "(n != 1)"},
			"es": {"count": 2, "form": "(n != 1)"},
			"es_AR": {"count": 2, "form": "(n != 1)"},
			"et": {"count": 2, "form": "(n != 1)"},
			"eu": {"count": 2, "form": "(n != 1)"},
		
			"fa": {"count": 1, "form": "0"},
			"ff": {"count": 2, "form": "(n != 1)"},
			"fi": {"count": 2, "form": "(n != 1)"},
			"fil": {"count": 2, "form": "(n > 1)"},
			"fo": {"count": 2, "form": "(n != 1)"},
			"fr": {"count": 2, "form": "(n > 1)"},
			"fur": {"count": 2, "form": "(n != 1)"},
			"fy": {"count": 2, "form": "(n != 1)"},
		
			"ga": {"count": 5, "form": "n==1 ? 0 : (n==2 ? 1 : (n<7 ? 2 : (n<11 ? 3 : 4)))"},
			"gd": {"count": 4, "form": "(n==1 || n==11) ? 0 : ((n==2 || n==12) ? 1 : ((n > 2 && n < 20) ? 2 : 3))"},
			"gl": {"count": 2, "form": "(n != 1)"},
			"gu": {"count": 2, "form": "(n != 1)"},
			"gun": {"count": 2, "form": "(n > 1)"},
		
			"ha": {"count": 2, "form": "(n != 1)"},
			"he": {"count": 2, "form": "(n != 1)"},
			"hi": {"count": 2, "form": "(n != 1)"},
			"hne": {"count": 2, "form": "(n != 1)"},
			"hy": {"count": 2, "form": "(n != 1)"},
			"hr": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"hu": {"count": 2, "form": "(n != 1)"},
		
			"ia": {"count": 2, "form": "(n != 1)"},
			"id": {"count": 1, "form": "0"},
			"is": {"count": 2, "form": "(n%10!=1 || n%100==11)"},
			"it": {"count": 2, "form": "(n != 1)"},
		
			"ja": {"count": 1, "form": "0"},
			"jbo": {"count": 1, "form": "0"},
			"jv": {"count": 2, "form": "(n != 0)"},
		
			"ka": {"count": 1, "form": "0"},
			"kk": {"count": 1, "form": "0"},
			"km": {"count": 1, "form": "0"},
			"kn": {"count": 2, "form": "(n != 1)"},
			"ko": {"count": 1, "form": "0"},
			"ku": {"count": 2, "form": "(n != 1)"},
			"kw": {"count": 4, "form": "(n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3"},
			"ky": {"count": 1, "form": "0"},
		
			"lb": {"count": 2, "form": "(n != 1)"},
			"ln": {"count": 2, "form": "(n > 1)"},
			"lo": {"count": 1, "form": "0"},
			"lt": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && (n%100<10 or n%100>=20) ? 1 : 2))"},
			"lv": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n != 0 ? 1 : 2))"},
		
			"mai": {"count": 2, "form": "(n != 1)"},
			"mfe": {"count": 2, "form": "(n > 1)"},
			"mg": {"count": 2, "form": "(n > 1)"},
			"mi": {"count": 2, "form": "(n > 1)"},
			"ml": {"count": 2, "form": "(n != 1)"},
			"mn": {"count": 2, "form": "(n != 1)"},
			"mni": {"count": 2, "form": "(n != 1)"},
			"mnk": {"count": 3, "form": "(n==0 ? 0 : (n==1 ? 1 : 2))"},
			"mr": {"count": 2, "form": "(n != 1)"},
			"ms": {"count": 1, "form": "0"},
			"mt": {"count": 4, "form": "(n==1 ? 0 : (n==0 || ( n%100>1 && n%100<11) ? 1 : ((n%100>10 && n%100<20 ) ? 2 : 3)))"},
			"my": {"count": 1, "form": "0"},
		
			"nah": {"count": 2, "form": "(n != 1)"},
			"nap": {"count": 2, "form": "(n != 1)"},
			"nb": {"count": 2, "form": "(n != 1)"},
			"ne": {"count": 2, "form": "(n != 1)"},
			"nl": {"count": 2, "form": "(n != 1)"},
			"se": {"count": 2, "form": "(n != 1)"},
			"nn": {"count": 2, "form": "(n != 1)"},
			"no": {"count": 2, "form": "(n != 1)"},
			"nso": {"count": 2, "form": "(n != 1)"},
		
			"oc": {"count": 2, "form": "(n > 1)"},
			"or": {"count": 2, "form": "(n != 1)"},
		
			"ps": {"count": 2, "form": "(n != 1)"},
			"pa": {"count": 2, "form": "(n != 1)"},
			"pap": {"count": 2, "form": "(n != 1)"},
			"pl": {"count": 3, "form": "(n==1 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"pms": {"count": 2, "form": "(n != 1)"},
			"pt": {"count": 2, "form": "(n != 1)"},
			"pt_BR": {"count": 2, "form": "(n != 1)"},
		
			"rm": {"count": 2, "form": "(n != 1)"},
			"ro": {"count": 3, "form": "(n==1 ? 0 : ((n==0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2))"},
			"ru": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"rw": {"count": 2, "form": "(n != 1)"},
		
			"sah": {"count": 1, "form": "0"},
			"sat": {"count": 2, "form": "(n != 1)"},
			"sco": {"count": 2, "form": "(n != 1)"},
			"sd": {"count": 2, "form": "(n != 1)"},
			"si": {"count": 2, "form": "(n != 1)"},
			"sk": {"count": 3, "form": "(n==1) ? 0 : ((n>=2 && n<=4) ? 1 : 2)"},
			"sl": {"count": 4, "form": "(n%100==1 ? 1 : (n%100==2 ? 2 : (n%100==3 || n%100==4 ? 3 : 0)))"},
			"so": {"count": 2, "form": "(n != 1)"},
			"son": {"count": 2, "form": "(n != 1)"},
			"sq": {"count": 2, "form": "(n != 1)"},
			"sr": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"su": {"count": 1, "form": "0"},
			"sw": {"count": 2, "form": "(n != 1)"},
			"sv": {"count": 2, "form": "(n != 1)"},
		
			"ta": {"count": 2, "form": "(n != 1)"},
			"te": {"count": 2, "form": "(n != 1)"},
			"tg": {"count": 2, "form": "(n > 1)"},
			"ti": {"count": 2, "form": "(n > 1)"},
			"th": {"count": 1, "form": "0"},
			"tk": {"count": 2, "form": "(n != 1)"},
			"tr": {"count": 2, "form": "(n > 1)"},
			"tt": {"count": 1, "form": "0"},
		
			"ug": {"count": 1, "form": "0"},
			"uk": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"ur": {"count": 2, "form": "(n != 1)"},
			"uz": {"count": 2, "form": "(n > 1)"},
		
			"vi": {"count": 1, "form": "0"},
		
			"wa": {"count": 2, "form": "(n > 1)"},
			"wo": {"count": 1, "form": "0"},
		
			"yo": {"count": 2, "form": "(n != 1)"},
		
			"zh": {"count": 1, "form": "0"}
		}
		}).call(this);
		
	
	}, '/lib/Loaders/Json.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/Loaders/Json.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Loaders/Json.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/Loaders/Json.js';
		var __dirname = '/lib/Loaders';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Loaders/Json.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Json, Loader, callsite, fs, isBrowser, path,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Loader = require('./Loader');
		
		  path = require('../node/path');
		
		  isBrowser = typeof window !== 'undefined';
		
		  if (!isBrowser) {
		    callsite = require('callsite');
		    fs = require('fs');
		  }
		
		  Json = (function(_super) {
		    __extends(Json, _super);
		
		    Json.prototype.directory = '/app/lang';
		
		    function Json(directory) {
		      var stack;
		      this.directory = directory != null ? directory : this.directory;
		      if (this.directory.charAt(0) === '.' && isBrowser) {
		        throw new Error('Relative paths to dictionaries is not supported in browser.');
		      }
		      if (this.directory.charAt(0) === '.') {
		        stack = callsite();
		        this.directory = path.dirname(stack[1].getFileName());
		      }
		      if (!isBrowser) {
		        this.directory = path.normalize(this.directory);
		      }
		    }
		
		    Json.prototype.load = function(parent, name, language) {
		      var data, e, _path;
		      _path = this.getFileSystemPath(parent, name, language);
		      try {
		        data = require(_path);
		      } catch (_error) {
		        e = _error;
		        data = {};
		      }
		      return data;
		    };
		
		    Json.prototype.save = function(parent, name, language, data) {
		      var _path;
		      if (isBrowser) {
		        throw new Error('Save method can not be used in browser.');
		      }
		      _path = this.getFileSystemPath(parent, name, language);
		      return fs.writeFileSync(_path, JSON.stringify(data, null, 2));
		    };
		
		    Json.prototype.getFileSystemPath = function(parent, name, language) {
		      return this.directory + (parent !== '' ? '/' + parent : '') + ("/" + language + "." + name + ".json");
		    };
		
		    return Json;
		
		  })(Loader);
		
		  module.exports = Json;
		
		}).call(this);
		
	
	}, 'callsite/index.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'callsite/index.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'callsite/index.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'callsite/index.js';
		var __dirname = 'callsite';
		var process = {cwd: function() {return '/';}, argv: ['node', 'callsite/index.js'], env: {}};
	
		/** code **/
		
		module.exports = function(){
		  var orig = Error.prepareStackTrace;
		  Error.prepareStackTrace = function(_, stack){ return stack; };
		  var err = new Error;
		  Error.captureStackTrace(err, arguments.callee);
		  var stack = err.stack;
		  Error.prepareStackTrace = orig;
		  return stack;
		};
		
	
	}, 'fs-finder/lib/Finder.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'fs-finder/lib/Finder.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-finder/lib/Finder.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'fs-finder/lib/Finder.js';
		var __dirname = 'fs-finder/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'fs-finder/lib/Finder.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Base, Finder, Helpers, compare, isFunction, moment, _ref,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Base = require('./Base');
		
		  Helpers = require('./Helpers');
		
		  moment = require('moment');
		
		  compare = require('operator-compare');
		
		  isFunction = function(obj) {
		    return Object.prototype.toString.call(obj) === '[object Function]';
		  };
		
		  Finder = (function(_super) {
		    __extends(Finder, _super);
		
		    function Finder() {
		      _ref = Finder.__super__.constructor.apply(this, arguments);
		      return _ref;
		    }
		
		    Finder.TIME_FORMAT = 'YYYY-MM-DD HH:mm';
		
		    Finder["in"] = function(path) {
		      return new Finder(path);
		    };
		
		    Finder.from = function(path) {
		      return (new Finder(path)).recursively();
		    };
		
		    Finder.find = function(path, fn, type) {
		      if (fn == null) {
		        fn = null;
		      }
		      if (type == null) {
		        type = 'all';
		      }
		      path = Helpers.parseDirectory(path);
		      return (new Finder(path.directory)).recursively().find(path.mask, fn, type);
		    };
		
		    Finder.findFiles = function(path, fn) {
		      if (path == null) {
		        path = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(path)) {
		        fn = path;
		        path = null;
		      }
		      return Finder.find(path, fn, 'files');
		    };
		
		    Finder.findDirectories = function(path, fn) {
		      if (path == null) {
		        path = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(path)) {
		        fn = path;
		        path = null;
		      }
		      return Finder.find(path, fn, 'directories');
		    };
		
		    Finder.findFile = function(path, fn) {
		      if (path == null) {
		        path = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(path)) {
		        fn = path;
		        path = null;
		      }
		      return Finder.findFirst().find(path, fn, 'files');
		    };
		
		    Finder.findDirectory = function(path, fn) {
		      if (path == null) {
		        path = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(path)) {
		        fn = path;
		        path = null;
		      }
		      return Finder.findFirst().find(path, fn, 'directories');
		    };
		
		    Finder.prototype.find = function(mask, fn, type) {
		      var _ref1;
		      if (mask == null) {
		        mask = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (type == null) {
		        type = 'all';
		      }
		      if (isFunction(mask)) {
		        type = fn;
		        fn = mask;
		        mask = null;
		      }
		      mask = Helpers.normalizePattern(mask);
		      if (this.up === true || ((_ref1 = typeof this.up) === 'number' || _ref1 === 'string')) {
		        if (fn === null) {
		          return this.getPathsFromParentsSync(mask, type);
		        } else {
		          return this.getPathsFromParentsAsync(fn, mask, type);
		        }
		      } else {
		        if (fn === null) {
		          return this.getPathsSync(type, mask);
		        } else {
		          return this.getPathsAsync(fn, type, mask);
		        }
		      }
		    };
		
		    Finder.prototype.findFiles = function(mask, fn) {
		      if (mask == null) {
		        mask = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(mask)) {
		        fn = mask;
		        mask = null;
		      }
		      return this.find(mask, fn, 'files');
		    };
		
		    Finder.prototype.findDirectories = function(mask, fn) {
		      if (mask == null) {
		        mask = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(mask)) {
		        fn = mask;
		        mask = null;
		      }
		      return this.find(mask, fn, 'directories');
		    };
		
		    Finder.prototype.findFile = function(mask, fn) {
		      if (mask == null) {
		        mask = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(mask)) {
		        fn = mask;
		        mask = null;
		      }
		      return this.findFirst().find(mask, fn, 'files');
		    };
		
		    Finder.prototype.findDirectory = function(mask, fn) {
		      if (mask == null) {
		        mask = null;
		      }
		      if (fn == null) {
		        fn = null;
		      }
		      if (isFunction(mask)) {
		        fn = mask;
		        mask = null;
		      }
		      return this.findFirst().find(mask, fn, 'directories');
		    };
		
		    Finder.prototype.size = function(operation, value) {
		      this.filter(function(stat) {
		        return compare(stat.size, operation, value);
		      });
		      return this;
		    };
		
		    Finder.prototype.date = function(operation, value) {
		      this.filter(function(stat) {
		        var date;
		        switch (Object.prototype.toString.call(value)) {
		          case '[object String]':
		            date = moment(value, Finder.TIME_FORMAT);
		            break;
		          case '[object Object]':
		            date = moment().subtract(value);
		            break;
		          default:
		            throw new Error('Date format is not valid.');
		        }
		        return compare((new Date(stat.mtime)).getTime(), operation, date.valueOf());
		      });
		      return this;
		    };
		
		    return Finder;
		
		  })(Base);
		
		  module.exports = Finder;
		
		}).call(this);
		
	
	}, 'fs-finder/lib/Base.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'fs-finder/lib/Base.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-finder/lib/Base.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'fs-finder/lib/Base.js';
		var __dirname = 'fs-finder/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'fs-finder/lib/Base.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Base, Helpers, Q, async, fs, path;
		
		  Helpers = require('./Helpers');
		
		  path = require('path');
		
		  fs = require('fs');
		
		  Q = require('q');
		
		  async = require('async');
		
		  Base = (function() {
		    Base.prototype.directory = null;
		
		    Base.prototype.recursive = false;
		
		    Base.prototype.excludes = null;
		
		    Base.prototype.filters = null;
		
		    Base.prototype.systemFiles = false;
		
		    Base.prototype.up = false;
		
		    Base.prototype._findFirst = false;
		
		    function Base(directory) {
		      directory = path.resolve(directory);
		      if (!fs.statSync(directory).isDirectory()) {
		        throw new Error("Path " + directory + " is not directory");
		      }
		      this.directory = directory;
		      this.excludes = [];
		      this.filters = [];
		    }
		
		    Base.mock = function(tree, info) {
		      var FS;
		      if (tree == null) {
		        tree = {};
		      }
		      if (info == null) {
		        info = {};
		      }
		      FS = require('fs-mock');
		      fs = new FS(tree, info);
		      return fs;
		    };
		
		    Base.restore = function() {
		      return fs = require('fs');
		    };
		
		    Base.prototype.recursively = function(recursive) {
		      this.recursive = recursive != null ? recursive : true;
		      return this;
		    };
		
		    Base.prototype.exclude = function(excludes, exactly) {
		      var exclude, result, _i, _len;
		      if (exactly == null) {
		        exactly = false;
		      }
		      if (typeof excludes === 'string') {
		        excludes = [excludes];
		      }
		      result = [];
		      for (_i = 0, _len = excludes.length; _i < _len; _i++) {
		        exclude = excludes[_i];
		        if (exactly) {
		          exclude = "<^>" + exclude + "<$>";
		        }
		        result.push(Helpers.normalizePattern(exclude));
		      }
		      this.excludes = this.excludes.concat(result);
		      return this;
		    };
		
		    Base.prototype.showSystemFiles = function(systemFiles) {
		      this.systemFiles = systemFiles != null ? systemFiles : true;
		      return this;
		    };
		
		    Base.prototype.lookUp = function(up) {
		      this.up = up != null ? up : true;
		      return this;
		    };
		
		    Base.prototype.findFirst = function(_findFirst) {
		      this._findFirst = _findFirst != null ? _findFirst : true;
		      return this;
		    };
		
		    Base.prototype.filter = function(fn) {
		      this.filters.push(fn);
		      return this;
		    };
		
		    Base.prototype.getPathsSync = function(type, mask, dir) {
		      var err, paths, read, result, stats, _i, _len, _path;
		      if (type == null) {
		        type = 'all';
		      }
		      if (mask == null) {
		        mask = null;
		      }
		      if (dir == null) {
		        dir = this.directory;
		      }
		      paths = [];
		      try {
		        read = fs.readdirSync(dir);
		      } catch (_error) {
		        err = _error;
		        if (this._findFirst === true) {
		          return null;
		        }
		        return paths;
		      }
		      for (_i = 0, _len = read.length; _i < _len; _i++) {
		        _path = read[_i];
		        _path = path.join(dir, _path);
		        if (!this.checkExcludes(_path) || !this.checkSystemFiles(_path)) {
		          continue;
		        }
		        try {
		          stats = fs.statSync(_path);
		        } catch (_error) {
		          err = _error;
		          continue;
		        }
		        switch (this.checkFile(_path, stats, mask, type)) {
		          case 0:
		            continue;
		          case 1:
		            if (this._findFirst === true) {
		              return _path;
		            }
		            paths.push(_path);
		        }
		        if (stats.isDirectory() && this.recursive === true) {
		          result = this.getPathsSync(type, mask, _path);
		          if (this._findFirst === true && typeof result === 'string') {
		            return result;
		          } else if (this._findFirst === true && result === null) {
		            continue;
		          } else {
		            paths = paths.concat(result);
		          }
		        }
		      }
		      if (this._findFirst === true) {
		        return null;
		      } else {
		        return paths;
		      }
		    };
		
		    Base.prototype.getPathsAsync = function(fn, type, mask, dir) {
		      var paths,
		        _this = this;
		      if (type == null) {
		        type = 'all';
		      }
		      if (mask == null) {
		        mask = null;
		      }
		      if (dir == null) {
		        dir = this.directory;
		      }
		      paths = [];
		      return fs.readdir(dir, function(err, read) {
		        var files, nextPaths, _i, _len, _path;
		        if (err) {
		          return fn(_this._findFirst === true ? null : paths);
		        } else {
		          nextPaths = [];
		          for (_i = 0, _len = read.length; _i < _len; _i++) {
		            _path = read[_i];
		            _path = path.join(dir, _path);
		            if (!_this.checkExcludes(_path) || !_this.checkSystemFiles(_path)) {
		              continue;
		            }
		            nextPaths.push(_path);
		          }
		          files = {};
		          return async.eachSeries(nextPaths, function(item, cb) {
		            return fs.stat(item, function(err, stats) {
		              if (!err) {
		                files[item] = stats;
		              }
		              return cb();
		            });
		          }, function() {
		            var file, stats, subDirectories;
		            subDirectories = [];
		            for (file in files) {
		              stats = files[file];
		              switch (_this.checkFile(file, stats, mask, type)) {
		                case 0:
		                  continue;
		                case 1:
		                  if (_this._findFirst === true) {
		                    fn(file);
		                    return null;
		                  }
		                  paths.push(file);
		              }
		              if (stats.isDirectory() && _this.recursive === true) {
		                subDirectories.push(file);
		              }
		            }
		            if (subDirectories.length === 0) {
		              return fn(_this._findFirst === true ? null : paths);
		            } else {
		              return async.eachSeries(subDirectories, function(item, cb) {
		                return _this.getPathsAsync(function(result) {
		                  if (_this._findFirst === true && typeof result === 'string') {
		                    fn(result);
		                    return cb(new Error('Fake error'));
		                  } else if (_this._findFirst === true && result === null) {
		                    return cb();
		                  } else {
		                    paths = paths.concat(result);
		                    return cb();
		                  }
		                }, type, mask, item);
		              }, function(err) {
		                if (!err) {
		                  return fn(paths);
		                }
		              });
		            }
		          });
		        }
		      });
		    };
		
		    Base.prototype.checkExcludes = function(_path) {
		      var exclude, _i, _len, _ref;
		      _ref = this.excludes;
		      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		        exclude = _ref[_i];
		        if ((new RegExp(exclude)).test(_path)) {
		          return false;
		        }
		      }
		      return true;
		    };
		
		    Base.prototype.checkSystemFiles = function(_path) {
		      if (this.systemFiles === false) {
		        if (path.basename(_path)[0] === '.' || _path.match(/~$/) !== null) {
		          return false;
		        }
		      }
		      return true;
		    };
		
		    Base.prototype.checkFilters = function(_path, stats) {
		      var filter, _i, _len, _ref;
		      _ref = this.filters;
		      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		        filter = _ref[_i];
		        if (!filter(stats, _path)) {
		          return false;
		        }
		      }
		      return true;
		    };
		
		    Base.prototype.checkFile = function(_path, stats, mask, type) {
		      if (type === 'all' || (type === 'files' && stats.isFile()) || (type === 'directories' && stats.isDirectory())) {
		        if (mask === null || (mask !== null && (new RegExp(mask, 'g')).test(_path))) {
		          if (!this.checkFilters(_path, stats)) {
		            return 0;
		          }
		          return 1;
		        }
		      }
		      return 2;
		    };
		
		    Base.prototype.getPathsFromParentsSync = function(mask, type) {
		      var Finder, breakAtEnd, finder, found, i, parentPath, parentPaths, previous, result, _i, _len;
		      if (mask == null) {
		        mask = null;
		      }
		      if (type == null) {
		        type = 'all';
		      }
		      Finder = require('./Finder');
		      parentPaths = Helpers.expandPath(this.directory);
		      result = [];
		      previous = null;
		      breakAtEnd = false;
		      for (i = _i = 0, _len = parentPaths.length; _i < _len; i = ++_i) {
		        parentPath = parentPaths[i];
		        if (this.up === true) {
		
		        } else if (typeof this.up === 'string' && this.up === parentPath) {
		          breakAtEnd = true;
		        } else if (typeof this.up === 'number' && this.up <= i) {
		          break;
		        }
		        finder = new Finder(parentPath);
		        finder.recursive = this.recursive;
		        finder.excludes = this.excludes;
		        finder.filters = this.filters;
		        finder.systemFiles = this.systemFiles;
		        finder._findFirst = this._findFirst === true;
		        if (previous !== null) {
		          finder.exclude(previous, true);
		        }
		        found = finder.getPathsSync(type, mask);
		        if (this._findFirst === true && typeof found === 'string') {
		          return found;
		        } else if (this._findFirst === true && found === null) {
		
		        } else if (found.length > 0) {
		          result = result.concat(found);
		        }
		        if (breakAtEnd) {
		          break;
		        }
		        previous = parentPath;
		      }
		      if (this._findFirst === true) {
		        return null;
		      } else {
		        return result;
		      }
		    };
		
		    Base.prototype.getPathsFromParentsAsync = function(fn, mask, type) {
		      var Finder, breakAtEnd, finder, finders, i, parentPath, parentPaths, previous, result, _i, _len,
		        _this = this;
		      if (mask == null) {
		        mask = null;
		      }
		      if (type == null) {
		        type = 'all';
		      }
		      Finder = require('./Finder');
		      parentPaths = Helpers.expandPath(this.directory);
		      result = [];
		      previous = null;
		      breakAtEnd = false;
		      finders = [];
		      for (i = _i = 0, _len = parentPaths.length; _i < _len; i = ++_i) {
		        parentPath = parentPaths[i];
		        if (this.up === true) {
		
		        } else if (typeof this.up === 'string' && this.up === parentPath) {
		          breakAtEnd = true;
		        } else if (typeof this.up === 'number' && this.up <= i) {
		          break;
		        }
		        finder = new Finder(parentPath);
		        finder.recursive = this.recursive;
		        finder.excludes = this.excludes;
		        finder.filters = this.filters;
		        finder.systemFiles = this.systemFiles;
		        finder._findFirst = this._findFirst === true;
		        if (previous !== null) {
		          finder.exclude(previous, true);
		        }
		        finders.push(finder);
		        if (breakAtEnd) {
		          break;
		        }
		        previous = parentPath;
		      }
		      return async.eachSeries(finders, function(finder, cb) {
		        return finder.getPathsAsync(function(found) {
		          if (_this._findFirst === true && typeof found === 'string') {
		            fn(found);
		            return cb(new Error('Fake error'));
		          } else if (_this._findFirst === true && found === null) {
		            return cb();
		          } else {
		            result = result.concat(found);
		            return cb();
		          }
		        }, type, mask);
		      }, function(err) {
		        if (!err) {
		          return fn(_this._findFirst === true ? null : result);
		        }
		      });
		    };
		
		    return Base;
		
		  })();
		
		  module.exports = Base;
		
		}).call(this);
		
	
	}, 'fs-finder/lib/Helpers.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'fs-finder/lib/Helpers.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-finder/lib/Helpers.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'fs-finder/lib/Helpers.js';
		var __dirname = 'fs-finder/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'fs-finder/lib/Helpers.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Helpers, escape, path;
		
		  escape = require('escape-regexp');
		
		  path = require('path');
		
		  Helpers = (function() {
		    function Helpers() {}
		
		    Helpers.ASTERISK_PATTERN = '<[0-9a-zA-Z/.-_ ]+>';
		
		    Helpers.parseDirectory = function(_path) {
		      var asterisk, mask, regexp, splitter;
		      mask = null;
		      asterisk = _path.indexOf('*');
		      regexp = _path.indexOf('<');
		      if (asterisk !== -1 || regexp !== -1) {
		        if (asterisk === -1 || (asterisk !== -1 && regexp !== -1 && asterisk > regexp)) {
		          splitter = regexp;
		        } else if (regexp === -1 || (regexp !== -1 && asterisk !== -1 && asterisk <= regexp)) {
		          splitter = asterisk;
		        }
		        mask = _path.substr(splitter);
		        _path = _path.substr(0, splitter);
		      }
		      return {
		        directory: _path,
		        mask: mask
		      };
		    };
		
		    Helpers.normalizePattern = function(pattern) {
		      var i, part, parts, partsResult, replacement, _i, _len;
		      if (pattern === null) {
		        return null;
		      }
		      if (pattern === '*') {
		        return null;
		      }
		      pattern = pattern.replace(/\*/g, Helpers.ASTERISK_PATTERN);
		      parts = pattern.match(/<((?!(<|>)).)*>/g);
		      if (parts !== null) {
		        partsResult = {};
		        for (i = _i = 0, _len = parts.length; _i < _len; i = ++_i) {
		          part = parts[i];
		          partsResult['__<<' + i + '>>__'] = part.replace(/^<(.*)>$/, '$1');
		          pattern = pattern.replace(part, '__<<' + i + '>>__');
		        }
		        pattern = escape(pattern);
		        for (replacement in partsResult) {
		          part = partsResult[replacement];
		          pattern = pattern.replace(replacement, part);
		        }
		      } else {
		        pattern = escape(pattern);
		      }
		      return pattern;
		    };
		
		    Helpers.expandPath = function(_path, isFile) {
		      var current, result;
		      if (isFile == null) {
		        isFile = false;
		      }
		      if (isFile) {
		        _path = path.dirname(_path);
		      }
		      current = _path;
		      result = [current];
		      while (current !== '/') {
		        result.push(path.dirname(current));
		        current = path.dirname(current);
		      }
		      return result;
		    };
		
		    return Helpers;
		
		  })();
		
		  module.exports = Helpers;
		
		}).call(this);
		
	
	}, 'escape-regexp/index.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'escape-regexp/index.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'escape-regexp/index.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'escape-regexp/index.js';
		var __dirname = 'escape-regexp';
		var process = {cwd: function() {return '/';}, argv: ['node', 'escape-regexp/index.js'], env: {}};
	
		/** code **/
		
		/**
		 * Escape regexp special characters in `str`.
		 *
		 * @param {String} str
		 * @return {String}
		 * @api public
		 */
		
		module.exports = function(str){
		  return String(str).replace(/([.*+?=^!:${}()|[\]\/\\])/g, '\\$1');
		};
	
	}, 'q/q.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'q/q.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'q/q.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'q/q.js';
		var __dirname = 'q';
		var process = {cwd: function() {return '/';}, argv: ['node', 'q/q.js'], env: {}};
	
		/** code **/
		// vim:ts=4:sts=4:sw=4:
		/*!
		 *
		 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
		 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
		 *
		 * With parts by Tyler Close
		 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
		 * at http://www.opensource.org/licenses/mit-license.html
		 * Forked at ref_send.js version: 2009-05-11
		 *
		 * With parts by Mark Miller
		 * Copyright (C) 2011 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 * http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		
		(function (definition) {
		    // Turn off strict mode for this function so we can assign to global.Q
		    /* jshint strict: false */
		
		    // This file will function properly as a <script> tag, or a module
		    // using CommonJS and NodeJS or RequireJS module formats.  In
		    // Common/Node/RequireJS, the module exports the Q API and when
		    // executed as a simple <script>, it creates a Q global instead.
		
		    // Montage Require
		    if (typeof bootstrap === "function") {
		        bootstrap("promise", definition);
		
		    // CommonJS
		    } else if (typeof exports === "object") {
		        module.exports = definition();
		
		    // RequireJS
		    } else if (typeof define === "function" && define.amd) {
		        define(definition);
		
		    // SES (Secure EcmaScript)
		    } else if (typeof ses !== "undefined") {
		        if (!ses.ok()) {
		            return;
		        } else {
		            ses.makeQ = definition;
		        }
		
		    // <script>
		    } else {
		        Q = definition();
		    }
		
		})(function () {
		"use strict";
		
		var hasStacks = false;
		try {
		    throw new Error();
		} catch (e) {
		    hasStacks = !!e.stack;
		}
		
		// All code after this point will be filtered from stack traces reported
		// by Q.
		var qStartingLine = captureLine();
		var qFileName;
		
		// shims
		
		// used for fallback in "allResolved"
		var noop = function () {};
		
		// Use the fastest possible means to execute a task in a future turn
		// of the event loop.
		var nextTick =(function () {
		    // linked list of tasks (single, with head node)
		    var head = {task: void 0, next: null};
		    var tail = head;
		    var flushing = false;
		    var requestTick = void 0;
		    var isNodeJS = false;
		
		    function flush() {
		        /* jshint loopfunc: true */
		
		        while (head.next) {
		            head = head.next;
		            var task = head.task;
		            head.task = void 0;
		            var domain = head.domain;
		
		            if (domain) {
		                head.domain = void 0;
		                domain.enter();
		            }
		
		            try {
		                task();
		
		            } catch (e) {
		                if (isNodeJS) {
		                    // In node, uncaught exceptions are considered fatal errors.
		                    // Re-throw them synchronously to interrupt flushing!
		
		                    // Ensure continuation if the uncaught exception is suppressed
		                    // listening "uncaughtException" events (as domains does).
		                    // Continue in next event to avoid tick recursion.
		                    if (domain) {
		                        domain.exit();
		                    }
		                    setTimeout(flush, 0);
		                    if (domain) {
		                        domain.enter();
		                    }
		
		                    throw e;
		
		                } else {
		                    // In browsers, uncaught exceptions are not fatal.
		                    // Re-throw them asynchronously to avoid slow-downs.
		                    setTimeout(function() {
		                       throw e;
		                    }, 0);
		                }
		            }
		
		            if (domain) {
		                domain.exit();
		            }
		        }
		
		        flushing = false;
		    }
		
		    nextTick = function (task) {
		        tail = tail.next = {
		            task: task,
		            domain: isNodeJS && process.domain,
		            next: null
		        };
		
		        if (!flushing) {
		            flushing = true;
		            requestTick();
		        }
		    };
		
		    if (typeof process !== "undefined" && process.nextTick) {
		        // Node.js before 0.9. Note that some fake-Node environments, like the
		        // Mocha test runner, introduce a `process` global without a `nextTick`.
		        isNodeJS = true;
		
		        requestTick = function () {
		            process.nextTick(flush);
		        };
		
		    } else if (typeof setImmediate === "function") {
		        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
		        if (typeof window !== "undefined") {
		            requestTick = setImmediate.bind(window, flush);
		        } else {
		            requestTick = function () {
		                setImmediate(flush);
		            };
		        }
		
		    } else if (typeof MessageChannel !== "undefined") {
		        // modern browsers
		        // http://www.nonblocking.io/2011/06/windownexttick.html
		        var channel = new MessageChannel();
		        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
		        // working message ports the first time a page loads.
		        channel.port1.onmessage = function () {
		            requestTick = requestPortTick;
		            channel.port1.onmessage = flush;
		            flush();
		        };
		        var requestPortTick = function () {
		            // Opera requires us to provide a message payload, regardless of
		            // whether we use it.
		            channel.port2.postMessage(0);
		        };
		        requestTick = function () {
		            setTimeout(flush, 0);
		            requestPortTick();
		        };
		
		    } else {
		        // old browsers
		        requestTick = function () {
		            setTimeout(flush, 0);
		        };
		    }
		
		    return nextTick;
		})();
		
		// Attempt to make generics safe in the face of downstream
		// modifications.
		// There is no situation where this is necessary.
		// If you need a security guarantee, these primordials need to be
		// deeply frozen anyway, and if you dont need a security guarantee,
		// this is just plain paranoid.
		// However, this **might** have the nice side-effect of reducing the size of
		// the minified code by reducing x.call() to merely x()
		// See Mark Millers explanation of what this does.
		// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
		var call = Function.call;
		function uncurryThis(f) {
		    return function () {
		        return call.apply(f, arguments);
		    };
		}
		// This is equivalent, but slower:
		// uncurryThis = Function_bind.bind(Function_bind.call);
		// http://jsperf.com/uncurrythis
		
		var array_slice = uncurryThis(Array.prototype.slice);
		
		var array_reduce = uncurryThis(
		    Array.prototype.reduce || function (callback, basis) {
		        var index = 0,
		            length = this.length;
		        // concerning the initial value, if one is not provided
		        if (arguments.length === 1) {
		            // seek to the first value in the array, accounting
		            // for the possibility that is is a sparse array
		            do {
		                if (index in this) {
		                    basis = this[index++];
		                    break;
		                }
		                if (++index >= length) {
		                    throw new TypeError();
		                }
		            } while (1);
		        }
		        // reduce
		        for (; index < length; index++) {
		            // account for the possibility that the array is sparse
		            if (index in this) {
		                basis = callback(basis, this[index], index);
		            }
		        }
		        return basis;
		    }
		);
		
		var array_indexOf = uncurryThis(
		    Array.prototype.indexOf || function (value) {
		        // not a very good shim, but good enough for our one use of it
		        for (var i = 0; i < this.length; i++) {
		            if (this[i] === value) {
		                return i;
		            }
		        }
		        return -1;
		    }
		);
		
		var array_map = uncurryThis(
		    Array.prototype.map || function (callback, thisp) {
		        var self = this;
		        var collect = [];
		        array_reduce(self, function (undefined, value, index) {
		            collect.push(callback.call(thisp, value, index, self));
		        }, void 0);
		        return collect;
		    }
		);
		
		var object_create = Object.create || function (prototype) {
		    function Type() { }
		    Type.prototype = prototype;
		    return new Type();
		};
		
		var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
		
		var object_keys = Object.keys || function (object) {
		    var keys = [];
		    for (var key in object) {
		        if (object_hasOwnProperty(object, key)) {
		            keys.push(key);
		        }
		    }
		    return keys;
		};
		
		var object_toString = uncurryThis(Object.prototype.toString);
		
		function isObject(value) {
		    return value === Object(value);
		}
		
		// generator related shims
		
		// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
		function isStopIteration(exception) {
		    return (
		        object_toString(exception) === "[object StopIteration]" ||
		        exception instanceof QReturnValue
		    );
		}
		
		// FIXME: Remove this helper and Q.return once ES6 generators are in
		// SpiderMonkey.
		var QReturnValue;
		if (typeof ReturnValue !== "undefined") {
		    QReturnValue = ReturnValue;
		} else {
		    QReturnValue = function (value) {
		        this.value = value;
		    };
		}
		
		// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
		// engine that has a deployed base of browsers that support generators.
		// However, SM's generators use the Python-inspired semantics of
		// outdated ES6 drafts.  We would like to support ES6, but we'd also
		// like to make it possible to use generators in deployed browsers, so
		// we also support Python-style generators.  At some point we can remove
		// this block.
		var hasES6Generators;
		try {
		    /* jshint evil: true, nonew: false */
		    new Function("(function* (){ yield 1; })");
		    hasES6Generators = true;
		} catch (e) {
		    hasES6Generators = false;
		}
		
		// long stack traces
		
		var STACK_JUMP_SEPARATOR = "From previous event:";
		
		function makeStackTraceLong(error, promise) {
		    // If possible, transform the error stack trace by removing Node and Q
		    // cruft, then concatenating with the stack trace of `promise`. See #57.
		    if (hasStacks &&
		        promise.stack &&
		        typeof error === "object" &&
		        error !== null &&
		        error.stack &&
		        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
		    ) {
		        var stacks = [];
		        for (var p = promise; !!p; p = p.source) {
		            if (p.stack) {
		                stacks.unshift(p.stack);
		            }
		        }
		        stacks.unshift(error.stack);
		
		        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
		        error.stack = filterStackString(concatedStacks);
		    }
		}
		
		function filterStackString(stackString) {
		    var lines = stackString.split("\n");
		    var desiredLines = [];
		    for (var i = 0; i < lines.length; ++i) {
		        var line = lines[i];
		
		        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
		            desiredLines.push(line);
		        }
		    }
		    return desiredLines.join("\n");
		}
		
		function isNodeFrame(stackLine) {
		    return stackLine.indexOf("(module.js:") !== -1 ||
		           stackLine.indexOf("(node.js:") !== -1;
		}
		
		function getFileNameAndLineNumber(stackLine) {
		    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
		    // In IE10 function name can have spaces ("Anonymous function") O_o
		    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
		    if (attempt1) {
		        return [attempt1[1], Number(attempt1[2])];
		    }
		
		    // Anonymous functions: "at filename:lineNumber:columnNumber"
		    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
		    if (attempt2) {
		        return [attempt2[1], Number(attempt2[2])];
		    }
		
		    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
		    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
		    if (attempt3) {
		        return [attempt3[1], Number(attempt3[2])];
		    }
		}
		
		function isInternalFrame(stackLine) {
		    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
		
		    if (!fileNameAndLineNumber) {
		        return false;
		    }
		
		    var fileName = fileNameAndLineNumber[0];
		    var lineNumber = fileNameAndLineNumber[1];
		
		    return fileName === qFileName &&
		        lineNumber >= qStartingLine &&
		        lineNumber <= qEndingLine;
		}
		
		// discover own file name and line number range for filtering stack
		// traces
		function captureLine() {
		    if (!hasStacks) {
		        return;
		    }
		
		    try {
		        throw new Error();
		    } catch (e) {
		        var lines = e.stack.split("\n");
		        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
		        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
		        if (!fileNameAndLineNumber) {
		            return;
		        }
		
		        qFileName = fileNameAndLineNumber[0];
		        return fileNameAndLineNumber[1];
		    }
		}
		
		function deprecate(callback, name, alternative) {
		    return function () {
		        if (typeof console !== "undefined" &&
		            typeof console.warn === "function") {
		            console.warn(name + " is deprecated, use " + alternative +
		                         " instead.", new Error("").stack);
		        }
		        return callback.apply(callback, arguments);
		    };
		}
		
		// end of shims
		// beginning of real work
		
		/**
		 * Constructs a promise for an immediate reference, passes promises through, or
		 * coerces promises from different systems.
		 * @param value immediate reference or promise
		 */
		function Q(value) {
		    // If the object is already a Promise, return it directly.  This enables
		    // the resolve function to both be used to created references from objects,
		    // but to tolerably coerce non-promises to promises.
		    if (isPromise(value)) {
		        return value;
		    }
		
		    // assimilate thenables
		    if (isPromiseAlike(value)) {
		        return coerce(value);
		    } else {
		        return fulfill(value);
		    }
		}
		Q.resolve = Q;
		
		/**
		 * Performs a task in a future turn of the event loop.
		 * @param {Function} task
		 */
		Q.nextTick = nextTick;
		
		/**
		 * Controls whether or not long stack traces will be on
		 */
		Q.longStackSupport = false;
		
		/**
		 * Constructs a {promise, resolve, reject} object.
		 *
		 * `resolve` is a callback to invoke with a more resolved value for the
		 * promise. To fulfill the promise, invoke `resolve` with any value that is
		 * not a thenable. To reject the promise, invoke `resolve` with a rejected
		 * thenable, or invoke `reject` with the reason directly. To resolve the
		 * promise to another thenable, thus putting it in the same state, invoke
		 * `resolve` with that other thenable.
		 */
		Q.defer = defer;
		function defer() {
		    // if "messages" is an "Array", that indicates that the promise has not yet
		    // been resolved.  If it is "undefined", it has been resolved.  Each
		    // element of the messages array is itself an array of complete arguments to
		    // forward to the resolved promise.  We coerce the resolution value to a
		    // promise using the `resolve` function because it handles both fully
		    // non-thenable values and other thenables gracefully.
		    var messages = [], progressListeners = [], resolvedPromise;
		
		    var deferred = object_create(defer.prototype);
		    var promise = object_create(Promise.prototype);
		
		    promise.promiseDispatch = function (resolve, op, operands) {
		        var args = array_slice(arguments);
		        if (messages) {
		            messages.push(args);
		            if (op === "when" && operands[1]) { // progress operand
		                progressListeners.push(operands[1]);
		            }
		        } else {
		            nextTick(function () {
		                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
		            });
		        }
		    };
		
		    // XXX deprecated
		    promise.valueOf = function () {
		        if (messages) {
		            return promise;
		        }
		        var nearerValue = nearer(resolvedPromise);
		        if (isPromise(nearerValue)) {
		            resolvedPromise = nearerValue; // shorten chain
		        }
		        return nearerValue;
		    };
		
		    promise.inspect = function () {
		        if (!resolvedPromise) {
		            return { state: "pending" };
		        }
		        return resolvedPromise.inspect();
		    };
		
		    if (Q.longStackSupport && hasStacks) {
		        try {
		            throw new Error();
		        } catch (e) {
		            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
		            // accessor around; that causes memory leaks as per GH-111. Just
		            // reify the stack trace as a string ASAP.
		            //
		            // At the same time, cut off the first line; it's always just
		            // "[object Promise]\n", as per the `toString`.
		            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
		        }
		    }
		
		    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
		    // consolidating them into `become`, since otherwise we'd create new
		    // promises with the lines `become(whatever(value))`. See e.g. GH-252.
		
		    function become(newPromise) {
		        resolvedPromise = newPromise;
		        promise.source = newPromise;
		
		        array_reduce(messages, function (undefined, message) {
		            nextTick(function () {
		                newPromise.promiseDispatch.apply(newPromise, message);
		            });
		        }, void 0);
		
		        messages = void 0;
		        progressListeners = void 0;
		    }
		
		    deferred.promise = promise;
		    deferred.resolve = function (value) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        become(Q(value));
		    };
		
		    deferred.fulfill = function (value) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        become(fulfill(value));
		    };
		    deferred.reject = function (reason) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        become(reject(reason));
		    };
		    deferred.notify = function (progress) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        array_reduce(progressListeners, function (undefined, progressListener) {
		            nextTick(function () {
		                progressListener(progress);
		            });
		        }, void 0);
		    };
		
		    return deferred;
		}
		
		/**
		 * Creates a Node-style callback that will resolve or reject the deferred
		 * promise.
		 * @returns a nodeback
		 */
		defer.prototype.makeNodeResolver = function () {
		    var self = this;
		    return function (error, value) {
		        if (error) {
		            self.reject(error);
		        } else if (arguments.length > 2) {
		            self.resolve(array_slice(arguments, 1));
		        } else {
		            self.resolve(value);
		        }
		    };
		};
		
		/**
		 * @param resolver {Function} a function that returns nothing and accepts
		 * the resolve, reject, and notify functions for a deferred.
		 * @returns a promise that may be resolved with the given resolve and reject
		 * functions, or rejected by a thrown exception in resolver
		 */
		Q.promise = promise;
		function promise(resolver) {
		    if (typeof resolver !== "function") {
		        throw new TypeError("resolver must be a function.");
		    }
		    var deferred = defer();
		    try {
		        resolver(deferred.resolve, deferred.reject, deferred.notify);
		    } catch (reason) {
		        deferred.reject(reason);
		    }
		    return deferred.promise;
		}
		
		// XXX experimental.  This method is a way to denote that a local value is
		// serializable and should be immediately dispatched to a remote upon request,
		// instead of passing a reference.
		Q.passByCopy = function (object) {
		    //freeze(object);
		    //passByCopies.set(object, true);
		    return object;
		};
		
		Promise.prototype.passByCopy = function () {
		    //freeze(object);
		    //passByCopies.set(object, true);
		    return this;
		};
		
		/**
		 * If two promises eventually fulfill to the same value, promises that value,
		 * but otherwise rejects.
		 * @param x {Any*}
		 * @param y {Any*}
		 * @returns {Any*} a promise for x and y if they are the same, but a rejection
		 * otherwise.
		 *
		 */
		Q.join = function (x, y) {
		    return Q(x).join(y);
		};
		
		Promise.prototype.join = function (that) {
		    return Q([this, that]).spread(function (x, y) {
		        if (x === y) {
		            // TODO: "===" should be Object.is or equiv
		            return x;
		        } else {
		            throw new Error("Can't join: not the same: " + x + " " + y);
		        }
		    });
		};
		
		/**
		 * Returns a promise for the first of an array of promises to become fulfilled.
		 * @param answers {Array[Any*]} promises to race
		 * @returns {Any*} the first promise to be fulfilled
		 */
		Q.race = race;
		function race(answerPs) {
		    return promise(function(resolve, reject) {
		        // Switch to this once we can assume at least ES5
		        // answerPs.forEach(function(answerP) {
		        //     Q(answerP).then(resolve, reject);
		        // });
		        // Use this in the meantime
		        for (var i = 0, len = answerPs.length; i < len; i++) {
		            Q(answerPs[i]).then(resolve, reject);
		        }
		    });
		}
		
		Promise.prototype.race = function () {
		    return this.then(Q.race);
		};
		
		/**
		 * Constructs a Promise with a promise descriptor object and optional fallback
		 * function.  The descriptor contains methods like when(rejected), get(name),
		 * set(name, value), post(name, args), and delete(name), which all
		 * return either a value, a promise for a value, or a rejection.  The fallback
		 * accepts the operation name, a resolver, and any further arguments that would
		 * have been forwarded to the appropriate method above had a method been
		 * provided with the proper name.  The API makes no guarantees about the nature
		 * of the returned object, apart from that it is usable whereever promises are
		 * bought and sold.
		 */
		Q.makePromise = Promise;
		function Promise(descriptor, fallback, inspect) {
		    if (fallback === void 0) {
		        fallback = function (op) {
		            return reject(new Error(
		                "Promise does not support operation: " + op
		            ));
		        };
		    }
		    if (inspect === void 0) {
		        inspect = function () {
		            return {state: "unknown"};
		        };
		    }
		
		    var promise = object_create(Promise.prototype);
		
		    promise.promiseDispatch = function (resolve, op, args) {
		        var result;
		        try {
		            if (descriptor[op]) {
		                result = descriptor[op].apply(promise, args);
		            } else {
		                result = fallback.call(promise, op, args);
		            }
		        } catch (exception) {
		            result = reject(exception);
		        }
		        if (resolve) {
		            resolve(result);
		        }
		    };
		
		    promise.inspect = inspect;
		
		    // XXX deprecated `valueOf` and `exception` support
		    if (inspect) {
		        var inspected = inspect();
		        if (inspected.state === "rejected") {
		            promise.exception = inspected.reason;
		        }
		
		        promise.valueOf = function () {
		            var inspected = inspect();
		            if (inspected.state === "pending" ||
		                inspected.state === "rejected") {
		                return promise;
		            }
		            return inspected.value;
		        };
		    }
		
		    return promise;
		}
		
		Promise.prototype.toString = function () {
		    return "[object Promise]";
		};
		
		Promise.prototype.then = function (fulfilled, rejected, progressed) {
		    var self = this;
		    var deferred = defer();
		    var done = false;   // ensure the untrusted promise makes at most a
		                        // single call to one of the callbacks
		
		    function _fulfilled(value) {
		        try {
		            return typeof fulfilled === "function" ? fulfilled(value) : value;
		        } catch (exception) {
		            return reject(exception);
		        }
		    }
		
		    function _rejected(exception) {
		        if (typeof rejected === "function") {
		            makeStackTraceLong(exception, self);
		            try {
		                return rejected(exception);
		            } catch (newException) {
		                return reject(newException);
		            }
		        }
		        return reject(exception);
		    }
		
		    function _progressed(value) {
		        return typeof progressed === "function" ? progressed(value) : value;
		    }
		
		    nextTick(function () {
		        self.promiseDispatch(function (value) {
		            if (done) {
		                return;
		            }
		            done = true;
		
		            deferred.resolve(_fulfilled(value));
		        }, "when", [function (exception) {
		            if (done) {
		                return;
		            }
		            done = true;
		
		            deferred.resolve(_rejected(exception));
		        }]);
		    });
		
		    // Progress propagator need to be attached in the current tick.
		    self.promiseDispatch(void 0, "when", [void 0, function (value) {
		        var newValue;
		        var threw = false;
		        try {
		            newValue = _progressed(value);
		        } catch (e) {
		            threw = true;
		            if (Q.onerror) {
		                Q.onerror(e);
		            } else {
		                throw e;
		            }
		        }
		
		        if (!threw) {
		            deferred.notify(newValue);
		        }
		    }]);
		
		    return deferred.promise;
		};
		
		/**
		 * Registers an observer on a promise.
		 *
		 * Guarantees:
		 *
		 * 1. that fulfilled and rejected will be called only once.
		 * 2. that either the fulfilled callback or the rejected callback will be
		 *    called, but not both.
		 * 3. that fulfilled and rejected will not be called in this turn.
		 *
		 * @param value      promise or immediate reference to observe
		 * @param fulfilled  function to be called with the fulfilled value
		 * @param rejected   function to be called with the rejection exception
		 * @param progressed function to be called on any progress notifications
		 * @return promise for the return value from the invoked callback
		 */
		Q.when = when;
		function when(value, fulfilled, rejected, progressed) {
		    return Q(value).then(fulfilled, rejected, progressed);
		}
		
		Promise.prototype.thenResolve = function (value) {
		    return this.then(function () { return value; });
		};
		
		Q.thenResolve = function (promise, value) {
		    return Q(promise).thenResolve(value);
		};
		
		Promise.prototype.thenReject = function (reason) {
		    return this.then(function () { throw reason; });
		};
		
		Q.thenReject = function (promise, reason) {
		    return Q(promise).thenReject(reason);
		};
		
		/**
		 * If an object is not a promise, it is as "near" as possible.
		 * If a promise is rejected, it is as "near" as possible too.
		 * If its a fulfilled promise, the fulfillment value is nearer.
		 * If its a deferred promise and the deferred has been resolved, the
		 * resolution is "nearer".
		 * @param object
		 * @returns most resolved (nearest) form of the object
		 */
		
		// XXX should we re-do this?
		Q.nearer = nearer;
		function nearer(value) {
		    if (isPromise(value)) {
		        var inspected = value.inspect();
		        if (inspected.state === "fulfilled") {
		            return inspected.value;
		        }
		    }
		    return value;
		}
		
		/**
		 * @returns whether the given object is a promise.
		 * Otherwise it is a fulfilled value.
		 */
		Q.isPromise = isPromise;
		function isPromise(object) {
		    return isObject(object) &&
		        typeof object.promiseDispatch === "function" &&
		        typeof object.inspect === "function";
		}
		
		Q.isPromiseAlike = isPromiseAlike;
		function isPromiseAlike(object) {
		    return isObject(object) && typeof object.then === "function";
		}
		
		/**
		 * @returns whether the given object is a pending promise, meaning not
		 * fulfilled or rejected.
		 */
		Q.isPending = isPending;
		function isPending(object) {
		    return isPromise(object) && object.inspect().state === "pending";
		}
		
		Promise.prototype.isPending = function () {
		    return this.inspect().state === "pending";
		};
		
		/**
		 * @returns whether the given object is a value or fulfilled
		 * promise.
		 */
		Q.isFulfilled = isFulfilled;
		function isFulfilled(object) {
		    return !isPromise(object) || object.inspect().state === "fulfilled";
		}
		
		Promise.prototype.isFulfilled = function () {
		    return this.inspect().state === "fulfilled";
		};
		
		/**
		 * @returns whether the given object is a rejected promise.
		 */
		Q.isRejected = isRejected;
		function isRejected(object) {
		    return isPromise(object) && object.inspect().state === "rejected";
		}
		
		Promise.prototype.isRejected = function () {
		    return this.inspect().state === "rejected";
		};
		
		//// BEGIN UNHANDLED REJECTION TRACKING
		
		// This promise library consumes exceptions thrown in handlers so they can be
		// handled by a subsequent promise.  The exceptions get added to this array when
		// they are created, and removed when they are handled.  Note that in ES6 or
		// shimmed environments, this would naturally be a `Set`.
		var unhandledReasons = [];
		var unhandledRejections = [];
		var unhandledReasonsDisplayed = false;
		var trackUnhandledRejections = true;
		function displayUnhandledReasons() {
		    if (
		        !unhandledReasonsDisplayed &&
		        typeof window !== "undefined" &&
		        window.console
		    ) {
		        console.warn("[Q] Unhandled rejection reasons (should be empty):",
		                     unhandledReasons);
		    }
		
		    unhandledReasonsDisplayed = true;
		}
		
		function logUnhandledReasons() {
		    for (var i = 0; i < unhandledReasons.length; i++) {
		        var reason = unhandledReasons[i];
		        console.warn("Unhandled rejection reason:", reason);
		    }
		}
		
		function resetUnhandledRejections() {
		    unhandledReasons.length = 0;
		    unhandledRejections.length = 0;
		    unhandledReasonsDisplayed = false;
		
		    if (!trackUnhandledRejections) {
		        trackUnhandledRejections = true;
		
		        // Show unhandled rejection reasons if Node exits without handling an
		        // outstanding rejection.  (Note that Browserify presently produces a
		        // `process` global without the `EventEmitter` `on` method.)
		        if (typeof process !== "undefined" && process.on) {
		            process.on("exit", logUnhandledReasons);
		        }
		    }
		}
		
		function trackRejection(promise, reason) {
		    if (!trackUnhandledRejections) {
		        return;
		    }
		
		    unhandledRejections.push(promise);
		    if (reason && typeof reason.stack !== "undefined") {
		        unhandledReasons.push(reason.stack);
		    } else {
		        unhandledReasons.push("(no stack) " + reason);
		    }
		    displayUnhandledReasons();
		}
		
		function untrackRejection(promise) {
		    if (!trackUnhandledRejections) {
		        return;
		    }
		
		    var at = array_indexOf(unhandledRejections, promise);
		    if (at !== -1) {
		        unhandledRejections.splice(at, 1);
		        unhandledReasons.splice(at, 1);
		    }
		}
		
		Q.resetUnhandledRejections = resetUnhandledRejections;
		
		Q.getUnhandledReasons = function () {
		    // Make a copy so that consumers can't interfere with our internal state.
		    return unhandledReasons.slice();
		};
		
		Q.stopUnhandledRejectionTracking = function () {
		    resetUnhandledRejections();
		    if (typeof process !== "undefined" && process.on) {
		        process.removeListener("exit", logUnhandledReasons);
		    }
		    trackUnhandledRejections = false;
		};
		
		resetUnhandledRejections();
		
		//// END UNHANDLED REJECTION TRACKING
		
		/**
		 * Constructs a rejected promise.
		 * @param reason value describing the failure
		 */
		Q.reject = reject;
		function reject(reason) {
		    var rejection = Promise({
		        "when": function (rejected) {
		            // note that the error has been handled
		            if (rejected) {
		                untrackRejection(this);
		            }
		            return rejected ? rejected(reason) : this;
		        }
		    }, function fallback() {
		        return this;
		    }, function inspect() {
		        return { state: "rejected", reason: reason };
		    });
		
		    // Note that the reason has not been handled.
		    trackRejection(rejection, reason);
		
		    return rejection;
		}
		
		/**
		 * Constructs a fulfilled promise for an immediate reference.
		 * @param value immediate reference
		 */
		Q.fulfill = fulfill;
		function fulfill(value) {
		    return Promise({
		        "when": function () {
		            return value;
		        },
		        "get": function (name) {
		            return value[name];
		        },
		        "set": function (name, rhs) {
		            value[name] = rhs;
		        },
		        "delete": function (name) {
		            delete value[name];
		        },
		        "post": function (name, args) {
		            // Mark Miller proposes that post with no name should apply a
		            // promised function.
		            if (name === null || name === void 0) {
		                return value.apply(void 0, args);
		            } else {
		                return value[name].apply(value, args);
		            }
		        },
		        "apply": function (thisp, args) {
		            return value.apply(thisp, args);
		        },
		        "keys": function () {
		            return object_keys(value);
		        }
		    }, void 0, function inspect() {
		        return { state: "fulfilled", value: value };
		    });
		}
		
		/**
		 * Converts thenables to Q promises.
		 * @param promise thenable promise
		 * @returns a Q promise
		 */
		function coerce(promise) {
		    var deferred = defer();
		    nextTick(function () {
		        try {
		            promise.then(deferred.resolve, deferred.reject, deferred.notify);
		        } catch (exception) {
		            deferred.reject(exception);
		        }
		    });
		    return deferred.promise;
		}
		
		/**
		 * Annotates an object such that it will never be
		 * transferred away from this process over any promise
		 * communication channel.
		 * @param object
		 * @returns promise a wrapping of that object that
		 * additionally responds to the "isDef" message
		 * without a rejection.
		 */
		Q.master = master;
		function master(object) {
		    return Promise({
		        "isDef": function () {}
		    }, function fallback(op, args) {
		        return dispatch(object, op, args);
		    }, function () {
		        return Q(object).inspect();
		    });
		}
		
		/**
		 * Spreads the values of a promised array of arguments into the
		 * fulfillment callback.
		 * @param fulfilled callback that receives variadic arguments from the
		 * promised array
		 * @param rejected callback that receives the exception if the promise
		 * is rejected.
		 * @returns a promise for the return value or thrown exception of
		 * either callback.
		 */
		Q.spread = spread;
		function spread(value, fulfilled, rejected) {
		    return Q(value).spread(fulfilled, rejected);
		}
		
		Promise.prototype.spread = function (fulfilled, rejected) {
		    return this.all().then(function (array) {
		        return fulfilled.apply(void 0, array);
		    }, rejected);
		};
		
		/**
		 * The async function is a decorator for generator functions, turning
		 * them into asynchronous generators.  Although generators are only part
		 * of the newest ECMAScript 6 drafts, this code does not cause syntax
		 * errors in older engines.  This code should continue to work and will
		 * in fact improve over time as the language improves.
		 *
		 * ES6 generators are currently part of V8 version 3.19 with the
		 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
		 * for longer, but under an older Python-inspired form.  This function
		 * works on both kinds of generators.
		 *
		 * Decorates a generator function such that:
		 *  - it may yield promises
		 *  - execution will continue when that promise is fulfilled
		 *  - the value of the yield expression will be the fulfilled value
		 *  - it returns a promise for the return value (when the generator
		 *    stops iterating)
		 *  - the decorated function returns a promise for the return value
		 *    of the generator or the first rejected promise among those
		 *    yielded.
		 *  - if an error is thrown in the generator, it propagates through
		 *    every following yield until it is caught, or until it escapes
		 *    the generator function altogether, and is translated into a
		 *    rejection for the promise returned by the decorated generator.
		 */
		Q.async = async;
		function async(makeGenerator) {
		    return function () {
		        // when verb is "send", arg is a value
		        // when verb is "throw", arg is an exception
		        function continuer(verb, arg) {
		            var result;
		            if (hasES6Generators) {
		                try {
		                    result = generator[verb](arg);
		                } catch (exception) {
		                    return reject(exception);
		                }
		                if (result.done) {
		                    return result.value;
		                } else {
		                    return when(result.value, callback, errback);
		                }
		            } else {
		                // FIXME: Remove this case when SM does ES6 generators.
		                try {
		                    result = generator[verb](arg);
		                } catch (exception) {
		                    if (isStopIteration(exception)) {
		                        return exception.value;
		                    } else {
		                        return reject(exception);
		                    }
		                }
		                return when(result, callback, errback);
		            }
		        }
		        var generator = makeGenerator.apply(this, arguments);
		        var callback = continuer.bind(continuer, "next");
		        var errback = continuer.bind(continuer, "throw");
		        return callback();
		    };
		}
		
		/**
		 * The spawn function is a small wrapper around async that immediately
		 * calls the generator and also ends the promise chain, so that any
		 * unhandled errors are thrown instead of forwarded to the error
		 * handler. This is useful because it's extremely common to run
		 * generators at the top-level to work with libraries.
		 */
		Q.spawn = spawn;
		function spawn(makeGenerator) {
		    Q.done(Q.async(makeGenerator)());
		}
		
		// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
		/**
		 * Throws a ReturnValue exception to stop an asynchronous generator.
		 *
		 * This interface is a stop-gap measure to support generator return
		 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
		 * generators like Chromium 29, just use "return" in your generator
		 * functions.
		 *
		 * @param value the return value for the surrounding generator
		 * @throws ReturnValue exception with the value.
		 * @example
		 * // ES6 style
		 * Q.async(function* () {
		 *      var foo = yield getFooPromise();
		 *      var bar = yield getBarPromise();
		 *      return foo + bar;
		 * })
		 * // Older SpiderMonkey style
		 * Q.async(function () {
		 *      var foo = yield getFooPromise();
		 *      var bar = yield getBarPromise();
		 *      Q.return(foo + bar);
		 * })
		 */
		Q["return"] = _return;
		function _return(value) {
		    throw new QReturnValue(value);
		}
		
		/**
		 * The promised function decorator ensures that any promise arguments
		 * are settled and passed as values (`this` is also settled and passed
		 * as a value).  It will also ensure that the result of a function is
		 * always a promise.
		 *
		 * @example
		 * var add = Q.promised(function (a, b) {
		 *     return a + b;
		 * });
		 * add(Q(a), Q(B));
		 *
		 * @param {function} callback The function to decorate
		 * @returns {function} a function that has been decorated.
		 */
		Q.promised = promised;
		function promised(callback) {
		    return function () {
		        return spread([this, all(arguments)], function (self, args) {
		            return callback.apply(self, args);
		        });
		    };
		}
		
		/**
		 * sends a message to a value in a future turn
		 * @param object* the recipient
		 * @param op the name of the message operation, e.g., "when",
		 * @param args further arguments to be forwarded to the operation
		 * @returns result {Promise} a promise for the result of the operation
		 */
		Q.dispatch = dispatch;
		function dispatch(object, op, args) {
		    return Q(object).dispatch(op, args);
		}
		
		Promise.prototype.dispatch = function (op, args) {
		    var self = this;
		    var deferred = defer();
		    nextTick(function () {
		        self.promiseDispatch(deferred.resolve, op, args);
		    });
		    return deferred.promise;
		};
		
		/**
		 * Gets the value of a property in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of property to get
		 * @return promise for the property value
		 */
		Q.get = function (object, key) {
		    return Q(object).dispatch("get", [key]);
		};
		
		Promise.prototype.get = function (key) {
		    return this.dispatch("get", [key]);
		};
		
		/**
		 * Sets the value of a property in a future turn.
		 * @param object    promise or immediate reference for object object
		 * @param name      name of property to set
		 * @param value     new value of property
		 * @return promise for the return value
		 */
		Q.set = function (object, key, value) {
		    return Q(object).dispatch("set", [key, value]);
		};
		
		Promise.prototype.set = function (key, value) {
		    return this.dispatch("set", [key, value]);
		};
		
		/**
		 * Deletes a property in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of property to delete
		 * @return promise for the return value
		 */
		Q.del = // XXX legacy
		Q["delete"] = function (object, key) {
		    return Q(object).dispatch("delete", [key]);
		};
		
		Promise.prototype.del = // XXX legacy
		Promise.prototype["delete"] = function (key) {
		    return this.dispatch("delete", [key]);
		};
		
		/**
		 * Invokes a method in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of method to invoke
		 * @param value     a value to post, typically an array of
		 *                  invocation arguments for promises that
		 *                  are ultimately backed with `resolve` values,
		 *                  as opposed to those backed with URLs
		 *                  wherein the posted value can be any
		 *                  JSON serializable object.
		 * @return promise for the return value
		 */
		// bound locally because it is used by other methods
		Q.mapply = // XXX As proposed by "Redsandro"
		Q.post = function (object, name, args) {
		    return Q(object).dispatch("post", [name, args]);
		};
		
		Promise.prototype.mapply = // XXX As proposed by "Redsandro"
		Promise.prototype.post = function (name, args) {
		    return this.dispatch("post", [name, args]);
		};
		
		/**
		 * Invokes a method in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of method to invoke
		 * @param ...args   array of invocation arguments
		 * @return promise for the return value
		 */
		Q.send = // XXX Mark Miller's proposed parlance
		Q.mcall = // XXX As proposed by "Redsandro"
		Q.invoke = function (object, name /*...args*/) {
		    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
		};
		
		Promise.prototype.send = // XXX Mark Miller's proposed parlance
		Promise.prototype.mcall = // XXX As proposed by "Redsandro"
		Promise.prototype.invoke = function (name /*...args*/) {
		    return this.dispatch("post", [name, array_slice(arguments, 1)]);
		};
		
		/**
		 * Applies the promised function in a future turn.
		 * @param object    promise or immediate reference for target function
		 * @param args      array of application arguments
		 */
		Q.fapply = function (object, args) {
		    return Q(object).dispatch("apply", [void 0, args]);
		};
		
		Promise.prototype.fapply = function (args) {
		    return this.dispatch("apply", [void 0, args]);
		};
		
		/**
		 * Calls the promised function in a future turn.
		 * @param object    promise or immediate reference for target function
		 * @param ...args   array of application arguments
		 */
		Q["try"] =
		Q.fcall = function (object /* ...args*/) {
		    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
		};
		
		Promise.prototype.fcall = function (/*...args*/) {
		    return this.dispatch("apply", [void 0, array_slice(arguments)]);
		};
		
		/**
		 * Binds the promised function, transforming return values into a fulfilled
		 * promise and thrown errors into a rejected one.
		 * @param object    promise or immediate reference for target function
		 * @param ...args   array of application arguments
		 */
		Q.fbind = function (object /*...args*/) {
		    var promise = Q(object);
		    var args = array_slice(arguments, 1);
		    return function fbound() {
		        return promise.dispatch("apply", [
		            this,
		            args.concat(array_slice(arguments))
		        ]);
		    };
		};
		Promise.prototype.fbind = function (/*...args*/) {
		    var promise = this;
		    var args = array_slice(arguments);
		    return function fbound() {
		        return promise.dispatch("apply", [
		            this,
		            args.concat(array_slice(arguments))
		        ]);
		    };
		};
		
		/**
		 * Requests the names of the owned properties of a promised
		 * object in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @return promise for the keys of the eventually settled object
		 */
		Q.keys = function (object) {
		    return Q(object).dispatch("keys", []);
		};
		
		Promise.prototype.keys = function () {
		    return this.dispatch("keys", []);
		};
		
		/**
		 * Turns an array of promises into a promise for an array.  If any of
		 * the promises gets rejected, the whole array is rejected immediately.
		 * @param {Array*} an array (or promise for an array) of values (or
		 * promises for values)
		 * @returns a promise for an array of the corresponding values
		 */
		// By Mark Miller
		// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
		Q.all = all;
		function all(promises) {
		    return when(promises, function (promises) {
		        var countDown = 0;
		        var deferred = defer();
		        array_reduce(promises, function (undefined, promise, index) {
		            var snapshot;
		            if (
		                isPromise(promise) &&
		                (snapshot = promise.inspect()).state === "fulfilled"
		            ) {
		                promises[index] = snapshot.value;
		            } else {
		                ++countDown;
		                when(
		                    promise,
		                    function (value) {
		                        promises[index] = value;
		                        if (--countDown === 0) {
		                            deferred.resolve(promises);
		                        }
		                    },
		                    deferred.reject,
		                    function (progress) {
		                        deferred.notify({ index: index, value: progress });
		                    }
		                );
		            }
		        }, void 0);
		        if (countDown === 0) {
		            deferred.resolve(promises);
		        }
		        return deferred.promise;
		    });
		}
		
		Promise.prototype.all = function () {
		    return all(this);
		};
		
		/**
		 * Waits for all promises to be settled, either fulfilled or
		 * rejected.  This is distinct from `all` since that would stop
		 * waiting at the first rejection.  The promise returned by
		 * `allResolved` will never be rejected.
		 * @param promises a promise for an array (or an array) of promises
		 * (or values)
		 * @return a promise for an array of promises
		 */
		Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
		function allResolved(promises) {
		    return when(promises, function (promises) {
		        promises = array_map(promises, Q);
		        return when(all(array_map(promises, function (promise) {
		            return when(promise, noop, noop);
		        })), function () {
		            return promises;
		        });
		    });
		}
		
		Promise.prototype.allResolved = function () {
		    return allResolved(this);
		};
		
		/**
		 * @see Promise#allSettled
		 */
		Q.allSettled = allSettled;
		function allSettled(promises) {
		    return Q(promises).allSettled();
		}
		
		/**
		 * Turns an array of promises into a promise for an array of their states (as
		 * returned by `inspect`) when they have all settled.
		 * @param {Array[Any*]} values an array (or promise for an array) of values (or
		 * promises for values)
		 * @returns {Array[State]} an array of states for the respective values.
		 */
		Promise.prototype.allSettled = function () {
		    return this.then(function (promises) {
		        return all(array_map(promises, function (promise) {
		            promise = Q(promise);
		            function regardless() {
		                return promise.inspect();
		            }
		            return promise.then(regardless, regardless);
		        }));
		    });
		};
		
		/**
		 * Captures the failure of a promise, giving an oportunity to recover
		 * with a callback.  If the given promise is fulfilled, the returned
		 * promise is fulfilled.
		 * @param {Any*} promise for something
		 * @param {Function} callback to fulfill the returned promise if the
		 * given promise is rejected
		 * @returns a promise for the return value of the callback
		 */
		Q.fail = // XXX legacy
		Q["catch"] = function (object, rejected) {
		    return Q(object).then(void 0, rejected);
		};
		
		Promise.prototype.fail = // XXX legacy
		Promise.prototype["catch"] = function (rejected) {
		    return this.then(void 0, rejected);
		};
		
		/**
		 * Attaches a listener that can respond to progress notifications from a
		 * promise's originating deferred. This listener receives the exact arguments
		 * passed to ``deferred.notify``.
		 * @param {Any*} promise for something
		 * @param {Function} callback to receive any progress notifications
		 * @returns the given promise, unchanged
		 */
		Q.progress = progress;
		function progress(object, progressed) {
		    return Q(object).then(void 0, void 0, progressed);
		}
		
		Promise.prototype.progress = function (progressed) {
		    return this.then(void 0, void 0, progressed);
		};
		
		/**
		 * Provides an opportunity to observe the settling of a promise,
		 * regardless of whether the promise is fulfilled or rejected.  Forwards
		 * the resolution to the returned promise when the callback is done.
		 * The callback can return a promise to defer completion.
		 * @param {Any*} promise
		 * @param {Function} callback to observe the resolution of the given
		 * promise, takes no arguments.
		 * @returns a promise for the resolution of the given promise when
		 * ``fin`` is done.
		 */
		Q.fin = // XXX legacy
		Q["finally"] = function (object, callback) {
		    return Q(object)["finally"](callback);
		};
		
		Promise.prototype.fin = // XXX legacy
		Promise.prototype["finally"] = function (callback) {
		    callback = Q(callback);
		    return this.then(function (value) {
		        return callback.fcall().then(function () {
		            return value;
		        });
		    }, function (reason) {
		        // TODO attempt to recycle the rejection with "this".
		        return callback.fcall().then(function () {
		            throw reason;
		        });
		    });
		};
		
		/**
		 * Terminates a chain of promises, forcing rejections to be
		 * thrown as exceptions.
		 * @param {Any*} promise at the end of a chain of promises
		 * @returns nothing
		 */
		Q.done = function (object, fulfilled, rejected, progress) {
		    return Q(object).done(fulfilled, rejected, progress);
		};
		
		Promise.prototype.done = function (fulfilled, rejected, progress) {
		    var onUnhandledError = function (error) {
		        // forward to a future turn so that ``when``
		        // does not catch it and turn it into a rejection.
		        nextTick(function () {
		            makeStackTraceLong(error, promise);
		            if (Q.onerror) {
		                Q.onerror(error);
		            } else {
		                throw error;
		            }
		        });
		    };
		
		    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
		    var promise = fulfilled || rejected || progress ?
		        this.then(fulfilled, rejected, progress) :
		        this;
		
		    if (typeof process === "object" && process && process.domain) {
		        onUnhandledError = process.domain.bind(onUnhandledError);
		    }
		
		    promise.then(void 0, onUnhandledError);
		};
		
		/**
		 * Causes a promise to be rejected if it does not get fulfilled before
		 * some milliseconds time out.
		 * @param {Any*} promise
		 * @param {Number} milliseconds timeout
		 * @param {String} custom error message (optional)
		 * @returns a promise for the resolution of the given promise if it is
		 * fulfilled before the timeout, otherwise rejected.
		 */
		Q.timeout = function (object, ms, message) {
		    return Q(object).timeout(ms, message);
		};
		
		Promise.prototype.timeout = function (ms, message) {
		    var deferred = defer();
		    var timeoutId = setTimeout(function () {
		        deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
		    }, ms);
		
		    this.then(function (value) {
		        clearTimeout(timeoutId);
		        deferred.resolve(value);
		    }, function (exception) {
		        clearTimeout(timeoutId);
		        deferred.reject(exception);
		    }, deferred.notify);
		
		    return deferred.promise;
		};
		
		/**
		 * Returns a promise for the given value (or promised value), some
		 * milliseconds after it resolved. Passes rejections immediately.
		 * @param {Any*} promise
		 * @param {Number} milliseconds
		 * @returns a promise for the resolution of the given promise after milliseconds
		 * time has elapsed since the resolution of the given promise.
		 * If the given promise rejects, that is passed immediately.
		 */
		Q.delay = function (object, timeout) {
		    if (timeout === void 0) {
		        timeout = object;
		        object = void 0;
		    }
		    return Q(object).delay(timeout);
		};
		
		Promise.prototype.delay = function (timeout) {
		    return this.then(function (value) {
		        var deferred = defer();
		        setTimeout(function () {
		            deferred.resolve(value);
		        }, timeout);
		        return deferred.promise;
		    });
		};
		
		/**
		 * Passes a continuation to a Node function, which is called with the given
		 * arguments provided as an array, and returns a promise.
		 *
		 *      Q.nfapply(FS.readFile, [__filename])
		 *      .then(function (content) {
		 *      })
		 *
		 */
		Q.nfapply = function (callback, args) {
		    return Q(callback).nfapply(args);
		};
		
		Promise.prototype.nfapply = function (args) {
		    var deferred = defer();
		    var nodeArgs = array_slice(args);
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.fapply(nodeArgs).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * Passes a continuation to a Node function, which is called with the given
		 * arguments provided individually, and returns a promise.
		 * @example
		 * Q.nfcall(FS.readFile, __filename)
		 * .then(function (content) {
		 * })
		 *
		 */
		Q.nfcall = function (callback /*...args*/) {
		    var args = array_slice(arguments, 1);
		    return Q(callback).nfapply(args);
		};
		
		Promise.prototype.nfcall = function (/*...args*/) {
		    var nodeArgs = array_slice(arguments);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.fapply(nodeArgs).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * Wraps a NodeJS continuation passing function and returns an equivalent
		 * version that returns a promise.
		 * @example
		 * Q.nfbind(FS.readFile, __filename)("utf-8")
		 * .then(console.log)
		 * .done()
		 */
		Q.nfbind =
		Q.denodeify = function (callback /*...args*/) {
		    var baseArgs = array_slice(arguments, 1);
		    return function () {
		        var nodeArgs = baseArgs.concat(array_slice(arguments));
		        var deferred = defer();
		        nodeArgs.push(deferred.makeNodeResolver());
		        Q(callback).fapply(nodeArgs).fail(deferred.reject);
		        return deferred.promise;
		    };
		};
		
		Promise.prototype.nfbind =
		Promise.prototype.denodeify = function (/*...args*/) {
		    var args = array_slice(arguments);
		    args.unshift(this);
		    return Q.denodeify.apply(void 0, args);
		};
		
		Q.nbind = function (callback, thisp /*...args*/) {
		    var baseArgs = array_slice(arguments, 2);
		    return function () {
		        var nodeArgs = baseArgs.concat(array_slice(arguments));
		        var deferred = defer();
		        nodeArgs.push(deferred.makeNodeResolver());
		        function bound() {
		            return callback.apply(thisp, arguments);
		        }
		        Q(bound).fapply(nodeArgs).fail(deferred.reject);
		        return deferred.promise;
		    };
		};
		
		Promise.prototype.nbind = function (/*thisp, ...args*/) {
		    var args = array_slice(arguments, 0);
		    args.unshift(this);
		    return Q.nbind.apply(void 0, args);
		};
		
		/**
		 * Calls a method of a Node-style object that accepts a Node-style
		 * callback with a given array of arguments, plus a provided callback.
		 * @param object an object that has the named method
		 * @param {String} name name of the method of object
		 * @param {Array} args arguments to pass to the method; the callback
		 * will be provided by Q and appended to these arguments.
		 * @returns a promise for the value or error
		 */
		Q.nmapply = // XXX As proposed by "Redsandro"
		Q.npost = function (object, name, args) {
		    return Q(object).npost(name, args);
		};
		
		Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
		Promise.prototype.npost = function (name, args) {
		    var nodeArgs = array_slice(args || []);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * Calls a method of a Node-style object that accepts a Node-style
		 * callback, forwarding the given variadic arguments, plus a provided
		 * callback argument.
		 * @param object an object that has the named method
		 * @param {String} name name of the method of object
		 * @param ...args arguments to pass to the method; the callback will
		 * be provided by Q and appended to these arguments.
		 * @returns a promise for the value or error
		 */
		Q.nsend = // XXX Based on Mark Miller's proposed "send"
		Q.nmcall = // XXX Based on "Redsandro's" proposal
		Q.ninvoke = function (object, name /*...args*/) {
		    var nodeArgs = array_slice(arguments, 2);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
		    return deferred.promise;
		};
		
		Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
		Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
		Promise.prototype.ninvoke = function (name /*...args*/) {
		    var nodeArgs = array_slice(arguments, 1);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * If a function would like to support both Node continuation-passing-style and
		 * promise-returning-style, it can end its internal promise chain with
		 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
		 * elects to use a nodeback, the result will be sent there.  If they do not
		 * pass a nodeback, they will receive the result promise.
		 * @param object a result (or a promise for a result)
		 * @param {Function} nodeback a Node.js-style callback
		 * @returns either the promise or nothing
		 */
		Q.nodeify = nodeify;
		function nodeify(object, nodeback) {
		    return Q(object).nodeify(nodeback);
		}
		
		Promise.prototype.nodeify = function (nodeback) {
		    if (nodeback) {
		        this.then(function (value) {
		            nextTick(function () {
		                nodeback(null, value);
		            });
		        }, function (error) {
		            nextTick(function () {
		                nodeback(error);
		            });
		        });
		    } else {
		        return this;
		    }
		};
		
		// All code before this point will be filtered from stack traces.
		var qEndingLine = captureLine();
		
		return Q;
		
		});
		
	
	}, 'async/lib/async.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'async/lib/async.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'async/lib/async.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'async/lib/async.js';
		var __dirname = 'async/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'async/lib/async.js'], env: {}};
	
		/** code **/
		/*global setImmediate: false, setTimeout: false, console: false */
		(function () {
		
		    var async = {};
		
		    // global on the server, window in the browser
		    var root, previous_async;
		
		    root = this;
		    if (root != null) {
		      previous_async = root.async;
		    }
		
		    async.noConflict = function () {
		        root.async = previous_async;
		        return async;
		    };
		
		    function only_once(fn) {
		        var called = false;
		        return function() {
		            if (called) throw new Error("Callback was already called.");
		            called = true;
		            fn.apply(root, arguments);
		        }
		    }
		
		    //// cross-browser compatiblity functions ////
		
		    var _each = function (arr, iterator) {
		        if (arr.forEach) {
		            return arr.forEach(iterator);
		        }
		        for (var i = 0; i < arr.length; i += 1) {
		            iterator(arr[i], i, arr);
		        }
		    };
		
		    var _map = function (arr, iterator) {
		        if (arr.map) {
		            return arr.map(iterator);
		        }
		        var results = [];
		        _each(arr, function (x, i, a) {
		            results.push(iterator(x, i, a));
		        });
		        return results;
		    };
		
		    var _reduce = function (arr, iterator, memo) {
		        if (arr.reduce) {
		            return arr.reduce(iterator, memo);
		        }
		        _each(arr, function (x, i, a) {
		            memo = iterator(memo, x, i, a);
		        });
		        return memo;
		    };
		
		    var _keys = function (obj) {
		        if (Object.keys) {
		            return Object.keys(obj);
		        }
		        var keys = [];
		        for (var k in obj) {
		            if (obj.hasOwnProperty(k)) {
		                keys.push(k);
		            }
		        }
		        return keys;
		    };
		
		    //// exported async module functions ////
		
		    //// nextTick implementation with browser-compatible fallback ////
		    if (typeof process === 'undefined' || !(process.nextTick)) {
		        if (typeof setImmediate === 'function') {
		            async.nextTick = function (fn) {
		                // not a direct alias for IE10 compatibility
		                setImmediate(fn);
		            };
		            async.setImmediate = async.nextTick;
		        }
		        else {
		            async.nextTick = function (fn) {
		                setTimeout(fn, 0);
		            };
		            async.setImmediate = async.nextTick;
		        }
		    }
		    else {
		        async.nextTick = process.nextTick;
		        if (typeof setImmediate !== 'undefined') {
		            async.setImmediate = function (fn) {
		              // not a direct alias for IE10 compatibility
		              setImmediate(fn);
		            };
		        }
		        else {
		            async.setImmediate = async.nextTick;
		        }
		    }
		
		    async.each = function (arr, iterator, callback) {
		        callback = callback || function () {};
		        if (!arr.length) {
		            return callback();
		        }
		        var completed = 0;
		        _each(arr, function (x) {
		            iterator(x, only_once(function (err) {
		                if (err) {
		                    callback(err);
		                    callback = function () {};
		                }
		                else {
		                    completed += 1;
		                    if (completed >= arr.length) {
		                        callback(null);
		                    }
		                }
		            }));
		        });
		    };
		    async.forEach = async.each;
		
		    async.eachSeries = function (arr, iterator, callback) {
		        callback = callback || function () {};
		        if (!arr.length) {
		            return callback();
		        }
		        var completed = 0;
		        var iterate = function () {
		            iterator(arr[completed], function (err) {
		                if (err) {
		                    callback(err);
		                    callback = function () {};
		                }
		                else {
		                    completed += 1;
		                    if (completed >= arr.length) {
		                        callback(null);
		                    }
		                    else {
		                        iterate();
		                    }
		                }
		            });
		        };
		        iterate();
		    };
		    async.forEachSeries = async.eachSeries;
		
		    async.eachLimit = function (arr, limit, iterator, callback) {
		        var fn = _eachLimit(limit);
		        fn.apply(null, [arr, iterator, callback]);
		    };
		    async.forEachLimit = async.eachLimit;
		
		    var _eachLimit = function (limit) {
		
		        return function (arr, iterator, callback) {
		            callback = callback || function () {};
		            if (!arr.length || limit <= 0) {
		                return callback();
		            }
		            var completed = 0;
		            var started = 0;
		            var running = 0;
		
		            (function replenish () {
		                if (completed >= arr.length) {
		                    return callback();
		                }
		
		                while (running < limit && started < arr.length) {
		                    started += 1;
		                    running += 1;
		                    iterator(arr[started - 1], function (err) {
		                        if (err) {
		                            callback(err);
		                            callback = function () {};
		                        }
		                        else {
		                            completed += 1;
		                            running -= 1;
		                            if (completed >= arr.length) {
		                                callback();
		                            }
		                            else {
		                                replenish();
		                            }
		                        }
		                    });
		                }
		            })();
		        };
		    };
		
		
		    var doParallel = function (fn) {
		        return function () {
		            var args = Array.prototype.slice.call(arguments);
		            return fn.apply(null, [async.each].concat(args));
		        };
		    };
		    var doParallelLimit = function(limit, fn) {
		        return function () {
		            var args = Array.prototype.slice.call(arguments);
		            return fn.apply(null, [_eachLimit(limit)].concat(args));
		        };
		    };
		    var doSeries = function (fn) {
		        return function () {
		            var args = Array.prototype.slice.call(arguments);
		            return fn.apply(null, [async.eachSeries].concat(args));
		        };
		    };
		
		
		    var _asyncMap = function (eachfn, arr, iterator, callback) {
		        var results = [];
		        arr = _map(arr, function (x, i) {
		            return {index: i, value: x};
		        });
		        eachfn(arr, function (x, callback) {
		            iterator(x.value, function (err, v) {
		                results[x.index] = v;
		                callback(err);
		            });
		        }, function (err) {
		            callback(err, results);
		        });
		    };
		    async.map = doParallel(_asyncMap);
		    async.mapSeries = doSeries(_asyncMap);
		    async.mapLimit = function (arr, limit, iterator, callback) {
		        return _mapLimit(limit)(arr, iterator, callback);
		    };
		
		    var _mapLimit = function(limit) {
		        return doParallelLimit(limit, _asyncMap);
		    };
		
		    // reduce only has a series version, as doing reduce in parallel won't
		    // work in many situations.
		    async.reduce = function (arr, memo, iterator, callback) {
		        async.eachSeries(arr, function (x, callback) {
		            iterator(memo, x, function (err, v) {
		                memo = v;
		                callback(err);
		            });
		        }, function (err) {
		            callback(err, memo);
		        });
		    };
		    // inject alias
		    async.inject = async.reduce;
		    // foldl alias
		    async.foldl = async.reduce;
		
		    async.reduceRight = function (arr, memo, iterator, callback) {
		        var reversed = _map(arr, function (x) {
		            return x;
		        }).reverse();
		        async.reduce(reversed, memo, iterator, callback);
		    };
		    // foldr alias
		    async.foldr = async.reduceRight;
		
		    var _filter = function (eachfn, arr, iterator, callback) {
		        var results = [];
		        arr = _map(arr, function (x, i) {
		            return {index: i, value: x};
		        });
		        eachfn(arr, function (x, callback) {
		            iterator(x.value, function (v) {
		                if (v) {
		                    results.push(x);
		                }
		                callback();
		            });
		        }, function (err) {
		            callback(_map(results.sort(function (a, b) {
		                return a.index - b.index;
		            }), function (x) {
		                return x.value;
		            }));
		        });
		    };
		    async.filter = doParallel(_filter);
		    async.filterSeries = doSeries(_filter);
		    // select alias
		    async.select = async.filter;
		    async.selectSeries = async.filterSeries;
		
		    var _reject = function (eachfn, arr, iterator, callback) {
		        var results = [];
		        arr = _map(arr, function (x, i) {
		            return {index: i, value: x};
		        });
		        eachfn(arr, function (x, callback) {
		            iterator(x.value, function (v) {
		                if (!v) {
		                    results.push(x);
		                }
		                callback();
		            });
		        }, function (err) {
		            callback(_map(results.sort(function (a, b) {
		                return a.index - b.index;
		            }), function (x) {
		                return x.value;
		            }));
		        });
		    };
		    async.reject = doParallel(_reject);
		    async.rejectSeries = doSeries(_reject);
		
		    var _detect = function (eachfn, arr, iterator, main_callback) {
		        eachfn(arr, function (x, callback) {
		            iterator(x, function (result) {
		                if (result) {
		                    main_callback(x);
		                    main_callback = function () {};
		                }
		                else {
		                    callback();
		                }
		            });
		        }, function (err) {
		            main_callback();
		        });
		    };
		    async.detect = doParallel(_detect);
		    async.detectSeries = doSeries(_detect);
		
		    async.some = function (arr, iterator, main_callback) {
		        async.each(arr, function (x, callback) {
		            iterator(x, function (v) {
		                if (v) {
		                    main_callback(true);
		                    main_callback = function () {};
		                }
		                callback();
		            });
		        }, function (err) {
		            main_callback(false);
		        });
		    };
		    // any alias
		    async.any = async.some;
		
		    async.every = function (arr, iterator, main_callback) {
		        async.each(arr, function (x, callback) {
		            iterator(x, function (v) {
		                if (!v) {
		                    main_callback(false);
		                    main_callback = function () {};
		                }
		                callback();
		            });
		        }, function (err) {
		            main_callback(true);
		        });
		    };
		    // all alias
		    async.all = async.every;
		
		    async.sortBy = function (arr, iterator, callback) {
		        async.map(arr, function (x, callback) {
		            iterator(x, function (err, criteria) {
		                if (err) {
		                    callback(err);
		                }
		                else {
		                    callback(null, {value: x, criteria: criteria});
		                }
		            });
		        }, function (err, results) {
		            if (err) {
		                return callback(err);
		            }
		            else {
		                var fn = function (left, right) {
		                    var a = left.criteria, b = right.criteria;
		                    return a < b ? -1 : a > b ? 1 : 0;
		                };
		                callback(null, _map(results.sort(fn), function (x) {
		                    return x.value;
		                }));
		            }
		        });
		    };
		
		    async.auto = function (tasks, callback) {
		        callback = callback || function () {};
		        var keys = _keys(tasks);
		        if (!keys.length) {
		            return callback(null);
		        }
		
		        var results = {};
		
		        var listeners = [];
		        var addListener = function (fn) {
		            listeners.unshift(fn);
		        };
		        var removeListener = function (fn) {
		            for (var i = 0; i < listeners.length; i += 1) {
		                if (listeners[i] === fn) {
		                    listeners.splice(i, 1);
		                    return;
		                }
		            }
		        };
		        var taskComplete = function () {
		            _each(listeners.slice(0), function (fn) {
		                fn();
		            });
		        };
		
		        addListener(function () {
		            if (_keys(results).length === keys.length) {
		                callback(null, results);
		                callback = function () {};
		            }
		        });
		
		        _each(keys, function (k) {
		            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
		            var taskCallback = function (err) {
		                var args = Array.prototype.slice.call(arguments, 1);
		                if (args.length <= 1) {
		                    args = args[0];
		                }
		                if (err) {
		                    var safeResults = {};
		                    _each(_keys(results), function(rkey) {
		                        safeResults[rkey] = results[rkey];
		                    });
		                    safeResults[k] = args;
		                    callback(err, safeResults);
		                    // stop subsequent errors hitting callback multiple times
		                    callback = function () {};
		                }
		                else {
		                    results[k] = args;
		                    async.setImmediate(taskComplete);
		                }
		            };
		            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
		            var ready = function () {
		                return _reduce(requires, function (a, x) {
		                    return (a && results.hasOwnProperty(x));
		                }, true) && !results.hasOwnProperty(k);
		            };
		            if (ready()) {
		                task[task.length - 1](taskCallback, results);
		            }
		            else {
		                var listener = function () {
		                    if (ready()) {
		                        removeListener(listener);
		                        task[task.length - 1](taskCallback, results);
		                    }
		                };
		                addListener(listener);
		            }
		        });
		    };
		
		    async.waterfall = function (tasks, callback) {
		        callback = callback || function () {};
		        if (tasks.constructor !== Array) {
		          var err = new Error('First argument to waterfall must be an array of functions');
		          return callback(err);
		        }
		        if (!tasks.length) {
		            return callback();
		        }
		        var wrapIterator = function (iterator) {
		            return function (err) {
		                if (err) {
		                    callback.apply(null, arguments);
		                    callback = function () {};
		                }
		                else {
		                    var args = Array.prototype.slice.call(arguments, 1);
		                    var next = iterator.next();
		                    if (next) {
		                        args.push(wrapIterator(next));
		                    }
		                    else {
		                        args.push(callback);
		                    }
		                    async.setImmediate(function () {
		                        iterator.apply(null, args);
		                    });
		                }
		            };
		        };
		        wrapIterator(async.iterator(tasks))();
		    };
		
		    var _parallel = function(eachfn, tasks, callback) {
		        callback = callback || function () {};
		        if (tasks.constructor === Array) {
		            eachfn.map(tasks, function (fn, callback) {
		                if (fn) {
		                    fn(function (err) {
		                        var args = Array.prototype.slice.call(arguments, 1);
		                        if (args.length <= 1) {
		                            args = args[0];
		                        }
		                        callback.call(null, err, args);
		                    });
		                }
		            }, callback);
		        }
		        else {
		            var results = {};
		            eachfn.each(_keys(tasks), function (k, callback) {
		                tasks[k](function (err) {
		                    var args = Array.prototype.slice.call(arguments, 1);
		                    if (args.length <= 1) {
		                        args = args[0];
		                    }
		                    results[k] = args;
		                    callback(err);
		                });
		            }, function (err) {
		                callback(err, results);
		            });
		        }
		    };
		
		    async.parallel = function (tasks, callback) {
		        _parallel({ map: async.map, each: async.each }, tasks, callback);
		    };
		
		    async.parallelLimit = function(tasks, limit, callback) {
		        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
		    };
		
		    async.series = function (tasks, callback) {
		        callback = callback || function () {};
		        if (tasks.constructor === Array) {
		            async.mapSeries(tasks, function (fn, callback) {
		                if (fn) {
		                    fn(function (err) {
		                        var args = Array.prototype.slice.call(arguments, 1);
		                        if (args.length <= 1) {
		                            args = args[0];
		                        }
		                        callback.call(null, err, args);
		                    });
		                }
		            }, callback);
		        }
		        else {
		            var results = {};
		            async.eachSeries(_keys(tasks), function (k, callback) {
		                tasks[k](function (err) {
		                    var args = Array.prototype.slice.call(arguments, 1);
		                    if (args.length <= 1) {
		                        args = args[0];
		                    }
		                    results[k] = args;
		                    callback(err);
		                });
		            }, function (err) {
		                callback(err, results);
		            });
		        }
		    };
		
		    async.iterator = function (tasks) {
		        var makeCallback = function (index) {
		            var fn = function () {
		                if (tasks.length) {
		                    tasks[index].apply(null, arguments);
		                }
		                return fn.next();
		            };
		            fn.next = function () {
		                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
		            };
		            return fn;
		        };
		        return makeCallback(0);
		    };
		
		    async.apply = function (fn) {
		        var args = Array.prototype.slice.call(arguments, 1);
		        return function () {
		            return fn.apply(
		                null, args.concat(Array.prototype.slice.call(arguments))
		            );
		        };
		    };
		
		    var _concat = function (eachfn, arr, fn, callback) {
		        var r = [];
		        eachfn(arr, function (x, cb) {
		            fn(x, function (err, y) {
		                r = r.concat(y || []);
		                cb(err);
		            });
		        }, function (err) {
		            callback(err, r);
		        });
		    };
		    async.concat = doParallel(_concat);
		    async.concatSeries = doSeries(_concat);
		
		    async.whilst = function (test, iterator, callback) {
		        if (test()) {
		            iterator(function (err) {
		                if (err) {
		                    return callback(err);
		                }
		                async.whilst(test, iterator, callback);
		            });
		        }
		        else {
		            callback();
		        }
		    };
		
		    async.doWhilst = function (iterator, test, callback) {
		        iterator(function (err) {
		            if (err) {
		                return callback(err);
		            }
		            if (test()) {
		                async.doWhilst(iterator, test, callback);
		            }
		            else {
		                callback();
		            }
		        });
		    };
		
		    async.until = function (test, iterator, callback) {
		        if (!test()) {
		            iterator(function (err) {
		                if (err) {
		                    return callback(err);
		                }
		                async.until(test, iterator, callback);
		            });
		        }
		        else {
		            callback();
		        }
		    };
		
		    async.doUntil = function (iterator, test, callback) {
		        iterator(function (err) {
		            if (err) {
		                return callback(err);
		            }
		            if (!test()) {
		                async.doUntil(iterator, test, callback);
		            }
		            else {
		                callback();
		            }
		        });
		    };
		
		    async.queue = function (worker, concurrency) {
		        if (concurrency === undefined) {
		            concurrency = 1;
		        }
		        function _insert(q, data, pos, callback) {
		          if(data.constructor !== Array) {
		              data = [data];
		          }
		          _each(data, function(task) {
		              var item = {
		                  data: task,
		                  callback: typeof callback === 'function' ? callback : null
		              };
		
		              if (pos) {
		                q.tasks.unshift(item);
		              } else {
		                q.tasks.push(item);
		              }
		
		              if (q.saturated && q.tasks.length === concurrency) {
		                  q.saturated();
		              }
		              async.setImmediate(q.process);
		          });
		        }
		
		        var workers = 0;
		        var q = {
		            tasks: [],
		            concurrency: concurrency,
		            saturated: null,
		            empty: null,
		            drain: null,
		            push: function (data, callback) {
		              _insert(q, data, false, callback);
		            },
		            unshift: function (data, callback) {
		              _insert(q, data, true, callback);
		            },
		            process: function () {
		                if (workers < q.concurrency && q.tasks.length) {
		                    var task = q.tasks.shift();
		                    if (q.empty && q.tasks.length === 0) {
		                        q.empty();
		                    }
		                    workers += 1;
		                    var next = function () {
		                        workers -= 1;
		                        if (task.callback) {
		                            task.callback.apply(task, arguments);
		                        }
		                        if (q.drain && q.tasks.length + workers === 0) {
		                            q.drain();
		                        }
		                        q.process();
		                    };
		                    var cb = only_once(next);
		                    worker(task.data, cb);
		                }
		            },
		            length: function () {
		                return q.tasks.length;
		            },
		            running: function () {
		                return workers;
		            }
		        };
		        return q;
		    };
		
		    async.cargo = function (worker, payload) {
		        var working     = false,
		            tasks       = [];
		
		        var cargo = {
		            tasks: tasks,
		            payload: payload,
		            saturated: null,
		            empty: null,
		            drain: null,
		            push: function (data, callback) {
		                if(data.constructor !== Array) {
		                    data = [data];
		                }
		                _each(data, function(task) {
		                    tasks.push({
		                        data: task,
		                        callback: typeof callback === 'function' ? callback : null
		                    });
		                    if (cargo.saturated && tasks.length === payload) {
		                        cargo.saturated();
		                    }
		                });
		                async.setImmediate(cargo.process);
		            },
		            process: function process() {
		                if (working) return;
		                if (tasks.length === 0) {
		                    if(cargo.drain) cargo.drain();
		                    return;
		                }
		
		                var ts = typeof payload === 'number'
		                            ? tasks.splice(0, payload)
		                            : tasks.splice(0);
		
		                var ds = _map(ts, function (task) {
		                    return task.data;
		                });
		
		                if(cargo.empty) cargo.empty();
		                working = true;
		                worker(ds, function () {
		                    working = false;
		
		                    var args = arguments;
		                    _each(ts, function (data) {
		                        if (data.callback) {
		                            data.callback.apply(null, args);
		                        }
		                    });
		
		                    process();
		                });
		            },
		            length: function () {
		                return tasks.length;
		            },
		            running: function () {
		                return working;
		            }
		        };
		        return cargo;
		    };
		
		    var _console_fn = function (name) {
		        return function (fn) {
		            var args = Array.prototype.slice.call(arguments, 1);
		            fn.apply(null, args.concat([function (err) {
		                var args = Array.prototype.slice.call(arguments, 1);
		                if (typeof console !== 'undefined') {
		                    if (err) {
		                        if (console.error) {
		                            console.error(err);
		                        }
		                    }
		                    else if (console[name]) {
		                        _each(args, function (x) {
		                            console[name](x);
		                        });
		                    }
		                }
		            }]));
		        };
		    };
		    async.log = _console_fn('log');
		    async.dir = _console_fn('dir');
		    /*async.info = _console_fn('info');
		    async.warn = _console_fn('warn');
		    async.error = _console_fn('error');*/
		
		    async.memoize = function (fn, hasher) {
		        var memo = {};
		        var queues = {};
		        hasher = hasher || function (x) {
		            return x;
		        };
		        var memoized = function () {
		            var args = Array.prototype.slice.call(arguments);
		            var callback = args.pop();
		            var key = hasher.apply(null, args);
		            if (key in memo) {
		                callback.apply(null, memo[key]);
		            }
		            else if (key in queues) {
		                queues[key].push(callback);
		            }
		            else {
		                queues[key] = [callback];
		                fn.apply(null, args.concat([function () {
		                    memo[key] = arguments;
		                    var q = queues[key];
		                    delete queues[key];
		                    for (var i = 0, l = q.length; i < l; i++) {
		                      q[i].apply(null, arguments);
		                    }
		                }]));
		            }
		        };
		        memoized.memo = memo;
		        memoized.unmemoized = fn;
		        return memoized;
		    };
		
		    async.unmemoize = function (fn) {
		      return function () {
		        return (fn.unmemoized || fn).apply(null, arguments);
		      };
		    };
		
		    async.times = function (count, iterator, callback) {
		        var counter = [];
		        for (var i = 0; i < count; i++) {
		            counter.push(i);
		        }
		        return async.map(counter, iterator, callback);
		    };
		
		    async.timesSeries = function (count, iterator, callback) {
		        var counter = [];
		        for (var i = 0; i < count; i++) {
		            counter.push(i);
		        }
		        return async.mapSeries(counter, iterator, callback);
		    };
		
		    async.compose = function (/* functions... */) {
		        var fns = Array.prototype.reverse.call(arguments);
		        return function () {
		            var that = this;
		            var args = Array.prototype.slice.call(arguments);
		            var callback = args.pop();
		            async.reduce(fns, args, function (newargs, fn, cb) {
		                fn.apply(that, newargs.concat([function () {
		                    var err = arguments[0];
		                    var nextargs = Array.prototype.slice.call(arguments, 1);
		                    cb(err, nextargs);
		                }]))
		            },
		            function (err, results) {
		                callback.apply(that, [err].concat(results));
		            });
		        };
		    };
		
		    var _applyEach = function (eachfn, fns /*args...*/) {
		        var go = function () {
		            var that = this;
		            var args = Array.prototype.slice.call(arguments);
		            var callback = args.pop();
		            return eachfn(fns, function (fn, cb) {
		                fn.apply(that, args.concat([cb]));
		            },
		            callback);
		        };
		        if (arguments.length > 2) {
		            var args = Array.prototype.slice.call(arguments, 2);
		            return go.apply(this, args);
		        }
		        else {
		            return go;
		        }
		    };
		    async.applyEach = doParallel(_applyEach);
		    async.applyEachSeries = doSeries(_applyEach);
		
		    async.forever = function (fn, callback) {
		        function next(err) {
		            if (err) {
		                if (callback) {
		                    return callback(err);
		                }
		                throw err;
		            }
		            fn(next);
		        }
		        next();
		    };
		
		    // AMD / RequireJS
		    if (typeof define !== 'undefined' && define.amd) {
		        define([], function () {
		            return async;
		        });
		    }
		    // Node.js
		    else if (typeof module !== 'undefined' && module.exports) {
		        module.exports = async;
		    }
		    // included directly via <script> tag
		    else {
		        root.async = async;
		    }
		
		}());
		
	
	}, 'operator-compare/lib/Compare.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'operator-compare/lib/Compare.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'operator-compare/lib/Compare.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'operator-compare/lib/Compare.js';
		var __dirname = 'operator-compare/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'operator-compare/lib/Compare.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  module.exports = function(left, operator, right) {
		    switch (operator) {
		      case '>':
		        return left > right;
		      case '>=':
		        return left >= right;
		      case '<':
		        return left < right;
		      case '<=':
		        return left <= right;
		      case '=':
		      case '==':
		        return left === right;
		      case '!':
		      case '!=':
		      case '<>':
		        return left !== right;
		      default:
		        throw new Error('Unknown operator ' + operator + '.', '^.');
		    }
		  };
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/BrowserLocalStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/BrowserLocalStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/BrowserLocalStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/BrowserLocalStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/BrowserLocalStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var BrowserLocalStorage, Cache, Storage,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  Cache = require('../Cache');
		
		  BrowserLocalStorage = (function(_super) {
		    __extends(BrowserLocalStorage, _super);
		
		    BrowserLocalStorage.TEST_VALUE = '__--cache-storage--__';
		
		    BrowserLocalStorage.prototype.allData = null;
		
		    BrowserLocalStorage.prototype.data = null;
		
		    BrowserLocalStorage.prototype.meta = null;
		
		    function BrowserLocalStorage() {
		      if (!BrowserLocalStorage.isSupported()) {
		        throw new Error('Cache storage: Local storage is not supported');
		      }
		    }
		
		    BrowserLocalStorage.isSupported = function() {
		      var e;
		      try {
		        localStorage.setItem(BrowserLocalStorage.TEST_VALUE, BrowserLocalStorage.TEST_VALUE);
		        localStorage.getItem(BrowserLocalStorage.TEST_VALUE);
		        return true;
		      } catch (_error) {
		        e = _error;
		        return false;
		      }
		    };
		
		    BrowserLocalStorage.prototype.getName = function() {
		      return '__' + this.cache.namespace;
		    };
		
		    BrowserLocalStorage.prototype.loadData = function() {
		      var data;
		      if (this.allData === null) {
		        data = localStorage.getItem(this.getName());
		        if (data === null) {
		          this.allData = {
		            data: {},
		            meta: {}
		          };
		        } else {
		          this.allData = JSON.parse(data);
		        }
		      }
		      return this.allData;
		    };
		
		    BrowserLocalStorage.prototype.getData = function() {
		      if (this.data === null) {
		        this.data = this.loadData().data;
		      }
		      return this.data;
		    };
		
		    BrowserLocalStorage.prototype.getMeta = function() {
		      if (this.meta === null) {
		        this.meta = this.loadData().meta;
		      }
		      return this.meta;
		    };
		
		    BrowserLocalStorage.prototype.writeData = function(data, meta) {
		      this.data = data;
		      this.meta = meta;
		      localStorage.setItem(this.getName(), JSON.stringify({
		        data: this.data,
		        meta: this.meta
		      }));
		      return this;
		    };
		
		    return BrowserLocalStorage;
		
		  })(Storage);
		
		  module.exports = BrowserLocalStorage;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/DevNullStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/DevNullStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/DevNullStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/DevNullStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/DevNullStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var DevNullStorage, Storage, _ref,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  DevNullStorage = (function(_super) {
		    __extends(DevNullStorage, _super);
		
		    function DevNullStorage() {
		      _ref = DevNullStorage.__super__.constructor.apply(this, arguments);
		      return _ref;
		    }
		
		    DevNullStorage.prototype.getData = function() {
		      return {};
		    };
		
		    DevNullStorage.prototype.getMeta = function() {
		      return {};
		    };
		
		    DevNullStorage.prototype.writeData = function(data, meta) {
		      return this;
		    };
		
		    DevNullStorage.prototype.read = function(key) {
		      return null;
		    };
		
		    DevNullStorage.prototype.write = function(key, data, dependencies) {
		      if (dependencies == null) {
		        dependencies = {};
		      }
		      return this;
		    };
		
		    DevNullStorage.prototype.remove = function(key) {
		      return this;
		    };
		
		    return DevNullStorage;
		
		  })(Storage);
		
		  module.exports = DevNullStorage;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/FileStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/FileStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/FileStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/FileStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/FileStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Cache, FileStorage, Storage, fs, path,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  Cache = require('../Cache');
		
		  fs = null;
		
		  path = null;
		
		  FileStorage = (function(_super) {
		    __extends(FileStorage, _super);
		
		    FileStorage.prototype.directory = null;
		
		    FileStorage.prototype.allData = null;
		
		    FileStorage.prototype.data = null;
		
		    FileStorage.prototype.meta = null;
		
		    function FileStorage(directory) {
		      this.directory = directory;
		      if (typeof window !== 'undefined') {
		        throw new Error('FileStorage: Can not use this storage in browser');
		      }
		      fs = require('fs');
		      path = require('path');
		      this.directory = path.resolve(this.directory);
		      if (!fs.existsSync(this.directory)) {
		        throw new Error('FileStorage: directory ' + this.directory + ' does not exists');
		      }
		      if (!fs.statSync(this.directory).isDirectory()) {
		        throw new Error('FileStorage: path ' + this.directory + ' must be directory');
		      }
		    }
		
		    FileStorage.prototype.getFileName = function() {
		      return this.directory + '/__' + this.cache.namespace + '.json';
		    };
		
		    FileStorage.prototype.loadData = function() {
		      var file;
		      if (this.allData === null) {
		        file = this.getFileName();
		        if (fs.existsSync(file)) {
		          this.allData = JSON.parse(fs.readFileSync(file, {
		            encoding: 'utf8'
		          }));
		        } else {
		          this.allData = {
		            data: {},
		            meta: {}
		          };
		        }
		      }
		      return this.allData;
		    };
		
		    FileStorage.prototype.getData = function() {
		      if (this.data === null) {
		        this.data = this.loadData().data;
		      }
		      return this.data;
		    };
		
		    FileStorage.prototype.getMeta = function() {
		      if (this.meta === null) {
		        this.meta = this.loadData().meta;
		      }
		      return this.meta;
		    };
		
		    FileStorage.prototype.writeData = function(data, meta) {
		      var file;
		      this.data = data;
		      this.meta = meta;
		      file = this.getFileName();
		      fs.writeFileSync(file, JSON.stringify({
		        data: this.data,
		        meta: this.meta
		      }));
		      return this;
		    };
		
		    return FileStorage;
		
		  })(Storage);
		
		  module.exports = FileStorage;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/MemoryStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/MemoryStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/MemoryStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/MemoryStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/MemoryStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var MemoryStorage, Storage, _ref,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  MemoryStorage = (function(_super) {
		    __extends(MemoryStorage, _super);
		
		    function MemoryStorage() {
		      _ref = MemoryStorage.__super__.constructor.apply(this, arguments);
		      return _ref;
		    }
		
		    MemoryStorage.prototype.data = null;
		
		    MemoryStorage.prototype.meta = null;
		
		    MemoryStorage.prototype.getData = function() {
		      if (this.data === null) {
		        this.data = {};
		      }
		      return this.data;
		    };
		
		    MemoryStorage.prototype.getMeta = function() {
		      if (this.meta === null) {
		        this.meta = {};
		      }
		      return this.meta;
		    };
		
		    MemoryStorage.prototype.writeData = function(data, meta) {
		      this.data = data;
		      this.meta = meta;
		      return this;
		    };
		
		    return MemoryStorage;
		
		  })(Storage);
		
		  module.exports = MemoryStorage;
		
		}).call(this);
		
	
	}, '/lib/Api.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/Api.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Api.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/Api.js';
		var __dirname = '/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Api.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Api, Finder, Loader, Translator, callsite, fs, path;
		
		  if (typeof window !== 'undefined') {
		    throw new Error('Translator API can not be used in browser.');
		  }
		
		  Loader = require('./Loaders/Loader');
		
		  Translator = require('./Translator');
		
		  fs = require('fs');
		
		  path = require('path');
		
		  callsite = require('callsite');
		
		  Finder = require('fs-finder');
		
		  Api = (function() {
		    Api.prototype.configPath = null;
		
		    Api.prototype.config = null;
		
		    Api.prototype.translator = null;
		
		    Api.prototype.loader = null;
		
		    Api.prototype.language = 'en';
		
		    Api.prototype.languages = null;
		
		    function Api(configPath, language) {
		      var stack;
		      this.configPath = configPath;
		      this.language = language != null ? language : this.language;
		      if (this.configPath.charAt(0) === '.') {
		        stack = callsite();
		        this.configPath = path.join(path.dirname(stack[1].getFileName()), this.configPath);
		      }
		      this.configPath = path.normalize(this.configPath);
		      this.config = JSON.parse(fs.readFileSync(this.configPath, {
		        encoding: 'utf8'
		      }));
		      if (typeof this.config.path === 'undefined') {
		        this.config.path = '.';
		      }
		      if (typeof this.config.loader === 'undefined') {
		        this.config.loader = 'Json';
		      }
		      if (typeof this.config.languages === 'undefined') {
		        this.config.languages = [];
		      }
		      if (this.config.path.charAt(0) === '.') {
		        this.config.path = path.join(path.dirname(this.configPath), this.config.path);
		      }
		      this.translator = new Translator(this.configPath);
		      this.loader = new (require('./Loaders/' + this.config.loader))(this.config.path);
		    }
		
		    Api.prototype.release = function() {
		      return this.languages = null;
		    };
		
		    Api.prototype.getLanguages = function() {
		      var file, language, _i, _j, _len, _len1, _ref, _ref1;
		      if (this.languages === null) {
		        this.languages = [];
		        _ref = Finder.from(this.config.path).findFiles('.*.json');
		        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		          file = _ref[_i];
		          language = path.basename(file).split('.')[0];
		          if (this.languages.indexOf(language) === -1) {
		            this.languages.push(language);
		          }
		        }
		        _ref1 = this.config.languages;
		        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
		          language = _ref1[_j];
		          if (this.languages.indexOf(language) === -1) {
		            this.languages.push(language);
		          }
		        }
		      }
		      return this.languages;
		    };
		
		    Api.prototype.hasLanguage = function(language) {
		      return this.getLanguages().indexOf(language) !== -1;
		    };
		
		    Api.prototype.addLanguage = function(language) {
		      if (!this.hasLanguage(language)) {
		        this.languages.push(language);
		        this.config.languages.push(language);
		        return fs.writeFileSync(this.configPath, JSON.stringify(this.config, null, '\t'));
		      }
		    };
		
		    Api.prototype.getDictionaries = function() {
		      var dir, file, name, result, _i, _len, _ref;
		      result = [];
		      _ref = Finder.from(this.config.path).findFiles(this.language + '.*.json');
		      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		        file = _ref[_i];
		        name = path.relative(this.config.path, file);
		        dir = path.dirname(name);
		        name = path.basename(name, path.extname(name)).replace(new RegExp('^' + this.language + '\.'), '');
		        result.push(path.join(dir, name));
		      }
		      return this.createTree(result);
		    };
		
		    Api.prototype.addDictionary = function(dictionary) {
		      var info, _path;
		      info = this.translator.getMessageInfo(dictionary + '.buf');
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      if (fs.existsSync(_path)) {
		        throw new Error("Dictionary '" + dictionary + "' already exists.");
		      }
		      return fs.writeFileSync(_path, '{}');
		    };
		
		    Api.prototype.renameDictionary = function(oldName, newName) {
		      var info, newInfo, newPath, _path;
		      info = this.translator.getMessageInfo(oldName + '.buf');
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      if (!fs.existsSync(_path)) {
		        throw new Error("Dictionary '" + oldName + "' does not exists.");
		      }
		      newInfo = this.translator.getMessageInfo(newName + '.buf');
		      newPath = this.loader.getFileSystemPath(newInfo.path, newInfo.category, this.language);
		      if (fs.existsSync(newPath)) {
		        throw new Error("Dictionary '" + newName + "' already exists.");
		      }
		      return fs.renameSync(_path, newPath);
		    };
		
		    Api.prototype.removeDictionary = function(dictionary) {
		      var info, _path;
		      info = this.translator.getMessageInfo(dictionary + '.buf');
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      if (!fs.existsSync(_path)) {
		        throw new Error("Dictionary '" + dictionary + "' does not exists.");
		      }
		      return fs.unlinkSync(_path);
		    };
		
		    Api.prototype.getTranslations = function(dictionary) {
		      var files, info, _path;
		      info = this.translator.getMessageInfo(dictionary + '.buf');
		      files = this.translator.loadCategory(info.path, info.category, this.language);
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      delete require.cache[_path];
		      return files;
		    };
		
		    Api.prototype.addTranslation = function(dictionary, name, translation) {
		      var data, info, _path;
		      info = this.translator.getMessageInfo(dictionary + '.' + name);
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      data = this.getTranslations(dictionary);
		      if (typeof data[info.name] !== 'undefined') {
		        throw new Error("Translation '" + name + "' already exists in '" + dictionary + "' dictionary.");
		      }
		      data[info.name] = translation;
		      data = JSON.stringify(data, null, '\t');
		      return fs.writeFileSync(_path, data);
		    };
		
		    Api.prototype.editTranslation = function(dictionary, name, translation) {
		      var data, info, _path;
		      info = this.translator.getMessageInfo(dictionary + '.' + name);
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      data = this.getTranslations(dictionary);
		      if (typeof data[info.name] === 'undefined') {
		        throw new Error("Translation '" + name + "' does not exists in '" + dictionary + "' dictionary.");
		      }
		      data[info.name] = translation;
		      data = JSON.stringify(data, null, '\t');
		      return fs.writeFileSync(_path, data);
		    };
		
		    Api.prototype.renameTranslation = function(dictionary, oldName, newName) {
		      var data, info, _path;
		      info = this.translator.getMessageInfo(dictionary + '.' + oldName);
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      data = this.getTranslations(dictionary);
		      if (typeof data[info.name] === 'undefined') {
		        throw new Error("Translation '" + oldName + "' does not exists in '" + dictionary + "' dictionary.");
		      }
		      if (typeof data[newName] !== 'undefined') {
		        throw new Error("Translation '" + newName + "' already exists in '" + dictionary + "' dictionary.");
		      }
		      data[newName] = data[oldName];
		      delete data[oldName];
		      data = JSON.stringify(data, null, '\t');
		      return fs.writeFileSync(_path, data);
		    };
		
		    Api.prototype.removeTranslation = function(dictionary, name) {
		      var data, info, _path;
		      info = this.translator.getMessageInfo(dictionary + '.' + name);
		      _path = this.loader.getFileSystemPath(info.path, info.category, this.language);
		      data = this.getTranslations(dictionary);
		      delete data[name];
		      data = JSON.stringify(data, null, '\t');
		      return fs.writeFileSync(_path, data);
		    };
		
		    Api.prototype.createTree = function(paths) {
		      var buf, count, part, parts, result, _i, _j, _len, _len1, _path;
		      result = {};
		      count = 0;
		      for (_i = 0, _len = paths.length; _i < _len; _i++) {
		        _path = paths[_i];
		        parts = _path.split(path.sep);
		        buf = result;
		        for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
		          part = parts[_j];
		          if (typeof buf[part] === 'undefined') {
		            buf[part] = {};
		          }
		          buf = buf[part];
		        }
		        count++;
		      }
		      return result;
		    };
		
		    return Api;
		
		  })();
		
		  module.exports = Api;
		
		}).call(this);
		
	
	}, '/test/browser/tests/Translator.coffee': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/browser/tests/Translator.coffee');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Translator.coffee';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/browser/tests/Translator.coffee';
		var __dirname = '/test/browser/tests';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Translator.coffee'], env: {}};
	
		/** code **/
		(function() {
		  var BrowserLocalStorage, Cache, Translator, dir, translator;
		
		  Translator = require('/lib/Translator');
		
		  BrowserLocalStorage = require('cache-storage/Storage/BrowserLocalStorage');
		
		  Cache = require('cache-storage');
		
		  dir = '/test/data';
		
		  translator = null;
		
		  describe('Translator', function() {
		    beforeEach(function() {
		      translator = new Translator(dir);
		      return translator.language = 'en';
		    });
		    afterEach(function() {
		      return translator = null;
		    });
		    describe('#constructor()', function() {
		      it('should contain some plural forms', function() {
		        return expect(translator.plurals).not.to.be.eql({});
		      });
		      return it('should create translator from path in config file', function() {
		        translator = new Translator(dir + '/config.json');
		        return expect(translator.loader.directory).to.be.equal(dir);
		      });
		    });
		    describe('#normalizeTranslations()', function() {
		      it('should return normalized object with dictionary', function() {
		        return expect(translator.normalizeTranslations({
		          car: 'car',
		          bus: ['bus']
		        })).to.be.eql({
		          car: ['car'],
		          bus: ['bus']
		        });
		      });
		      it('should return normalized translations without comments', function() {
		        return expect(translator.normalizeTranslations({
		          one: ['# hello #', 'car', '# house #', 'something']
		        })).to.be.eql({
		          one: ['car', 'something']
		        });
		      });
		      it('should return normalized translations for list with comments', function() {
		        return expect(translator.normalizeTranslations({
		          one: [['first'], '# comment #', ['second', '# comment #'], ['third']]
		        })).to.be.eql({
		          one: [['first'], ['second'], ['third']]
		        });
		      });
		      return it('should return normalized translations for list with new syntax', function() {
		        return expect(translator.normalizeTranslations({
		          '-- list': ['first', 'second', 'third']
		        })).to.be.eql({
		          list: [['first'], ['second'], ['third']]
		        });
		      });
		    });
		    describe('#getMessageInfo()', function() {
		      return it('should return information about dictionary from message to translate', function() {
		        return expect(translator.getMessageInfo('web.pages.homepage.promo.title')).to.be.eql({
		          path: 'web/pages/homepage',
		          category: 'promo',
		          name: 'title'
		        });
		      });
		    });
		    describe('#loadCategory()', function() {
		      it('should load parsed dictionary', function() {
		        return expect(translator.loadCategory('web/pages/homepage', 'simple')).to.be.eql({
		          title: ['Title of promo box']
		        });
		      });
		      it('should load dictionary for different language', function() {
		        return expect(translator.loadCategory('web/pages/homepage', 'simple', 'cs')).to.be.eql({
		          title: ['Titulek promo boxu']
		        });
		      });
		      return it('should return empty object if dictionary does not exists', function() {
		        return expect(translator.loadCategory('some/unknown', 'translation')).to.be.eql({});
		      });
		    });
		    describe('#findTranslation()', function() {
		      it('should return english translations from dictionary', function() {
		        return expect(translator.findTranslation('web.pages.homepage.promo.title')).to.be.eql(['Title of promo box']);
		      });
		      it('should return translations from dictionary for different language', function() {
		        return expect(translator.findTranslation('web.pages.homepage.simple.title', 'cs')).to.be.eql(['Titulek promo boxu']);
		      });
		      it('should return null when translation does not exists', function() {
		        return expect(translator.findTranslation('some.unknown.translation')).to.be["null"];
		      });
		      return it('should return null when translation does not exists for given language', function() {
		        return expect(translator.findTranslation('some.unknown.translation', 'cs')).to.be["null"];
		      });
		    });
		    describe('#hasTranslation()', function() {
		      it('should return true when translation exists', function() {
		        return expect(translator.hasTranslation('web.pages.homepage.promo.title')).to.be["true"];
		      });
		      it('should return true when translation exists for different language', function() {
		        return expect(translator.hasTranslation('web.pages.homepage.simple.title', 'cs')).to.be["true"];
		      });
		      it('should return false when translation does not exists', function() {
		        return expect(translator.hasTranslation('some.unknown.translation')).to.be["false"];
		      });
		      return it('should return false when translation does not exists for different language', function() {
		        return expect(translator.hasTranslation('some.unknown.translation', 'cs')).to.be["false"];
		      });
		    });
		    describe('#pluralize()', function() {
		      it('should return right version of translation(s) by count', function() {
		        var cars, fruits;
		        cars = ['1 car', '%count% cars'];
		        expect(translator.pluralize('car', cars, 1)).to.be.equal('1 car');
		        expect(translator.pluralize('car', cars, 4)).to.be.equal('%count% cars');
		        fruits = [['1 apple', '%count% apples'], ['1 orange', '%count% oranges']];
		        expect(translator.pluralize('list', fruits, 1)).to.be.eql(['1 apple', '1 orange']);
		        return expect(translator.pluralize('list', fruits, 4)).to.be.eql(['%count% apples', '%count% oranges']);
		      });
		      return it('should return right version of translation(s) by count for different language', function() {
		        var cars, fruits;
		        cars = ['1 auto', '%count% auta', '%count% aut'];
		        expect(translator.pluralize('car', cars, 1, 'cs')).to.be.equal('1 auto');
		        expect(translator.pluralize('car', cars, 4, 'cs')).to.be.equal('%count% auta');
		        fruits = [['1 jablko', '%count% jablka', '%count% jablek'], ['1 pomeran', '%count% pomerane', '%count% pomeran']];
		        expect(translator.pluralize('list', fruits, 1)).to.be.eql(['1 jablko', '1 pomeran']);
		        return expect(translator.pluralize('list', fruits, 4)).to.be.eql(['%count% jablka', '%count% pomerane']);
		      });
		    });
		    describe('#prepareTranslation()', function() {
		      return it('should return expanded translation with arguments', function() {
		        translator.addReplacement('item', 'car');
		        return expect(translator.prepareTranslation('%item% has got %count% %append%.', {
		          count: 5,
		          append: 'things'
		        })).to.be.equal('car has got 5 things.');
		      });
		    });
		    describe('#applyReplacements()', function() {
		      return it('should add replacements to text', function() {
		        return expect(translator.applyReplacements('%one% %two% %three%', {
		          one: 1,
		          two: 2,
		          three: 3
		        })).to.be.equal('1 2 3');
		      });
		    });
		    describe('#translate()', function() {
		      it('should return translated text from dictionary', function() {
		        return expect(translator.translate('web.pages.homepage.promo.title')).to.be.equal('Title of promo box');
		      });
		      it('should return original text if text is eclosed in \':\'', function() {
		        return expect(translator.translate(':do.not.translate.me:')).to.be.equal('do.not.translate.me');
		      });
		      it('should return array of list', function() {
		        return expect(translator.translate('web.pages.homepage.promo.list')).to.be.eql(['1st item', '2nd item', '3rd item', '4th item', '5th item']);
		      });
		      it('should return translation for plural form', function() {
		        return expect(translator.translate('web.pages.homepage.promo.cars', 3)).to.be.equal('3 cars');
		      });
		      it('should return translation of list for plural form', function() {
		        return expect(translator.translate('web.pages.homepage.promo.fruits', 3)).to.be.eql(['3 bananas', '3 citrons', '3 oranges']);
		      });
		      it('should return translation with replacement in message', function() {
		        translator.addReplacement('one', 1);
		        translator.addReplacement('dictionary', 'promo');
		        return expect(translator.translate('web.pages.homepage.%dictionary%.%name%', null, {
		          two: 2,
		          name: 'advanced'
		        })).to.be.equal('1 2');
		      });
		      it('should translate with parameters in place of count argument', function() {
		        return expect(translator.translate('web.pages.homepage.promo.advanced', {
		          one: '1',
		          two: 2
		        })).to.be.equal('1 2');
		      });
		      it('should translate one item from list in translate method', function() {
		        expect(translator.translate('web.pages.homepage.promo.newList[0]')).to.be.equal('first');
		        expect(translator.translate('web.pages.homepage.promo.newList[1]')).to.be.equal('second');
		        return expect(translator.translate('web.pages.homepage.promo.newList[2]')).to.be.equal('third');
		      });
		      it('should throw an error when translating one item from non-list', function() {
		        return expect(function() {
		          return translator.translate('web.pages.homepage.promo.title[5]');
		        })["throw"](Error);
		      });
		      it('should throw an error when translating one item which does not exists', function() {
		        return expect(function() {
		          return translator.translate('web.pages.homepage.promo.newList[5]');
		        })["throw"](Error);
		      });
		      it('should return translated text from dictionary for different language', function() {
		        return expect(translator.translate('cs|web.pages.homepage.simple.title')).to.be.equal('Titulek promo boxu');
		      });
		      return it('should return original text if text is eclosed in \':\'', function() {
		        return expect(translator.translate(':cs|do.not.translate.me:')).to.be.equal('do.not.translate.me');
		      });
		    });
		    describe('#translatePairs()', function() {
		      it('should throw an error if message to translate are not arrays', function() {
		        return expect(function() {
		          return translator.translatePairs('web.pages.homepage.promo', 'title', 'list');
		        })["throw"](Error);
		      });
		      it('should throw an error if keys and values have not got the same length', function() {
		        return expect(function() {
		          return translator.translatePairs('web.pages.homepage.promo', 'list', 'keys');
		        })["throw"](Error);
		      });
		      return it('should return object with keys and values translations', function() {
		        return expect(translator.translatePairs('web.pages.homepage.promo', 'keys', 'values')).to.be.eql({
		          '1st title': '1st text',
		          '2nd title': '2nd text',
		          '3rd title': '3rd text',
		          '4th title': '4th text'
		        });
		      });
		    });
		    describe('#translateMap()', function() {
		      it('should throw an error if object is not array or object', function() {
		        return expect(function() {
		          return translator.translateMap(new Date);
		        }).to["throw"](Error);
		      });
		      it('should translate array', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.title', 'web.pages.homepage.promo.info'])).to.be.eql(['Title of promo box', 'Some info text']);
		      });
		      it('should translate object', function() {
		        var t;
		        t = {
		          title: 'web.pages.homepage.promo.title',
		          info: 'web.pages.homepage.promo.info'
		        };
		        return expect(translator.translateMap(t)).to.be.eql({
		          title: 'Title of promo box',
		          info: 'Some info text'
		        });
		      });
		      it('should translate array with plural forms translations', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.cars', 'web.pages.homepage.promo.mobile'], 6)).to.be.eql(['6 cars', '6 mobiles']);
		      });
		      it('should translate array with arguments', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.advanced'], {
		          one: 1,
		          two: 2
		        })).to.be.eql(['1 2']);
		      });
		      it('should translate array with base path', function() {
		        return expect(translator.translateMap(['title', 'info'], 'web.pages.homepage.promo')).to.be.eql(['Title of promo box', 'Some info text']);
		      });
		      return it('should translate array with list', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.fruits'], 4)).to.be.eql([['4 bananas', '4 citrons', '4 oranges']]);
		      });
		    });
		    describe('#setCacheStorage()', function() {
		      it('should throw an exception if storage is not the right type', function() {
		        return expect(function() {
		          return translator.setCacheStorage(new Array);
		        })["throw"](Error);
		      });
		      return it('should create cache instance', function() {
		        translator.setCacheStorage(new BrowserLocalStorage);
		        return expect(translator.cache).to.be.an["instanceof"](Cache);
		      });
		    });
		    return describe('#expand()', function() {
		      it('should expand base translate method', function() {
		        var main;
		        main = translator.expand({});
		        return expect(main._('web.pages.homepage.promo.title')).to.be.equal('Title of promo box');
		      });
		      it('should expand translatePairs method', function() {
		        var main;
		        main = translator.expand({});
		        return expect(main._p('web.pages.homepage.promo', 'keys', 'values')).to.be.eql({
		          '1st title': '1st text',
		          '2nd title': '2nd text',
		          '3rd title': '3rd text',
		          '4th title': '4th text'
		        });
		      });
		      return it('should expand translateMap method', function() {
		        var main;
		        main = translator.expand({});
		        return expect(main._m(['web.pages.homepage.promo.title', 'web.pages.homepage.promo.info'])).to.be.eql(['Title of promo box', 'Some info text']);
		      });
		    });
		  });
		
		}).call(this);
		
	
	}, '/test/data/config.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/config.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/config.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/config.json';
		var __dirname = '/test/data';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/config.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"path": ".",
			"languages": [
				"sk"
			]
		}
		}).call(this);
		
	
	}, '/test/data/en.first.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/en.first.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/en.first.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/en.first.json';
		var __dirname = '/test/data';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/en.first.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"test": "hello"
		}
		}).call(this);
		
	
	}, '/test/data/web/pages/homepage/cs.simple.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/web/pages/homepage/cs.simple.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/web/pages/homepage/cs.simple.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/web/pages/homepage/cs.simple.json';
		var __dirname = '/test/data/web/pages/homepage';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/web/pages/homepage/cs.simple.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"title": "Titulek promo boxu"
		}
		}).call(this);
		
	
	}, '/test/data/web/pages/homepage/en.cached.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/web/pages/homepage/en.cached.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/web/pages/homepage/en.cached.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/web/pages/homepage/en.cached.json';
		var __dirname = '/test/data/web/pages/homepage';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/web/pages/homepage/en.cached.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {"variable": "1"}
		}).call(this);
		
	
	}, '/test/data/web/pages/homepage/en.promo.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/web/pages/homepage/en.promo.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/web/pages/homepage/en.promo.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/web/pages/homepage/en.promo.json';
		var __dirname = '/test/data/web/pages/homepage';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/web/pages/homepage/en.promo.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"title": "Title of promo box",
			"info": "Some info text",
			"list": [
				["1st item"],
				["2nd item"],
				["3rd item"],
				["4th item"],
				["5th item"]
			],
			"cars": [
				"1 car",
				"%count% cars"
			],
			"mobile": [
				"1 mobile",
				"%count% mobiles"
			],
			"fruits": [
				"# this is some random comment #",
				[
					"1 banana",
					"%count% bananas"
				],
				[
					"1 citron",
					"# another comment #",
					"%count% citrons"
				],
				[
					"1 orange",
					"%count% oranges"
				]
			],
			"keys": [
				["1st title"],
				["2nd title"],
				["3rd title"],
				["4th title"]
			],
			"values": [
				["1st text"],
				["2nd text"],
				["3rd text"],
				["4th text"]
			],
			"advanced": "%one% %two%",
			"-- newList": [
				"first",
				"second",
				"third"
			]
		}
		}).call(this);
		
	
	}, '/test/data/web/pages/homepage/en.simple.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/web/pages/homepage/en.simple.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/web/pages/homepage/en.simple.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/web/pages/homepage/en.simple.json';
		var __dirname = '/test/data/web/pages/homepage';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/web/pages/homepage/en.simple.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"title": "Title of promo box"
		}
		}).call(this);
		
	
	}, 'cache-storage/Storage/BrowserLocalStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/BrowserLocalStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/BrowserLocalStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/BrowserLocalStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/BrowserLocalStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/BrowserLocalStorage');
	
	}, 'cache-storage/Storage/DevNullStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/DevNullStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/DevNullStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/DevNullStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/DevNullStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/DevNullStorage');
	
	}, 'cache-storage/Storage/FileStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/FileStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/FileStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/FileStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/FileStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/FileStorage');
	
	}, 'cache-storage/Storage/MemoryStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/MemoryStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/MemoryStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/MemoryStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/MemoryStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/MemoryStorage');
	
	}, 'cache-storage': function(exports, module) { module.exports = __r__c__.require('cache-storage/lib/Cache.js'); }
	, 'moment': function(exports, module) { module.exports = __r__c__.require('moment/moment.js'); }
	, 'normalize-arguments': function(exports, module) { module.exports = __r__c__.require('normalize-arguments/lib/Args.js'); }
	, 'callsite': function(exports, module) { module.exports = __r__c__.require('callsite/index.js'); }
	, 'fs-finder': function(exports, module) { module.exports = __r__c__.require('fs-finder/lib/Finder.js'); }
	, 'escape-regexp': function(exports, module) { module.exports = __r__c__.require('escape-regexp/index.js'); }
	, 'q': function(exports, module) { module.exports = __r__c__.require('q/q.js'); }
	, 'async': function(exports, module) { module.exports = __r__c__.require('async/lib/async.js'); }
	, 'operator-compare': function(exports, module) { module.exports = __r__c__.require('operator-compare/lib/Compare.js'); }
	
	});
	__r__c__.require.version = '5.6.3';
	
	window.require = __r__c__.require;
	
	/** run section **/
	
	/** /test/browser/tests/Translator **/
	__r__c__.require('/test/browser/tests/Translator');
}).call({});