(function() {
	var __r__c__ = this;
	/** Generated by SimQ **/
	/** modules **/
	
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var SUPPORTED, arrayIndexOf, cache, creating, modules, require, resolve, stats;
	
	  if (!this.require) {
	    SUPPORTED = ['js', 'json', 'ts', 'coffee', 'eco'];
	    modules = {};
	    stats = {};
	    cache = {};
	    creating = [];
	    require = function(name, parent) {
	      var fullName, m;
	      if (parent == null) {
	        parent = null;
	      }
	      fullName = resolve(name, parent);
	      if (typeof cache[fullName] === 'undefined') {
	        m = {
	          exports: {},
	          id: fullName,
	          filename: fullName,
	          loaded: false,
	          parent: null,
	          children: null
	        };
	        if (arrayIndexOf(creating, fullName) === -1) {
	          creating.push(fullName);
	          modules[fullName].apply(window, [m.exports, m]);
	          creating.splice(arrayIndexOf(creating, fullName));
	          cache[fullName] = m;
	        }
	        m.loaded = true;
	      } else {
	        m = cache[fullName];
	      }
	      if (typeof stats[fullName] === 'undefined') {
	        stats[fullName] = {
	          atime: null,
	          mtime: null,
	          ctime: null
	        };
	      }
	      stats[fullName].atime = new Date;
	      return m.exports;
	    };
	    resolve = function(name, parent) {
	      var ext, num, original, part, parts, prev, result, _i, _j, _k, _len, _len1, _len2;
	      if (parent == null) {
	        parent = null;
	      }
	      original = name;
	      if (parent !== null && name[0] === '.') {
	        num = parent.lastIndexOf('/');
	        if (num !== -1) {
	          parent = parent.substr(0, num);
	        }
	        name = parent + '/' + name;
	      }
	      parts = name.split('/');
	      result = [];
	      prev = null;
	      for (_i = 0, _len = parts.length; _i < _len; _i++) {
	        part = parts[_i];
	        if (part === '.' || part === '') {
	          continue;
	        } else if (part === '..' && prev) {
	          result.pop();
	        } else {
	          result.push(part);
	        }
	        prev = part;
	      }
	      name = result.join('/');
	      if ((original[0] === '/') || (parent !== null && parent[0] === '/' && original[0] === '.')) {
	        name = '/' + name;
	      }
	      if (typeof modules[name] !== 'undefined') {
	        return name;
	      }
	      for (_j = 0, _len1 = SUPPORTED.length; _j < _len1; _j++) {
	        ext = SUPPORTED[_j];
	        if (typeof modules[name + '.' + ext] !== 'undefined') {
	          return name + '.' + ext;
	        }
	      }
	      for (_k = 0, _len2 = SUPPORTED.length; _k < _len2; _k++) {
	        ext = SUPPORTED[_k];
	        if (typeof modules[name + '/index.' + ext] !== 'undefined') {
	          return name + '/index.' + ext;
	        }
	      }
	      throw new Error("Module " + original + " was not found.");
	    };
	    arrayIndexOf = function(array, search) {
	      var element, i, _i, _len;
	      if (typeof Array.prototype.indexOf !== 'undefined') {
	        return array.indexOf(search);
	      }
	      if (array.length === 0) {
	        return -1;
	      }
	      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
	        element = array[i];
	        if (element === search) {
	          return i;
	        }
	      }
	      return -1;
	    };
	    this.require = function(name, parent) {
	      if (parent == null) {
	        parent = null;
	      }
	      return require(name, parent);
	    };
	    this.require.simq = true;
	    this.require.version = 1;
	    this.require.resolve = function(name, parent) {
	      if (parent == null) {
	        parent = null;
	      }
	      return resolve(name, parent);
	    };
	    this.require.define = function(bundleOrName, obj) {
	      var m, name, _results;
	      if (obj == null) {
	        obj = null;
	      }
	      if (typeof bundleOrName === 'string') {
	        return modules[bundleOrName] = obj;
	      } else {
	        _results = [];
	        for (name in bundleOrName) {
	          m = bundleOrName[name];
	          _results.push(modules[name] = m);
	        }
	        return _results;
	      }
	    };
	    this.require.release = function() {
	      var name, _results;
	      _results = [];
	      for (name in cache) {
	        _results.push(delete cache[name]);
	      }
	      return _results;
	    };
	    this.require.getStats = function(name, parent) {
	      var fullName;
	      if (parent == null) {
	        parent = null;
	      }
	      fullName = resolve(name, parent);
	      if (fullName === null) {
	        throw new Error('Module ' + name + ' was not found.');
	      }
	      if (typeof stats[fullName] === 'undefined') {
	        stats[fullName] = {
	          atime: null,
	          mtime: null,
	          ctime: null
	        };
	      }
	      return stats[fullName];
	    };
	    this.require.__setStats = function(bundle) {
	      var data, name, _results;
	      _results = [];
	      for (name in bundle) {
	        data = bundle[name];
	        _results.push(stats[name] = {
	          atime: new Date(data.atime),
	          mtime: new Date(data.mtime),
	          ctime: new Date(data.ctime)
	        });
	      }
	      return _results;
	    };
	    this.require.cache = cache;
	  }
	
	  return this.require.define;
	
	}).call(this)({
	 '/lib/Loaders/Loader.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/Loaders/Loader.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Loaders/Loader.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/Loaders/Loader.js';
		var __dirname = '/lib/Loaders';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Loaders/Loader.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Loader;
		
		  Loader = (function() {
		    function Loader() {}
		
		    Loader.prototype.load = function() {
		      throw new Error('Translator loader: you have to implement method load.');
		    };
		
		    Loader.prototype.getFileSystemPath = function() {
		      throw new Error('Translator loader: you have to implement method getFileSystemPath.');
		    };
		
		    return Loader;
		
		  })();
		
		  module.exports = Loader;
		
		}).call(this);
		
	
	}, '/lib/node/path.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/node/path.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/node/path.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/node/path.js';
		var __dirname = '/lib/node';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/node/path.js'], env: {}};
	
		/** code **/
		// Taken from https://github.com/joyent/node/blob/master/lib/path.js
		
		
		
		// resolves . and .. elements in a path array with directory names there
		// must be no slashes, empty elements, or device names (c:\) in the array
		// (so also no leading and trailing slashes - it does not distinguish
		// relative and absolute paths)
		function normalizeArray(parts, allowAboveRoot) {
			// if the path tries to go above the root, `up` ends up > 0
			var up = 0;
			for (var i = parts.length - 1; i >= 0; i--) {
				var last = parts[i];
				if (last === '.') {
					parts.splice(i, 1);
				} else if (last === '..') {
					parts.splice(i, 1);
					up++;
				} else if (up) {
					parts.splice(i, 1);
					up--;
				}
			}
		
			// if the path is allowed to go above the root, restore leading ..s
			if (allowAboveRoot) {
				for (; up--; up) {
					parts.unshift('..');
				}
			}
		
			return parts;
		}
		
		var splitPathRe =
			/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
		var splitPath = function(filename) {
			return splitPathRe.exec(filename).slice(1);
		};
		
		var isBrowser = typeof window !== 'undefined';
		
		if (!isBrowser) {
			var path = require('path');
		}
		
		exports.isAbsolute = function(_path) {
			if (isBrowser) {
				return _path.charAt(0) === '/';
			} else {
				return path.isAbsolute.call({}, _path);
			}
		};
		
		exports.normalize = function(_path) {
			if (isBrowser) {
				var isAbsolute = exports.isAbsolute(_path),
					trailingSlash = _path[_path.length - 1] === '/',
					segments = _path.split('/'),
					nonEmptySegments = [];
		
				// Normalize the path
				for (var i = 0; i < segments.length; i++) {
					if (segments[i]) {
						nonEmptySegments.push(segments[i]);
					}
				}
				_path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');
		
				if (!_path && !isAbsolute) {
					_path = '.';
				}
				if (_path && trailingSlash) {
					_path += '/';
				}
		
				return (isAbsolute ? '/' : '') + _path;
			} else {
				return path.normalize.call({}, _path);
			}
		};
		
		exports.join = function() {
			if (isBrowser) {
				var _path = '';
				for (var i = 0; i < arguments.length; i++) {
					var segment = arguments[i];
					if (typeof segment != 'string') {
						throw new TypeError('Arguments to path.join must be strings');
					}
					if (segment) {
						if (!_path) {
							_path += segment;
						} else {
							_path += '/' + segment;
						}
					}
				}
				return exports.normalize(_path);
			} else {
				return path.join.apply({}, arguments);
			}
		};
		
		exports.dirname = function(_path) {
			if (isBrowser) {
				var result = splitPath(_path),
					root = result[0],
					dir = result[1];
		
				if (!root && !dir) {
					// No dirname whatsoever
					return '.';
				}
		
				if (dir) {
					// It has a dirname, strip trailing slash
					dir = dir.substr(0, dir.length - 1);
				}
		
				return root + dir;
			} else {
				return path.dirname.call({}, _path);
			}
		};
	
	}, 'callsite/index.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'callsite/index.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'callsite/index.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'callsite/index.js';
		var __dirname = 'callsite';
		var process = {cwd: function() {return '/';}, argv: ['node', 'callsite/index.js'], env: {}};
	
		/** code **/
		
		module.exports = function(){
		  var orig = Error.prepareStackTrace;
		  Error.prepareStackTrace = function(_, stack){ return stack; };
		  var err = new Error;
		  Error.captureStackTrace(err, arguments.callee);
		  var stack = err.stack;
		  Error.prepareStackTrace = orig;
		  return stack;
		};
		
	
	}, 'cache-storage/lib/Cache.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Cache.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Cache.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Cache.js';
		var __dirname = 'cache-storage/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Cache.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Cache;
		
		  Cache = (function() {
		    Cache.FILES = 'files';
		
		    Cache.TAGS = 'tags';
		
		    Cache.EXPIRE = 'expire';
		
		    Cache.ITEMS = 'items';
		
		    Cache.PRIORITY = 'priority';
		
		    Cache.ALL = 'all';
		
		    Cache.TIME_FORMAT = 'YYYY-MM-DD HH:mm';
		
		    Cache.prototype.storage = null;
		
		    Cache.prototype.namespace = null;
		
		    function Cache(storage, namespace) {
		      this.storage = storage;
		      this.namespace = namespace;
		      if (!(this.storage instanceof require('./Storage/Storage'))) {
		        throw new Error('Cache: storage must be instance of cache-storage/Storage/Storage');
		      }
		      this.storage.cache = this;
		    }
		
		    Cache.prototype.generateKey = function(key) {
		      var ch, hash, i, max, _i;
		      hash = 0;
		      if (key.length === 0) {
		        return hash;
		      }
		      max = key.length - 1;
		      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
		        ch = key.charCodeAt(i);
		        hash = ((hash << 5) - hash) + ch;
		        hash |= 0;
		      }
		      return hash;
		    };
		
		    Cache.prototype.load = function(key, fallback) {
		      var data;
		      if (fallback == null) {
		        fallback = null;
		      }
		      data = this.storage.read(this.generateKey(key));
		      if (data === null && fallback !== null) {
		        return this.save(key, fallback);
		      }
		      return data;
		    };
		
		    Cache.prototype.save = function(key, data, dependencies) {
		      if (dependencies == null) {
		        dependencies = {};
		      }
		      key = this.generateKey(key);
		      if (Object.prototype.toString.call(data) === '[object Function]') {
		        data = data();
		      }
		      if (data === null) {
		        this.storage.remove(key);
		      } else {
		        this.storage.write(key, data, this.storage.parseDependencies(dependencies));
		      }
		      return data;
		    };
		
		    Cache.prototype.remove = function(key) {
		      return this.save(key, null);
		    };
		
		    Cache.prototype.clean = function(conditions) {
		      this.storage.clean(conditions);
		      return this;
		    };
		
		    return Cache;
		
		  })();
		
		  module.exports = Cache;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/Storage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/Storage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/Storage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/Storage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/Storage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Cache, Storage, checkFilesSupport, fs, isWindow, moment, path;
		
		  isWindow = typeof window === 'undefined' ? false : true;
		
		  if (!isWindow) {
		    fs = require('fs');
		    path = require('path');
		  }
		
		  moment = require('moment');
		
		  Cache = require('../Cache');
		
		  checkFilesSupport = function() {
		    var version;
		    if (isWindow && window.require.simq !== true) {
		      throw new Error('Files meta information can be used in browser only with simq.');
		    }
		    if (isWindow) {
		      version = window.require.version;
		      if (typeof version === 'undefined' || parseInt(version.replace(/\./g, '')) < 510) {
		        throw new Error('File method information is supported only with simq@5.1.0 and later.');
		      }
		    }
		  };
		
		  Storage = (function() {
		    Storage.prototype.cache = null;
		
		    function Storage() {
		      if (typeof this.getData === 'undefined' || typeof this.getMeta === 'undefined' || typeof this.writeData === 'undefined') {
		        throw new Error('Cache storage: you have to implement methods getData, getMeta and writeData.');
		      }
		    }
		
		    Storage.prototype.read = function(key) {
		      var data;
		      data = this.getData();
		      if (typeof data[key] === 'undefined') {
		        return null;
		      } else {
		        if (this.verify(this.findMeta(key))) {
		          return data[key];
		        } else {
		          this.remove(key);
		          return null;
		        }
		      }
		    };
		
		    Storage.prototype.write = function(key, data, dependencies) {
		      var all, meta;
		      if (dependencies == null) {
		        dependencies = {};
		      }
		      all = this.getData();
		      all[key] = data;
		      meta = this.getMeta();
		      meta[key] = dependencies;
		      this.writeData(all, meta);
		      return this;
		    };
		
		    Storage.prototype.remove = function(key) {
		      var data, meta;
		      data = this.getData();
		      meta = this.getMeta();
		      if (typeof data[key] !== 'undefined') {
		        delete data[key];
		        delete meta[key];
		      }
		      this.writeData(data, meta);
		      return this;
		    };
		
		    Storage.prototype.clean = function(conditions) {
		      var key, tag, type, typeFn, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
		      typeFn = Object.prototype.toString;
		      type = typeFn.call(conditions);
		      if (conditions === Cache.ALL) {
		        this.writeData({}, {});
		      } else if (type === '[object Object]') {
		        if (typeof conditions[Cache.TAGS] !== 'undefined') {
		          if (typeFn(conditions[Cache.TAGS]) === '[object String]') {
		            conditions[Cache.TAGS] = [conditions[Cache.TAGS]];
		          }
		          _ref = conditions[Cache.TAGS];
		          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		            tag = _ref[_i];
		            _ref1 = this.findKeysByTag(tag);
		            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
		              key = _ref1[_j];
		              this.remove(key);
		            }
		          }
		        }
		        if (typeof conditions[Cache.PRIORITY] !== 'undefined') {
		          _ref2 = this.findKeysByPriority(conditions[Cache.PRIORITY]);
		          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
		            key = _ref2[_k];
		            this.remove(key);
		          }
		        }
		      }
		      return this;
		    };
		
		    Storage.prototype.findMeta = function(key) {
		      var meta;
		      meta = this.getMeta();
		      if (typeof meta[key] !== 'undefined') {
		        return meta[key];
		      } else {
		        return null;
		      }
		    };
		
		    Storage.prototype.findKeysByTag = function(tag) {
		      var key, meta, metas, result;
		      metas = this.getMeta();
		      result = [];
		      for (key in metas) {
		        meta = metas[key];
		        if (typeof meta[Cache.TAGS] !== 'undefined' && meta[Cache.TAGS].indexOf(tag) !== -1) {
		          result.push(key);
		        }
		      }
		      return result;
		    };
		
		    Storage.prototype.findKeysByPriority = function(priority) {
		      var key, meta, metas, result;
		      metas = this.getMeta();
		      result = [];
		      for (key in metas) {
		        meta = metas[key];
		        if (typeof meta[Cache.PRIORITY] !== 'undefined' && meta[Cache.PRIORITY] <= priority) {
		          result.push(key);
		        }
		      }
		      return result;
		    };
		
		    Storage.prototype.verify = function(meta) {
		      var file, item, mtime, time, typefn, _i, _len, _ref, _ref1, _ref2;
		      typefn = Object.prototype.toString;
		      if (typefn.call(meta) === '[object Object]') {
		        if (typeof meta[Cache.FILES] !== 'undefined') {
		          checkFilesSupport();
		          if (isWindow) {
		            _ref = meta[Cache.FILES];
		            for (file in _ref) {
		              time = _ref[file];
		              mtime = window.require.getStats(file).mtime;
		              if (mtime === null) {
		                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
		              }
		              if (window.require.getStats(file).mtime.getTime() !== time) {
		                return false;
		              }
		            }
		          } else {
		            _ref1 = meta[Cache.FILES];
		            for (file in _ref1) {
		              time = _ref1[file];
		              if ((new Date(fs.statSync(file).mtime)).getTime() !== time) {
		                return false;
		              }
		            }
		          }
		        }
		        if (typeof meta[Cache.EXPIRE] !== 'undefined') {
		          if (moment().valueOf() >= meta[Cache.EXPIRE]) {
		            return false;
		          }
		        }
		        if (typeof meta[Cache.ITEMS] !== 'undefined') {
		          _ref2 = meta[Cache.ITEMS];
		          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
		            item = _ref2[_i];
		            item = this.findMeta(item);
		            if ((item === null) || (item !== null && this.verify(item) === false)) {
		              return false;
		            }
		          }
		        }
		      }
		      return true;
		    };
		
		    Storage.prototype.parseDependencies = function(dependencies) {
		      var file, files, i, item, mtime, result, time, typefn, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
		      typefn = Object.prototype.toString;
		      result = {};
		      if (typefn.call(dependencies) === '[object Object]') {
		        if (typeof dependencies[Cache.FILES] !== 'undefined') {
		          checkFilesSupport();
		          files = {};
		          if (isWindow) {
		            _ref = dependencies[Cache.FILES];
		            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
		              file = _ref[_i];
		              mtime = window.require.getStats(file).mtime;
		              if (mtime === null) {
		                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
		              }
		              file = window.require.resolve(file);
		              files[file] = mtime.getTime();
		            }
		          } else {
		            _ref1 = dependencies[Cache.FILES];
		            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
		              file = _ref1[_j];
		              file = path.resolve(file);
		              files[file] = (new Date(fs.statSync(file).mtime)).getTime();
		            }
		          }
		          result[Cache.FILES] = files;
		        }
		        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
		          switch (typefn.call(dependencies[Cache.EXPIRE])) {
		            case '[object String]':
		              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
		              break;
		            case '[object Object]':
		              time = moment().add(dependencies[Cache.EXPIRE]);
		              break;
		            default:
		              throw new Error('Expire format is not valid');
		          }
		          result[Cache.EXPIRE] = time.valueOf();
		        }
		        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
		          result[Cache.ITEMS] = [];
		          _ref2 = dependencies[Cache.ITEMS];
		          for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
		            item = _ref2[i];
		            result[Cache.ITEMS].push(this.cache.generateKey(item));
		          }
		        }
		        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
		          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
		        }
		        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
		          result[Cache.TAGS] = dependencies[Cache.TAGS];
		        }
		      }
		      return result;
		    };
		
		    return Storage;
		
		  })();
		
		  module.exports = Storage;
		
		}).call(this);
		
	
	}, 'moment/moment.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'moment/moment.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/moment.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'moment/moment.js';
		var __dirname = 'moment';
		var process = {cwd: function() {return '/';}, argv: ['node', 'moment/moment.js'], env: {}};
	
		/** code **/
		//! moment.js
		//! version : 2.5.1
		//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
		//! license : MIT
		//! momentjs.com
		
		(function (undefined) {
		
		    /************************************
		        Constants
		    ************************************/
		
		    var moment,
		        VERSION = "2.5.1",
		        global = this,
		        round = Math.round,
		        i,
		
		        YEAR = 0,
		        MONTH = 1,
		        DATE = 2,
		        HOUR = 3,
		        MINUTE = 4,
		        SECOND = 5,
		        MILLISECOND = 6,
		
		        // internal storage for language config files
		        languages = {},
		
		        // moment internal properties
		        momentProperties = {
		            _isAMomentObject: null,
		            _i : null,
		            _f : null,
		            _l : null,
		            _strict : null,
		            _isUTC : null,
		            _offset : null,  // optional. Combine with _isUTC
		            _pf : null,
		            _lang : null  // optional
		        },
		
		        // check for nodeJS
		        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),
		
		        // ASP.NET json date format regex
		        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
		        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
		
		        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
		        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
		        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
		
		        // format tokens
		        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
		        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
		
		        // parsing token regexes
		        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
		        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
		        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
		        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
		        parseTokenDigits = /\d+/, // nonzero number of digits
		        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
		        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
		        parseTokenT = /T/i, // T (ISO separator)
		        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
		
		        //strict parsing regexes
		        parseTokenOneDigit = /\d/, // 0 - 9
		        parseTokenTwoDigits = /\d\d/, // 00 - 99
		        parseTokenThreeDigits = /\d{3}/, // 000 - 999
		        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
		        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
		        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf
		
		        // iso 8601 regex
		        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
		        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		
		        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
		
		        isoDates = [
		            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
		            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
		            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
		            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
		            ['YYYY-DDD', /\d{4}-\d{3}/]
		        ],
		
		        // iso time formats and regexes
		        isoTimes = [
		            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
		            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
		            ['HH:mm', /(T| )\d\d:\d\d/],
		            ['HH', /(T| )\d\d/]
		        ],
		
		        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
		        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
		
		        // getter and setter names
		        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
		        unitMillisecondFactors = {
		            'Milliseconds' : 1,
		            'Seconds' : 1e3,
		            'Minutes' : 6e4,
		            'Hours' : 36e5,
		            'Days' : 864e5,
		            'Months' : 2592e6,
		            'Years' : 31536e6
		        },
		
		        unitAliases = {
		            ms : 'millisecond',
		            s : 'second',
		            m : 'minute',
		            h : 'hour',
		            d : 'day',
		            D : 'date',
		            w : 'week',
		            W : 'isoWeek',
		            M : 'month',
		            y : 'year',
		            DDD : 'dayOfYear',
		            e : 'weekday',
		            E : 'isoWeekday',
		            gg: 'weekYear',
		            GG: 'isoWeekYear'
		        },
		
		        camelFunctions = {
		            dayofyear : 'dayOfYear',
		            isoweekday : 'isoWeekday',
		            isoweek : 'isoWeek',
		            weekyear : 'weekYear',
		            isoweekyear : 'isoWeekYear'
		        },
		
		        // format function strings
		        formatFunctions = {},
		
		        // tokens to ordinalize and pad
		        ordinalizeTokens = 'DDD w W M D d'.split(' '),
		        paddedTokens = 'M D H h m s w W'.split(' '),
		
		        formatTokenFunctions = {
		            M    : function () {
		                return this.month() + 1;
		            },
		            MMM  : function (format) {
		                return this.lang().monthsShort(this, format);
		            },
		            MMMM : function (format) {
		                return this.lang().months(this, format);
		            },
		            D    : function () {
		                return this.date();
		            },
		            DDD  : function () {
		                return this.dayOfYear();
		            },
		            d    : function () {
		                return this.day();
		            },
		            dd   : function (format) {
		                return this.lang().weekdaysMin(this, format);
		            },
		            ddd  : function (format) {
		                return this.lang().weekdaysShort(this, format);
		            },
		            dddd : function (format) {
		                return this.lang().weekdays(this, format);
		            },
		            w    : function () {
		                return this.week();
		            },
		            W    : function () {
		                return this.isoWeek();
		            },
		            YY   : function () {
		                return leftZeroFill(this.year() % 100, 2);
		            },
		            YYYY : function () {
		                return leftZeroFill(this.year(), 4);
		            },
		            YYYYY : function () {
		                return leftZeroFill(this.year(), 5);
		            },
		            YYYYYY : function () {
		                var y = this.year(), sign = y >= 0 ? '+' : '-';
		                return sign + leftZeroFill(Math.abs(y), 6);
		            },
		            gg   : function () {
		                return leftZeroFill(this.weekYear() % 100, 2);
		            },
		            gggg : function () {
		                return leftZeroFill(this.weekYear(), 4);
		            },
		            ggggg : function () {
		                return leftZeroFill(this.weekYear(), 5);
		            },
		            GG   : function () {
		                return leftZeroFill(this.isoWeekYear() % 100, 2);
		            },
		            GGGG : function () {
		                return leftZeroFill(this.isoWeekYear(), 4);
		            },
		            GGGGG : function () {
		                return leftZeroFill(this.isoWeekYear(), 5);
		            },
		            e : function () {
		                return this.weekday();
		            },
		            E : function () {
		                return this.isoWeekday();
		            },
		            a    : function () {
		                return this.lang().meridiem(this.hours(), this.minutes(), true);
		            },
		            A    : function () {
		                return this.lang().meridiem(this.hours(), this.minutes(), false);
		            },
		            H    : function () {
		                return this.hours();
		            },
		            h    : function () {
		                return this.hours() % 12 || 12;
		            },
		            m    : function () {
		                return this.minutes();
		            },
		            s    : function () {
		                return this.seconds();
		            },
		            S    : function () {
		                return toInt(this.milliseconds() / 100);
		            },
		            SS   : function () {
		                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
		            },
		            SSS  : function () {
		                return leftZeroFill(this.milliseconds(), 3);
		            },
		            SSSS : function () {
		                return leftZeroFill(this.milliseconds(), 3);
		            },
		            Z    : function () {
		                var a = -this.zone(),
		                    b = "+";
		                if (a < 0) {
		                    a = -a;
		                    b = "-";
		                }
		                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
		            },
		            ZZ   : function () {
		                var a = -this.zone(),
		                    b = "+";
		                if (a < 0) {
		                    a = -a;
		                    b = "-";
		                }
		                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
		            },
		            z : function () {
		                return this.zoneAbbr();
		            },
		            zz : function () {
		                return this.zoneName();
		            },
		            X    : function () {
		                return this.unix();
		            },
		            Q : function () {
		                return this.quarter();
		            }
		        },
		
		        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
		
		    function defaultParsingFlags() {
		        // We need to deep clone this object, and es5 standard is not very
		        // helpful.
		        return {
		            empty : false,
		            unusedTokens : [],
		            unusedInput : [],
		            overflow : -2,
		            charsLeftOver : 0,
		            nullInput : false,
		            invalidMonth : null,
		            invalidFormat : false,
		            userInvalidated : false,
		            iso: false
		        };
		    }
		
		    function padToken(func, count) {
		        return function (a) {
		            return leftZeroFill(func.call(this, a), count);
		        };
		    }
		    function ordinalizeToken(func, period) {
		        return function (a) {
		            return this.lang().ordinal(func.call(this, a), period);
		        };
		    }
		
		    while (ordinalizeTokens.length) {
		        i = ordinalizeTokens.pop();
		        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
		    }
		    while (paddedTokens.length) {
		        i = paddedTokens.pop();
		        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
		    }
		    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
		
		
		    /************************************
		        Constructors
		    ************************************/
		
		    function Language() {
		
		    }
		
		    // Moment prototype object
		    function Moment(config) {
		        checkOverflow(config);
		        extend(this, config);
		    }
		
		    // Duration Constructor
		    function Duration(duration) {
		        var normalizedInput = normalizeObjectUnits(duration),
		            years = normalizedInput.year || 0,
		            months = normalizedInput.month || 0,
		            weeks = normalizedInput.week || 0,
		            days = normalizedInput.day || 0,
		            hours = normalizedInput.hour || 0,
		            minutes = normalizedInput.minute || 0,
		            seconds = normalizedInput.second || 0,
		            milliseconds = normalizedInput.millisecond || 0;
		
		        // representation for dateAddRemove
		        this._milliseconds = +milliseconds +
		            seconds * 1e3 + // 1000
		            minutes * 6e4 + // 1000 * 60
		            hours * 36e5; // 1000 * 60 * 60
		        // Because of dateAddRemove treats 24 hours as different from a
		        // day when working around DST, we need to store them separately
		        this._days = +days +
		            weeks * 7;
		        // It is impossible translate months into days without knowing
		        // which months you are are talking about, so we have to store
		        // it separately.
		        this._months = +months +
		            years * 12;
		
		        this._data = {};
		
		        this._bubble();
		    }
		
		    /************************************
		        Helpers
		    ************************************/
		
		
		    function extend(a, b) {
		        for (var i in b) {
		            if (b.hasOwnProperty(i)) {
		                a[i] = b[i];
		            }
		        }
		
		        if (b.hasOwnProperty("toString")) {
		            a.toString = b.toString;
		        }
		
		        if (b.hasOwnProperty("valueOf")) {
		            a.valueOf = b.valueOf;
		        }
		
		        return a;
		    }
		
		    function cloneMoment(m) {
		        var result = {}, i;
		        for (i in m) {
		            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
		                result[i] = m[i];
		            }
		        }
		
		        return result;
		    }
		
		    function absRound(number) {
		        if (number < 0) {
		            return Math.ceil(number);
		        } else {
		            return Math.floor(number);
		        }
		    }
		
		    // left zero fill a number
		    // see http://jsperf.com/left-zero-filling for performance comparison
		    function leftZeroFill(number, targetLength, forceSign) {
		        var output = '' + Math.abs(number),
		            sign = number >= 0;
		
		        while (output.length < targetLength) {
		            output = '0' + output;
		        }
		        return (sign ? (forceSign ? '+' : '') : '-') + output;
		    }
		
		    // helper function for _.addTime and _.subtractTime
		    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
		        var milliseconds = duration._milliseconds,
		            days = duration._days,
		            months = duration._months,
		            minutes,
		            hours;
		
		        if (milliseconds) {
		            mom._d.setTime(+mom._d + milliseconds * isAdding);
		        }
		        // store the minutes and hours so we can restore them
		        if (days || months) {
		            minutes = mom.minute();
		            hours = mom.hour();
		        }
		        if (days) {
		            mom.date(mom.date() + days * isAdding);
		        }
		        if (months) {
		            mom.month(mom.month() + months * isAdding);
		        }
		        if (milliseconds && !ignoreUpdateOffset) {
		            moment.updateOffset(mom);
		        }
		        // restore the minutes and hours after possibly changing dst
		        if (days || months) {
		            mom.minute(minutes);
		            mom.hour(hours);
		        }
		    }
		
		    // check if is an array
		    function isArray(input) {
		        return Object.prototype.toString.call(input) === '[object Array]';
		    }
		
		    function isDate(input) {
		        return  Object.prototype.toString.call(input) === '[object Date]' ||
		                input instanceof Date;
		    }
		
		    // compare two arrays, return the number of differences
		    function compareArrays(array1, array2, dontConvert) {
		        var len = Math.min(array1.length, array2.length),
		            lengthDiff = Math.abs(array1.length - array2.length),
		            diffs = 0,
		            i;
		        for (i = 0; i < len; i++) {
		            if ((dontConvert && array1[i] !== array2[i]) ||
		                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
		                diffs++;
		            }
		        }
		        return diffs + lengthDiff;
		    }
		
		    function normalizeUnits(units) {
		        if (units) {
		            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
		            units = unitAliases[units] || camelFunctions[lowered] || lowered;
		        }
		        return units;
		    }
		
		    function normalizeObjectUnits(inputObject) {
		        var normalizedInput = {},
		            normalizedProp,
		            prop;
		
		        for (prop in inputObject) {
		            if (inputObject.hasOwnProperty(prop)) {
		                normalizedProp = normalizeUnits(prop);
		                if (normalizedProp) {
		                    normalizedInput[normalizedProp] = inputObject[prop];
		                }
		            }
		        }
		
		        return normalizedInput;
		    }
		
		    function makeList(field) {
		        var count, setter;
		
		        if (field.indexOf('week') === 0) {
		            count = 7;
		            setter = 'day';
		        }
		        else if (field.indexOf('month') === 0) {
		            count = 12;
		            setter = 'month';
		        }
		        else {
		            return;
		        }
		
		        moment[field] = function (format, index) {
		            var i, getter,
		                method = moment.fn._lang[field],
		                results = [];
		
		            if (typeof format === 'number') {
		                index = format;
		                format = undefined;
		            }
		
		            getter = function (i) {
		                var m = moment().utc().set(setter, i);
		                return method.call(moment.fn._lang, m, format || '');
		            };
		
		            if (index != null) {
		                return getter(index);
		            }
		            else {
		                for (i = 0; i < count; i++) {
		                    results.push(getter(i));
		                }
		                return results;
		            }
		        };
		    }
		
		    function toInt(argumentForCoercion) {
		        var coercedNumber = +argumentForCoercion,
		            value = 0;
		
		        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
		            if (coercedNumber >= 0) {
		                value = Math.floor(coercedNumber);
		            } else {
		                value = Math.ceil(coercedNumber);
		            }
		        }
		
		        return value;
		    }
		
		    function daysInMonth(year, month) {
		        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
		    }
		
		    function daysInYear(year) {
		        return isLeapYear(year) ? 366 : 365;
		    }
		
		    function isLeapYear(year) {
		        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
		    }
		
		    function checkOverflow(m) {
		        var overflow;
		        if (m._a && m._pf.overflow === -2) {
		            overflow =
		                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
		                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
		                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
		                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
		                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
		                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
		                -1;
		
		            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
		                overflow = DATE;
		            }
		
		            m._pf.overflow = overflow;
		        }
		    }
		
		    function isValid(m) {
		        if (m._isValid == null) {
		            m._isValid = !isNaN(m._d.getTime()) &&
		                m._pf.overflow < 0 &&
		                !m._pf.empty &&
		                !m._pf.invalidMonth &&
		                !m._pf.nullInput &&
		                !m._pf.invalidFormat &&
		                !m._pf.userInvalidated;
		
		            if (m._strict) {
		                m._isValid = m._isValid &&
		                    m._pf.charsLeftOver === 0 &&
		                    m._pf.unusedTokens.length === 0;
		            }
		        }
		        return m._isValid;
		    }
		
		    function normalizeLanguage(key) {
		        return key ? key.toLowerCase().replace('_', '-') : key;
		    }
		
		    // Return a moment from input, that is local/utc/zone equivalent to model.
		    function makeAs(input, model) {
		        return model._isUTC ? moment(input).zone(model._offset || 0) :
		            moment(input).local();
		    }
		
		    /************************************
		        Languages
		    ************************************/
		
		
		    extend(Language.prototype, {
		
		        set : function (config) {
		            var prop, i;
		            for (i in config) {
		                prop = config[i];
		                if (typeof prop === 'function') {
		                    this[i] = prop;
		                } else {
		                    this['_' + i] = prop;
		                }
		            }
		        },
		
		        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
		        months : function (m) {
		            return this._months[m.month()];
		        },
		
		        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
		        monthsShort : function (m) {
		            return this._monthsShort[m.month()];
		        },
		
		        monthsParse : function (monthName) {
		            var i, mom, regex;
		
		            if (!this._monthsParse) {
		                this._monthsParse = [];
		            }
		
		            for (i = 0; i < 12; i++) {
		                // make the regex if we don't have it already
		                if (!this._monthsParse[i]) {
		                    mom = moment.utc([2000, i]);
		                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
		                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
		                }
		                // test the regex
		                if (this._monthsParse[i].test(monthName)) {
		                    return i;
		                }
		            }
		        },
		
		        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
		        weekdays : function (m) {
		            return this._weekdays[m.day()];
		        },
		
		        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
		        weekdaysShort : function (m) {
		            return this._weekdaysShort[m.day()];
		        },
		
		        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
		        weekdaysMin : function (m) {
		            return this._weekdaysMin[m.day()];
		        },
		
		        weekdaysParse : function (weekdayName) {
		            var i, mom, regex;
		
		            if (!this._weekdaysParse) {
		                this._weekdaysParse = [];
		            }
		
		            for (i = 0; i < 7; i++) {
		                // make the regex if we don't have it already
		                if (!this._weekdaysParse[i]) {
		                    mom = moment([2000, 1]).day(i);
		                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
		                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
		                }
		                // test the regex
		                if (this._weekdaysParse[i].test(weekdayName)) {
		                    return i;
		                }
		            }
		        },
		
		        _longDateFormat : {
		            LT : "h:mm A",
		            L : "MM/DD/YYYY",
		            LL : "MMMM D YYYY",
		            LLL : "MMMM D YYYY LT",
		            LLLL : "dddd, MMMM D YYYY LT"
		        },
		        longDateFormat : function (key) {
		            var output = this._longDateFormat[key];
		            if (!output && this._longDateFormat[key.toUpperCase()]) {
		                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
		                    return val.slice(1);
		                });
		                this._longDateFormat[key] = output;
		            }
		            return output;
		        },
		
		        isPM : function (input) {
		            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
		            // Using charAt should be more compatible.
		            return ((input + '').toLowerCase().charAt(0) === 'p');
		        },
		
		        _meridiemParse : /[ap]\.?m?\.?/i,
		        meridiem : function (hours, minutes, isLower) {
		            if (hours > 11) {
		                return isLower ? 'pm' : 'PM';
		            } else {
		                return isLower ? 'am' : 'AM';
		            }
		        },
		
		        _calendar : {
		            sameDay : '[Today at] LT',
		            nextDay : '[Tomorrow at] LT',
		            nextWeek : 'dddd [at] LT',
		            lastDay : '[Yesterday at] LT',
		            lastWeek : '[Last] dddd [at] LT',
		            sameElse : 'L'
		        },
		        calendar : function (key, mom) {
		            var output = this._calendar[key];
		            return typeof output === 'function' ? output.apply(mom) : output;
		        },
		
		        _relativeTime : {
		            future : "in %s",
		            past : "%s ago",
		            s : "a few seconds",
		            m : "a minute",
		            mm : "%d minutes",
		            h : "an hour",
		            hh : "%d hours",
		            d : "a day",
		            dd : "%d days",
		            M : "a month",
		            MM : "%d months",
		            y : "a year",
		            yy : "%d years"
		        },
		        relativeTime : function (number, withoutSuffix, string, isFuture) {
		            var output = this._relativeTime[string];
		            return (typeof output === 'function') ?
		                output(number, withoutSuffix, string, isFuture) :
		                output.replace(/%d/i, number);
		        },
		        pastFuture : function (diff, output) {
		            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
		            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
		        },
		
		        ordinal : function (number) {
		            return this._ordinal.replace("%d", number);
		        },
		        _ordinal : "%d",
		
		        preparse : function (string) {
		            return string;
		        },
		
		        postformat : function (string) {
		            return string;
		        },
		
		        week : function (mom) {
		            return weekOfYear(mom, this._week.dow, this._week.doy).week;
		        },
		
		        _week : {
		            dow : 0, // Sunday is the first day of the week.
		            doy : 6  // The week that contains Jan 1st is the first week of the year.
		        },
		
		        _invalidDate: 'Invalid date',
		        invalidDate: function () {
		            return this._invalidDate;
		        }
		    });
		
		    // Loads a language definition into the `languages` cache.  The function
		    // takes a key and optionally values.  If not in the browser and no values
		    // are provided, it will load the language file module.  As a convenience,
		    // this function also returns the language values.
		    function loadLang(key, values) {
		        values.abbr = key;
		        if (!languages[key]) {
		            languages[key] = new Language();
		        }
		        languages[key].set(values);
		        return languages[key];
		    }
		
		    // Remove a language from the `languages` cache. Mostly useful in tests.
		    function unloadLang(key) {
		        delete languages[key];
		    }
		
		    // Determines which language definition to use and returns it.
		    //
		    // With no parameters, it will return the global language.  If you
		    // pass in a language key, such as 'en', it will return the
		    // definition for 'en', so long as 'en' has already been loaded using
		    // moment.lang.
		    function getLangDefinition(key) {
		        var i = 0, j, lang, next, split,
		            get = function (k) {
		                if (!languages[k] && hasModule) {
		                    try {
		                        require('./lang/' + k);
		                    } catch (e) { }
		                }
		                return languages[k];
		            };
		
		        if (!key) {
		            return moment.fn._lang;
		        }
		
		        if (!isArray(key)) {
		            //short-circuit everything else
		            lang = get(key);
		            if (lang) {
		                return lang;
		            }
		            key = [key];
		        }
		
		        //pick the language from the array
		        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
		        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
		        while (i < key.length) {
		            split = normalizeLanguage(key[i]).split('-');
		            j = split.length;
		            next = normalizeLanguage(key[i + 1]);
		            next = next ? next.split('-') : null;
		            while (j > 0) {
		                lang = get(split.slice(0, j).join('-'));
		                if (lang) {
		                    return lang;
		                }
		                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
		                    //the next array item is better than a shallower substring of this one
		                    break;
		                }
		                j--;
		            }
		            i++;
		        }
		        return moment.fn._lang;
		    }
		
		    /************************************
		        Formatting
		    ************************************/
		
		
		    function removeFormattingTokens(input) {
		        if (input.match(/\[[\s\S]/)) {
		            return input.replace(/^\[|\]$/g, "");
		        }
		        return input.replace(/\\/g, "");
		    }
		
		    function makeFormatFunction(format) {
		        var array = format.match(formattingTokens), i, length;
		
		        for (i = 0, length = array.length; i < length; i++) {
		            if (formatTokenFunctions[array[i]]) {
		                array[i] = formatTokenFunctions[array[i]];
		            } else {
		                array[i] = removeFormattingTokens(array[i]);
		            }
		        }
		
		        return function (mom) {
		            var output = "";
		            for (i = 0; i < length; i++) {
		                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
		            }
		            return output;
		        };
		    }
		
		    // format date using native date object
		    function formatMoment(m, format) {
		
		        if (!m.isValid()) {
		            return m.lang().invalidDate();
		        }
		
		        format = expandFormat(format, m.lang());
		
		        if (!formatFunctions[format]) {
		            formatFunctions[format] = makeFormatFunction(format);
		        }
		
		        return formatFunctions[format](m);
		    }
		
		    function expandFormat(format, lang) {
		        var i = 5;
		
		        function replaceLongDateFormatTokens(input) {
		            return lang.longDateFormat(input) || input;
		        }
		
		        localFormattingTokens.lastIndex = 0;
		        while (i >= 0 && localFormattingTokens.test(format)) {
		            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
		            localFormattingTokens.lastIndex = 0;
		            i -= 1;
		        }
		
		        return format;
		    }
		
		
		    /************************************
		        Parsing
		    ************************************/
		
		
		    // get the regex to find the next token
		    function getParseRegexForToken(token, config) {
		        var a, strict = config._strict;
		        switch (token) {
		        case 'DDDD':
		            return parseTokenThreeDigits;
		        case 'YYYY':
		        case 'GGGG':
		        case 'gggg':
		            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
		        case 'Y':
		        case 'G':
		        case 'g':
		            return parseTokenSignedNumber;
		        case 'YYYYYY':
		        case 'YYYYY':
		        case 'GGGGG':
		        case 'ggggg':
		            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
		        case 'S':
		            if (strict) { return parseTokenOneDigit; }
		            /* falls through */
		        case 'SS':
		            if (strict) { return parseTokenTwoDigits; }
		            /* falls through */
		        case 'SSS':
		            if (strict) { return parseTokenThreeDigits; }
		            /* falls through */
		        case 'DDD':
		            return parseTokenOneToThreeDigits;
		        case 'MMM':
		        case 'MMMM':
		        case 'dd':
		        case 'ddd':
		        case 'dddd':
		            return parseTokenWord;
		        case 'a':
		        case 'A':
		            return getLangDefinition(config._l)._meridiemParse;
		        case 'X':
		            return parseTokenTimestampMs;
		        case 'Z':
		        case 'ZZ':
		            return parseTokenTimezone;
		        case 'T':
		            return parseTokenT;
		        case 'SSSS':
		            return parseTokenDigits;
		        case 'MM':
		        case 'DD':
		        case 'YY':
		        case 'GG':
		        case 'gg':
		        case 'HH':
		        case 'hh':
		        case 'mm':
		        case 'ss':
		        case 'ww':
		        case 'WW':
		            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
		        case 'M':
		        case 'D':
		        case 'd':
		        case 'H':
		        case 'h':
		        case 'm':
		        case 's':
		        case 'w':
		        case 'W':
		        case 'e':
		        case 'E':
		            return parseTokenOneOrTwoDigits;
		        default :
		            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
		            return a;
		        }
		    }
		
		    function timezoneMinutesFromString(string) {
		        string = string || "";
		        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
		            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
		            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
		            minutes = +(parts[1] * 60) + toInt(parts[2]);
		
		        return parts[0] === '+' ? -minutes : minutes;
		    }
		
		    // function to convert string input to date
		    function addTimeToArrayFromToken(token, input, config) {
		        var a, datePartArray = config._a;
		
		        switch (token) {
		        // MONTH
		        case 'M' : // fall through to MM
		        case 'MM' :
		            if (input != null) {
		                datePartArray[MONTH] = toInt(input) - 1;
		            }
		            break;
		        case 'MMM' : // fall through to MMMM
		        case 'MMMM' :
		            a = getLangDefinition(config._l).monthsParse(input);
		            // if we didn't find a month name, mark the date as invalid.
		            if (a != null) {
		                datePartArray[MONTH] = a;
		            } else {
		                config._pf.invalidMonth = input;
		            }
		            break;
		        // DAY OF MONTH
		        case 'D' : // fall through to DD
		        case 'DD' :
		            if (input != null) {
		                datePartArray[DATE] = toInt(input);
		            }
		            break;
		        // DAY OF YEAR
		        case 'DDD' : // fall through to DDDD
		        case 'DDDD' :
		            if (input != null) {
		                config._dayOfYear = toInt(input);
		            }
		
		            break;
		        // YEAR
		        case 'YY' :
		            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
		            break;
		        case 'YYYY' :
		        case 'YYYYY' :
		        case 'YYYYYY' :
		            datePartArray[YEAR] = toInt(input);
		            break;
		        // AM / PM
		        case 'a' : // fall through to A
		        case 'A' :
		            config._isPm = getLangDefinition(config._l).isPM(input);
		            break;
		        // 24 HOUR
		        case 'H' : // fall through to hh
		        case 'HH' : // fall through to hh
		        case 'h' : // fall through to hh
		        case 'hh' :
		            datePartArray[HOUR] = toInt(input);
		            break;
		        // MINUTE
		        case 'm' : // fall through to mm
		        case 'mm' :
		            datePartArray[MINUTE] = toInt(input);
		            break;
		        // SECOND
		        case 's' : // fall through to ss
		        case 'ss' :
		            datePartArray[SECOND] = toInt(input);
		            break;
		        // MILLISECOND
		        case 'S' :
		        case 'SS' :
		        case 'SSS' :
		        case 'SSSS' :
		            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
		            break;
		        // UNIX TIMESTAMP WITH MS
		        case 'X':
		            config._d = new Date(parseFloat(input) * 1000);
		            break;
		        // TIMEZONE
		        case 'Z' : // fall through to ZZ
		        case 'ZZ' :
		            config._useUTC = true;
		            config._tzm = timezoneMinutesFromString(input);
		            break;
		        case 'w':
		        case 'ww':
		        case 'W':
		        case 'WW':
		        case 'd':
		        case 'dd':
		        case 'ddd':
		        case 'dddd':
		        case 'e':
		        case 'E':
		            token = token.substr(0, 1);
		            /* falls through */
		        case 'gg':
		        case 'gggg':
		        case 'GG':
		        case 'GGGG':
		        case 'GGGGG':
		            token = token.substr(0, 2);
		            if (input) {
		                config._w = config._w || {};
		                config._w[token] = input;
		            }
		            break;
		        }
		    }
		
		    // convert an array to a date.
		    // the array should mirror the parameters below
		    // note: all values past the year are optional and will default to the lowest possible value.
		    // [year, month, day , hour, minute, second, millisecond]
		    function dateFromConfig(config) {
		        var i, date, input = [], currentDate,
		            yearToUse, fixYear, w, temp, lang, weekday, week;
		
		        if (config._d) {
		            return;
		        }
		
		        currentDate = currentDateArray(config);
		
		        //compute day of the year from weeks and weekdays
		        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
		            fixYear = function (val) {
		                var int_val = parseInt(val, 10);
		                return val ?
		                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
		                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
		            };
		
		            w = config._w;
		            if (w.GG != null || w.W != null || w.E != null) {
		                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
		            }
		            else {
		                lang = getLangDefinition(config._l);
		                weekday = w.d != null ?  parseWeekday(w.d, lang) :
		                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);
		
		                week = parseInt(w.w, 10) || 1;
		
		                //if we're parsing 'd', then the low day numbers may be next week
		                if (w.d != null && weekday < lang._week.dow) {
		                    week++;
		                }
		
		                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
		            }
		
		            config._a[YEAR] = temp.year;
		            config._dayOfYear = temp.dayOfYear;
		        }
		
		        //if the day of the year is set, figure out what it is
		        if (config._dayOfYear) {
		            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];
		
		            if (config._dayOfYear > daysInYear(yearToUse)) {
		                config._pf._overflowDayOfYear = true;
		            }
		
		            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
		            config._a[MONTH] = date.getUTCMonth();
		            config._a[DATE] = date.getUTCDate();
		        }
		
		        // Default to current date.
		        // * if no year, month, day of month are given, default to today
		        // * if day of month is given, default month and year
		        // * if month is given, default only year
		        // * if year is given, don't default anything
		        for (i = 0; i < 3 && config._a[i] == null; ++i) {
		            config._a[i] = input[i] = currentDate[i];
		        }
		
		        // Zero out whatever was not defaulted, including time
		        for (; i < 7; i++) {
		            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
		        }
		
		        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
		        input[HOUR] += toInt((config._tzm || 0) / 60);
		        input[MINUTE] += toInt((config._tzm || 0) % 60);
		
		        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
		    }
		
		    function dateFromObject(config) {
		        var normalizedInput;
		
		        if (config._d) {
		            return;
		        }
		
		        normalizedInput = normalizeObjectUnits(config._i);
		        config._a = [
		            normalizedInput.year,
		            normalizedInput.month,
		            normalizedInput.day,
		            normalizedInput.hour,
		            normalizedInput.minute,
		            normalizedInput.second,
		            normalizedInput.millisecond
		        ];
		
		        dateFromConfig(config);
		    }
		
		    function currentDateArray(config) {
		        var now = new Date();
		        if (config._useUTC) {
		            return [
		                now.getUTCFullYear(),
		                now.getUTCMonth(),
		                now.getUTCDate()
		            ];
		        } else {
		            return [now.getFullYear(), now.getMonth(), now.getDate()];
		        }
		    }
		
		    // date from string and format string
		    function makeDateFromStringAndFormat(config) {
		
		        config._a = [];
		        config._pf.empty = true;
		
		        // This array is used to make a Date, either with `new Date` or `Date.UTC`
		        var lang = getLangDefinition(config._l),
		            string = '' + config._i,
		            i, parsedInput, tokens, token, skipped,
		            stringLength = string.length,
		            totalParsedInputLength = 0;
		
		        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];
		
		        for (i = 0; i < tokens.length; i++) {
		            token = tokens[i];
		            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
		            if (parsedInput) {
		                skipped = string.substr(0, string.indexOf(parsedInput));
		                if (skipped.length > 0) {
		                    config._pf.unusedInput.push(skipped);
		                }
		                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
		                totalParsedInputLength += parsedInput.length;
		            }
		            // don't parse if it's not a known token
		            if (formatTokenFunctions[token]) {
		                if (parsedInput) {
		                    config._pf.empty = false;
		                }
		                else {
		                    config._pf.unusedTokens.push(token);
		                }
		                addTimeToArrayFromToken(token, parsedInput, config);
		            }
		            else if (config._strict && !parsedInput) {
		                config._pf.unusedTokens.push(token);
		            }
		        }
		
		        // add remaining unparsed input length to the string
		        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
		        if (string.length > 0) {
		            config._pf.unusedInput.push(string);
		        }
		
		        // handle am pm
		        if (config._isPm && config._a[HOUR] < 12) {
		            config._a[HOUR] += 12;
		        }
		        // if is 12 am, change hours to 0
		        if (config._isPm === false && config._a[HOUR] === 12) {
		            config._a[HOUR] = 0;
		        }
		
		        dateFromConfig(config);
		        checkOverflow(config);
		    }
		
		    function unescapeFormat(s) {
		        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
		            return p1 || p2 || p3 || p4;
		        });
		    }
		
		    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
		    function regexpEscape(s) {
		        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
		    }
		
		    // date from string and array of format strings
		    function makeDateFromStringAndArray(config) {
		        var tempConfig,
		            bestMoment,
		
		            scoreToBeat,
		            i,
		            currentScore;
		
		        if (config._f.length === 0) {
		            config._pf.invalidFormat = true;
		            config._d = new Date(NaN);
		            return;
		        }
		
		        for (i = 0; i < config._f.length; i++) {
		            currentScore = 0;
		            tempConfig = extend({}, config);
		            tempConfig._pf = defaultParsingFlags();
		            tempConfig._f = config._f[i];
		            makeDateFromStringAndFormat(tempConfig);
		
		            if (!isValid(tempConfig)) {
		                continue;
		            }
		
		            // if there is any input that was not parsed add a penalty for that format
		            currentScore += tempConfig._pf.charsLeftOver;
		
		            //or tokens
		            currentScore += tempConfig._pf.unusedTokens.length * 10;
		
		            tempConfig._pf.score = currentScore;
		
		            if (scoreToBeat == null || currentScore < scoreToBeat) {
		                scoreToBeat = currentScore;
		                bestMoment = tempConfig;
		            }
		        }
		
		        extend(config, bestMoment || tempConfig);
		    }
		
		    // date from iso format
		    function makeDateFromString(config) {
		        var i, l,
		            string = config._i,
		            match = isoRegex.exec(string);
		
		        if (match) {
		            config._pf.iso = true;
		            for (i = 0, l = isoDates.length; i < l; i++) {
		                if (isoDates[i][1].exec(string)) {
		                    // match[5] should be "T" or undefined
		                    config._f = isoDates[i][0] + (match[6] || " ");
		                    break;
		                }
		            }
		            for (i = 0, l = isoTimes.length; i < l; i++) {
		                if (isoTimes[i][1].exec(string)) {
		                    config._f += isoTimes[i][0];
		                    break;
		                }
		            }
		            if (string.match(parseTokenTimezone)) {
		                config._f += "Z";
		            }
		            makeDateFromStringAndFormat(config);
		        }
		        else {
		            config._d = new Date(string);
		        }
		    }
		
		    function makeDateFromInput(config) {
		        var input = config._i,
		            matched = aspNetJsonRegex.exec(input);
		
		        if (input === undefined) {
		            config._d = new Date();
		        } else if (matched) {
		            config._d = new Date(+matched[1]);
		        } else if (typeof input === 'string') {
		            makeDateFromString(config);
		        } else if (isArray(input)) {
		            config._a = input.slice(0);
		            dateFromConfig(config);
		        } else if (isDate(input)) {
		            config._d = new Date(+input);
		        } else if (typeof(input) === 'object') {
		            dateFromObject(config);
		        } else {
		            config._d = new Date(input);
		        }
		    }
		
		    function makeDate(y, m, d, h, M, s, ms) {
		        //can't just apply() to create a date:
		        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
		        var date = new Date(y, m, d, h, M, s, ms);
		
		        //the date constructor doesn't accept years < 1970
		        if (y < 1970) {
		            date.setFullYear(y);
		        }
		        return date;
		    }
		
		    function makeUTCDate(y) {
		        var date = new Date(Date.UTC.apply(null, arguments));
		        if (y < 1970) {
		            date.setUTCFullYear(y);
		        }
		        return date;
		    }
		
		    function parseWeekday(input, language) {
		        if (typeof input === 'string') {
		            if (!isNaN(input)) {
		                input = parseInt(input, 10);
		            }
		            else {
		                input = language.weekdaysParse(input);
		                if (typeof input !== 'number') {
		                    return null;
		                }
		            }
		        }
		        return input;
		    }
		
		    /************************************
		        Relative Time
		    ************************************/
		
		
		    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
		    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
		        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
		    }
		
		    function relativeTime(milliseconds, withoutSuffix, lang) {
		        var seconds = round(Math.abs(milliseconds) / 1000),
		            minutes = round(seconds / 60),
		            hours = round(minutes / 60),
		            days = round(hours / 24),
		            years = round(days / 365),
		            args = seconds < 45 && ['s', seconds] ||
		                minutes === 1 && ['m'] ||
		                minutes < 45 && ['mm', minutes] ||
		                hours === 1 && ['h'] ||
		                hours < 22 && ['hh', hours] ||
		                days === 1 && ['d'] ||
		                days <= 25 && ['dd', days] ||
		                days <= 45 && ['M'] ||
		                days < 345 && ['MM', round(days / 30)] ||
		                years === 1 && ['y'] || ['yy', years];
		        args[2] = withoutSuffix;
		        args[3] = milliseconds > 0;
		        args[4] = lang;
		        return substituteTimeAgo.apply({}, args);
		    }
		
		
		    /************************************
		        Week of Year
		    ************************************/
		
		
		    // firstDayOfWeek       0 = sun, 6 = sat
		    //                      the day of the week that starts the week
		    //                      (usually sunday or monday)
		    // firstDayOfWeekOfYear 0 = sun, 6 = sat
		    //                      the first week is the week that contains the first
		    //                      of this day of the week
		    //                      (eg. ISO weeks use thursday (4))
		    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
		        var end = firstDayOfWeekOfYear - firstDayOfWeek,
		            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
		            adjustedMoment;
		
		
		        if (daysToDayOfWeek > end) {
		            daysToDayOfWeek -= 7;
		        }
		
		        if (daysToDayOfWeek < end - 7) {
		            daysToDayOfWeek += 7;
		        }
		
		        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
		        return {
		            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
		            year: adjustedMoment.year()
		        };
		    }
		
		    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
		    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
		        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
		
		        weekday = weekday != null ? weekday : firstDayOfWeek;
		        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
		        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
		
		        return {
		            year: dayOfYear > 0 ? year : year - 1,
		            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
		        };
		    }
		
		    /************************************
		        Top Level Functions
		    ************************************/
		
		    function makeMoment(config) {
		        var input = config._i,
		            format = config._f;
		
		        if (input === null) {
		            return moment.invalid({nullInput: true});
		        }
		
		        if (typeof input === 'string') {
		            config._i = input = getLangDefinition().preparse(input);
		        }
		
		        if (moment.isMoment(input)) {
		            config = cloneMoment(input);
		
		            config._d = new Date(+input._d);
		        } else if (format) {
		            if (isArray(format)) {
		                makeDateFromStringAndArray(config);
		            } else {
		                makeDateFromStringAndFormat(config);
		            }
		        } else {
		            makeDateFromInput(config);
		        }
		
		        return new Moment(config);
		    }
		
		    moment = function (input, format, lang, strict) {
		        var c;
		
		        if (typeof(lang) === "boolean") {
		            strict = lang;
		            lang = undefined;
		        }
		        // object construction must be done this way.
		        // https://github.com/moment/moment/issues/1423
		        c = {};
		        c._isAMomentObject = true;
		        c._i = input;
		        c._f = format;
		        c._l = lang;
		        c._strict = strict;
		        c._isUTC = false;
		        c._pf = defaultParsingFlags();
		
		        return makeMoment(c);
		    };
		
		    // creating with utc
		    moment.utc = function (input, format, lang, strict) {
		        var c;
		
		        if (typeof(lang) === "boolean") {
		            strict = lang;
		            lang = undefined;
		        }
		        // object construction must be done this way.
		        // https://github.com/moment/moment/issues/1423
		        c = {};
		        c._isAMomentObject = true;
		        c._useUTC = true;
		        c._isUTC = true;
		        c._l = lang;
		        c._i = input;
		        c._f = format;
		        c._strict = strict;
		        c._pf = defaultParsingFlags();
		
		        return makeMoment(c).utc();
		    };
		
		    // creating with unix timestamp (in seconds)
		    moment.unix = function (input) {
		        return moment(input * 1000);
		    };
		
		    // duration
		    moment.duration = function (input, key) {
		        var duration = input,
		            // matching against regexp is expensive, do it on demand
		            match = null,
		            sign,
		            ret,
		            parseIso;
		
		        if (moment.isDuration(input)) {
		            duration = {
		                ms: input._milliseconds,
		                d: input._days,
		                M: input._months
		            };
		        } else if (typeof input === 'number') {
		            duration = {};
		            if (key) {
		                duration[key] = input;
		            } else {
		                duration.milliseconds = input;
		            }
		        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
		            sign = (match[1] === "-") ? -1 : 1;
		            duration = {
		                y: 0,
		                d: toInt(match[DATE]) * sign,
		                h: toInt(match[HOUR]) * sign,
		                m: toInt(match[MINUTE]) * sign,
		                s: toInt(match[SECOND]) * sign,
		                ms: toInt(match[MILLISECOND]) * sign
		            };
		        } else if (!!(match = isoDurationRegex.exec(input))) {
		            sign = (match[1] === "-") ? -1 : 1;
		            parseIso = function (inp) {
		                // We'd normally use ~~inp for this, but unfortunately it also
		                // converts floats to ints.
		                // inp may be undefined, so careful calling replace on it.
		                var res = inp && parseFloat(inp.replace(',', '.'));
		                // apply sign while we're at it
		                return (isNaN(res) ? 0 : res) * sign;
		            };
		            duration = {
		                y: parseIso(match[2]),
		                M: parseIso(match[3]),
		                d: parseIso(match[4]),
		                h: parseIso(match[5]),
		                m: parseIso(match[6]),
		                s: parseIso(match[7]),
		                w: parseIso(match[8])
		            };
		        }
		
		        ret = new Duration(duration);
		
		        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
		            ret._lang = input._lang;
		        }
		
		        return ret;
		    };
		
		    // version number
		    moment.version = VERSION;
		
		    // default format
		    moment.defaultFormat = isoFormat;
		
		    // This function will be called whenever a moment is mutated.
		    // It is intended to keep the offset in sync with the timezone.
		    moment.updateOffset = function () {};
		
		    // This function will load languages and then set the global language.  If
		    // no arguments are passed in, it will simply return the current global
		    // language key.
		    moment.lang = function (key, values) {
		        var r;
		        if (!key) {
		            return moment.fn._lang._abbr;
		        }
		        if (values) {
		            loadLang(normalizeLanguage(key), values);
		        } else if (values === null) {
		            unloadLang(key);
		            key = 'en';
		        } else if (!languages[key]) {
		            getLangDefinition(key);
		        }
		        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
		        return r._abbr;
		    };
		
		    // returns language data
		    moment.langData = function (key) {
		        if (key && key._lang && key._lang._abbr) {
		            key = key._lang._abbr;
		        }
		        return getLangDefinition(key);
		    };
		
		    // compare moment object
		    moment.isMoment = function (obj) {
		        return obj instanceof Moment ||
		            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
		    };
		
		    // for typechecking Duration objects
		    moment.isDuration = function (obj) {
		        return obj instanceof Duration;
		    };
		
		    for (i = lists.length - 1; i >= 0; --i) {
		        makeList(lists[i]);
		    }
		
		    moment.normalizeUnits = function (units) {
		        return normalizeUnits(units);
		    };
		
		    moment.invalid = function (flags) {
		        var m = moment.utc(NaN);
		        if (flags != null) {
		            extend(m._pf, flags);
		        }
		        else {
		            m._pf.userInvalidated = true;
		        }
		
		        return m;
		    };
		
		    moment.parseZone = function (input) {
		        return moment(input).parseZone();
		    };
		
		    /************************************
		        Moment Prototype
		    ************************************/
		
		
		    extend(moment.fn = Moment.prototype, {
		
		        clone : function () {
		            return moment(this);
		        },
		
		        valueOf : function () {
		            return +this._d + ((this._offset || 0) * 60000);
		        },
		
		        unix : function () {
		            return Math.floor(+this / 1000);
		        },
		
		        toString : function () {
		            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
		        },
		
		        toDate : function () {
		            return this._offset ? new Date(+this) : this._d;
		        },
		
		        toISOString : function () {
		            var m = moment(this).utc();
		            if (0 < m.year() && m.year() <= 9999) {
		                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
		            } else {
		                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
		            }
		        },
		
		        toArray : function () {
		            var m = this;
		            return [
		                m.year(),
		                m.month(),
		                m.date(),
		                m.hours(),
		                m.minutes(),
		                m.seconds(),
		                m.milliseconds()
		            ];
		        },
		
		        isValid : function () {
		            return isValid(this);
		        },
		
		        isDSTShifted : function () {
		
		            if (this._a) {
		                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
		            }
		
		            return false;
		        },
		
		        parsingFlags : function () {
		            return extend({}, this._pf);
		        },
		
		        invalidAt: function () {
		            return this._pf.overflow;
		        },
		
		        utc : function () {
		            return this.zone(0);
		        },
		
		        local : function () {
		            this.zone(0);
		            this._isUTC = false;
		            return this;
		        },
		
		        format : function (inputString) {
		            var output = formatMoment(this, inputString || moment.defaultFormat);
		            return this.lang().postformat(output);
		        },
		
		        add : function (input, val) {
		            var dur;
		            // switch args to support add('s', 1) and add(1, 's')
		            if (typeof input === 'string') {
		                dur = moment.duration(+val, input);
		            } else {
		                dur = moment.duration(input, val);
		            }
		            addOrSubtractDurationFromMoment(this, dur, 1);
		            return this;
		        },
		
		        subtract : function (input, val) {
		            var dur;
		            // switch args to support subtract('s', 1) and subtract(1, 's')
		            if (typeof input === 'string') {
		                dur = moment.duration(+val, input);
		            } else {
		                dur = moment.duration(input, val);
		            }
		            addOrSubtractDurationFromMoment(this, dur, -1);
		            return this;
		        },
		
		        diff : function (input, units, asFloat) {
		            var that = makeAs(input, this),
		                zoneDiff = (this.zone() - that.zone()) * 6e4,
		                diff, output;
		
		            units = normalizeUnits(units);
		
		            if (units === 'year' || units === 'month') {
		                // average number of days in the months in the given dates
		                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
		                // difference in months
		                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
		                // adjust by taking difference in days, average number of days
		                // and dst in the given months.
		                output += ((this - moment(this).startOf('month')) -
		                        (that - moment(that).startOf('month'))) / diff;
		                // same as above but with zones, to negate all dst
		                output -= ((this.zone() - moment(this).startOf('month').zone()) -
		                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
		                if (units === 'year') {
		                    output = output / 12;
		                }
		            } else {
		                diff = (this - that);
		                output = units === 'second' ? diff / 1e3 : // 1000
		                    units === 'minute' ? diff / 6e4 : // 1000 * 60
		                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
		                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
		                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
		                    diff;
		            }
		            return asFloat ? output : absRound(output);
		        },
		
		        from : function (time, withoutSuffix) {
		            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
		        },
		
		        fromNow : function (withoutSuffix) {
		            return this.from(moment(), withoutSuffix);
		        },
		
		        calendar : function () {
		            // We want to compare the start of today, vs this.
		            // Getting start-of-today depends on whether we're zone'd or not.
		            var sod = makeAs(moment(), this).startOf('day'),
		                diff = this.diff(sod, 'days', true),
		                format = diff < -6 ? 'sameElse' :
		                    diff < -1 ? 'lastWeek' :
		                    diff < 0 ? 'lastDay' :
		                    diff < 1 ? 'sameDay' :
		                    diff < 2 ? 'nextDay' :
		                    diff < 7 ? 'nextWeek' : 'sameElse';
		            return this.format(this.lang().calendar(format, this));
		        },
		
		        isLeapYear : function () {
		            return isLeapYear(this.year());
		        },
		
		        isDST : function () {
		            return (this.zone() < this.clone().month(0).zone() ||
		                this.zone() < this.clone().month(5).zone());
		        },
		
		        day : function (input) {
		            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
		            if (input != null) {
		                input = parseWeekday(input, this.lang());
		                return this.add({ d : input - day });
		            } else {
		                return day;
		            }
		        },
		
		        month : function (input) {
		            var utc = this._isUTC ? 'UTC' : '',
		                dayOfMonth;
		
		            if (input != null) {
		                if (typeof input === 'string') {
		                    input = this.lang().monthsParse(input);
		                    if (typeof input !== 'number') {
		                        return this;
		                    }
		                }
		
		                dayOfMonth = this.date();
		                this.date(1);
		                this._d['set' + utc + 'Month'](input);
		                this.date(Math.min(dayOfMonth, this.daysInMonth()));
		
		                moment.updateOffset(this);
		                return this;
		            } else {
		                return this._d['get' + utc + 'Month']();
		            }
		        },
		
		        startOf: function (units) {
		            units = normalizeUnits(units);
		            // the following switch intentionally omits break keywords
		            // to utilize falling through the cases.
		            switch (units) {
		            case 'year':
		                this.month(0);
		                /* falls through */
		            case 'month':
		                this.date(1);
		                /* falls through */
		            case 'week':
		            case 'isoWeek':
		            case 'day':
		                this.hours(0);
		                /* falls through */
		            case 'hour':
		                this.minutes(0);
		                /* falls through */
		            case 'minute':
		                this.seconds(0);
		                /* falls through */
		            case 'second':
		                this.milliseconds(0);
		                /* falls through */
		            }
		
		            // weeks are a special case
		            if (units === 'week') {
		                this.weekday(0);
		            } else if (units === 'isoWeek') {
		                this.isoWeekday(1);
		            }
		
		            return this;
		        },
		
		        endOf: function (units) {
		            units = normalizeUnits(units);
		            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
		        },
		
		        isAfter: function (input, units) {
		            units = typeof units !== 'undefined' ? units : 'millisecond';
		            return +this.clone().startOf(units) > +moment(input).startOf(units);
		        },
		
		        isBefore: function (input, units) {
		            units = typeof units !== 'undefined' ? units : 'millisecond';
		            return +this.clone().startOf(units) < +moment(input).startOf(units);
		        },
		
		        isSame: function (input, units) {
		            units = units || 'ms';
		            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
		        },
		
		        min: function (other) {
		            other = moment.apply(null, arguments);
		            return other < this ? this : other;
		        },
		
		        max: function (other) {
		            other = moment.apply(null, arguments);
		            return other > this ? this : other;
		        },
		
		        zone : function (input) {
		            var offset = this._offset || 0;
		            if (input != null) {
		                if (typeof input === "string") {
		                    input = timezoneMinutesFromString(input);
		                }
		                if (Math.abs(input) < 16) {
		                    input = input * 60;
		                }
		                this._offset = input;
		                this._isUTC = true;
		                if (offset !== input) {
		                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
		                }
		            } else {
		                return this._isUTC ? offset : this._d.getTimezoneOffset();
		            }
		            return this;
		        },
		
		        zoneAbbr : function () {
		            return this._isUTC ? "UTC" : "";
		        },
		
		        zoneName : function () {
		            return this._isUTC ? "Coordinated Universal Time" : "";
		        },
		
		        parseZone : function () {
		            if (this._tzm) {
		                this.zone(this._tzm);
		            } else if (typeof this._i === 'string') {
		                this.zone(this._i);
		            }
		            return this;
		        },
		
		        hasAlignedHourOffset : function (input) {
		            if (!input) {
		                input = 0;
		            }
		            else {
		                input = moment(input).zone();
		            }
		
		            return (this.zone() - input) % 60 === 0;
		        },
		
		        daysInMonth : function () {
		            return daysInMonth(this.year(), this.month());
		        },
		
		        dayOfYear : function (input) {
		            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
		            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
		        },
		
		        quarter : function () {
		            return Math.ceil((this.month() + 1.0) / 3.0);
		        },
		
		        weekYear : function (input) {
		            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
		            return input == null ? year : this.add("y", (input - year));
		        },
		
		        isoWeekYear : function (input) {
		            var year = weekOfYear(this, 1, 4).year;
		            return input == null ? year : this.add("y", (input - year));
		        },
		
		        week : function (input) {
		            var week = this.lang().week(this);
		            return input == null ? week : this.add("d", (input - week) * 7);
		        },
		
		        isoWeek : function (input) {
		            var week = weekOfYear(this, 1, 4).week;
		            return input == null ? week : this.add("d", (input - week) * 7);
		        },
		
		        weekday : function (input) {
		            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
		            return input == null ? weekday : this.add("d", input - weekday);
		        },
		
		        isoWeekday : function (input) {
		            // behaves the same as moment#day except
		            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
		            // as a setter, sunday should belong to the previous week.
		            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
		        },
		
		        get : function (units) {
		            units = normalizeUnits(units);
		            return this[units]();
		        },
		
		        set : function (units, value) {
		            units = normalizeUnits(units);
		            if (typeof this[units] === 'function') {
		                this[units](value);
		            }
		            return this;
		        },
		
		        // If passed a language key, it will set the language for this
		        // instance.  Otherwise, it will return the language configuration
		        // variables for this instance.
		        lang : function (key) {
		            if (key === undefined) {
		                return this._lang;
		            } else {
		                this._lang = getLangDefinition(key);
		                return this;
		            }
		        }
		    });
		
		    // helper for adding shortcuts
		    function makeGetterAndSetter(name, key) {
		        moment.fn[name] = moment.fn[name + 's'] = function (input) {
		            var utc = this._isUTC ? 'UTC' : '';
		            if (input != null) {
		                this._d['set' + utc + key](input);
		                moment.updateOffset(this);
		                return this;
		            } else {
		                return this._d['get' + utc + key]();
		            }
		        };
		    }
		
		    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
		    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
		        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
		    }
		
		    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
		    makeGetterAndSetter('year', 'FullYear');
		
		    // add plural methods
		    moment.fn.days = moment.fn.day;
		    moment.fn.months = moment.fn.month;
		    moment.fn.weeks = moment.fn.week;
		    moment.fn.isoWeeks = moment.fn.isoWeek;
		
		    // add aliased format methods
		    moment.fn.toJSON = moment.fn.toISOString;
		
		    /************************************
		        Duration Prototype
		    ************************************/
		
		
		    extend(moment.duration.fn = Duration.prototype, {
		
		        _bubble : function () {
		            var milliseconds = this._milliseconds,
		                days = this._days,
		                months = this._months,
		                data = this._data,
		                seconds, minutes, hours, years;
		
		            // The following code bubbles up values, see the tests for
		            // examples of what that means.
		            data.milliseconds = milliseconds % 1000;
		
		            seconds = absRound(milliseconds / 1000);
		            data.seconds = seconds % 60;
		
		            minutes = absRound(seconds / 60);
		            data.minutes = minutes % 60;
		
		            hours = absRound(minutes / 60);
		            data.hours = hours % 24;
		
		            days += absRound(hours / 24);
		            data.days = days % 30;
		
		            months += absRound(days / 30);
		            data.months = months % 12;
		
		            years = absRound(months / 12);
		            data.years = years;
		        },
		
		        weeks : function () {
		            return absRound(this.days() / 7);
		        },
		
		        valueOf : function () {
		            return this._milliseconds +
		              this._days * 864e5 +
		              (this._months % 12) * 2592e6 +
		              toInt(this._months / 12) * 31536e6;
		        },
		
		        humanize : function (withSuffix) {
		            var difference = +this,
		                output = relativeTime(difference, !withSuffix, this.lang());
		
		            if (withSuffix) {
		                output = this.lang().pastFuture(difference, output);
		            }
		
		            return this.lang().postformat(output);
		        },
		
		        add : function (input, val) {
		            // supports only 2.0-style add(1, 's') or add(moment)
		            var dur = moment.duration(input, val);
		
		            this._milliseconds += dur._milliseconds;
		            this._days += dur._days;
		            this._months += dur._months;
		
		            this._bubble();
		
		            return this;
		        },
		
		        subtract : function (input, val) {
		            var dur = moment.duration(input, val);
		
		            this._milliseconds -= dur._milliseconds;
		            this._days -= dur._days;
		            this._months -= dur._months;
		
		            this._bubble();
		
		            return this;
		        },
		
		        get : function (units) {
		            units = normalizeUnits(units);
		            return this[units.toLowerCase() + 's']();
		        },
		
		        as : function (units) {
		            units = normalizeUnits(units);
		            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
		        },
		
		        lang : moment.fn.lang,
		
		        toIsoString : function () {
		            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
		            var years = Math.abs(this.years()),
		                months = Math.abs(this.months()),
		                days = Math.abs(this.days()),
		                hours = Math.abs(this.hours()),
		                minutes = Math.abs(this.minutes()),
		                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
		
		            if (!this.asSeconds()) {
		                // this is the same as C#'s (Noda) and python (isodate)...
		                // but not other JS (goog.date)
		                return 'P0D';
		            }
		
		            return (this.asSeconds() < 0 ? '-' : '') +
		                'P' +
		                (years ? years + 'Y' : '') +
		                (months ? months + 'M' : '') +
		                (days ? days + 'D' : '') +
		                ((hours || minutes || seconds) ? 'T' : '') +
		                (hours ? hours + 'H' : '') +
		                (minutes ? minutes + 'M' : '') +
		                (seconds ? seconds + 'S' : '');
		        }
		    });
		
		    function makeDurationGetter(name) {
		        moment.duration.fn[name] = function () {
		            return this._data[name];
		        };
		    }
		
		    function makeDurationAsGetter(name, factor) {
		        moment.duration.fn['as' + name] = function () {
		            return +this / factor;
		        };
		    }
		
		    for (i in unitMillisecondFactors) {
		        if (unitMillisecondFactors.hasOwnProperty(i)) {
		            makeDurationAsGetter(i, unitMillisecondFactors[i]);
		            makeDurationGetter(i.toLowerCase());
		        }
		    }
		
		    makeDurationAsGetter('Weeks', 6048e5);
		    moment.duration.fn.asMonths = function () {
		        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
		    };
		
		
		    /************************************
		        Default Lang
		    ************************************/
		
		
		    // Set default language, other languages will inherit from English.
		    moment.lang('en', {
		        ordinal : function (number) {
		            var b = number % 10,
		                output = (toInt(number % 100 / 10) === 1) ? 'th' :
		                (b === 1) ? 'st' :
		                (b === 2) ? 'nd' :
		                (b === 3) ? 'rd' : 'th';
		            return number + output;
		        }
		    });
		
		    /* EMBED_LANGUAGES */
		
		    /************************************
		        Exposing Moment
		    ************************************/
		
		    function makeGlobal(deprecate) {
		        var warned = false, local_moment = moment;
		        /*global ender:false */
		        if (typeof ender !== 'undefined') {
		            return;
		        }
		        // here, `this` means `window` in the browser, or `global` on the server
		        // add `moment` as a global object via a string identifier,
		        // for Closure Compiler "advanced" mode
		        if (deprecate) {
		            global.moment = function () {
		                if (!warned && console && console.warn) {
		                    warned = true;
		                    console.warn(
		                            "Accessing Moment through the global scope is " +
		                            "deprecated, and will be removed in an upcoming " +
		                            "release.");
		                }
		                return local_moment.apply(null, arguments);
		            };
		            extend(global.moment, local_moment);
		        } else {
		            global['moment'] = moment;
		        }
		    }
		
		    // CommonJS module is defined
		    if (hasModule) {
		        module.exports = moment;
		        makeGlobal(true);
		    } else if (typeof define === "function" && define.amd) {
		        define("moment", function (require, exports, module) {
		            if (module.config && module.config() && module.config().noGlobal !== true) {
		                // If user provided noGlobal, he is aware of global
		                makeGlobal(module.config().noGlobal === undefined);
		            }
		
		            return moment;
		        });
		    } else {
		        makeGlobal();
		    }
		}).call(this);
		
	
	}, 'cache-storage/Storage/Storage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/Storage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/Storage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/Storage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/Storage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/Storage');
	
	}, 'normalize-arguments/lib/Args.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'normalize-arguments/lib/Args.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'normalize-arguments/lib/Args.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'normalize-arguments/lib/Args.js';
		var __dirname = 'normalize-arguments/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', 'normalize-arguments/lib/Args.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var args, count, emptyArgument, expandArguments, exportFunc, fn, isFunction, name, type, types;
		
		  types = {
		    string: '[object String]',
		    number: '[object Number]',
		    'boolean': '[object Boolean]',
		    array: '[object Array]',
		    object: '[object Object]',
		    fn: '[object Function]'
		  };
		
		  exportFunc = {
		    string: function(d) {
		      return {
		        type: 'string',
		        d: d
		      };
		    },
		    number: function(d) {
		      return {
		        type: 'number',
		        d: d
		      };
		    },
		    'boolean': function(d) {
		      return {
		        type: 'boolean',
		        d: d
		      };
		    },
		    array: function(d) {
		      return {
		        type: 'array',
		        d: d
		      };
		    },
		    object: function(d) {
		      return {
		        type: 'object',
		        d: d
		      };
		    },
		    any: function(d) {
		      return {
		        type: 'any',
		        d: d
		      };
		    },
		    fn: function(d) {
		      return {
		        type: 'fn',
		        d: d
		      };
		    },
		    oneOf: function(list, d) {
		      var i, readable, t, type, _i, _len;
		      if (d == null) {
		        d = null;
		      }
		      readable = [];
		      for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
		        type = list[i];
		        t = type().type;
		        list[i] = types[t];
		        readable.push(t);
		      }
		      return {
		        type: 'oneOf',
		        d: d,
		        dCalled: arguments.length === 2,
		        types: list,
		        readable: readable
		      };
		    }
		  };
		
		  emptyArgument = {};
		
		  type = Object.prototype.toString;
		
		  isFunction = function(v) {
		    return type.call(v) === '[object Function]';
		  };
		
		  count = function(num) {
		    switch (num) {
		      case 1:
		        return 'st';
		      case 2:
		        return 'nd';
		      case 3:
		        return 'rd';
		      default:
		        return 'th';
		    }
		  };
		
		  expandArguments = function(params, expected) {
		    var actual, e, i, _i, _len;
		    if (params == null) {
		      params = [];
		    }
		    if (expected == null) {
		      expected = [];
		    }
		    for (i = _i = 0, _len = expected.length; _i < _len; i = ++_i) {
		      e = expected[i];
		      if (isFunction(e)) {
		        e = e();
		      }
		      actual = type.call(params[i]);
		      if (params[i] !== null && e.type !== 'any' && ((e.type === 'oneOf' && e.types.indexOf(actual) === -1) || (e.type !== 'oneOf' && types[e.type] !== actual))) {
		        params.splice(i, 0, emptyArgument);
		      }
		    }
		    return params;
		  };
		
		  args = function(params, expected) {
		    var e, expect, fn, i, last, must, num, param, _i, _len;
		    if (params == null) {
		      params = [];
		    }
		    if (expected == null) {
		      expected = [];
		    }
		    if (type.call(params) === '[object Arguments]') {
		      params = Array.prototype.slice.call(params);
		    }
		    params = expandArguments(params, expected);
		    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
		      param = params[i];
		      expect = null;
		      e = expected[i];
		      if (typeof e !== 'undefined') {
		        expect = isFunction(e) ? e().type : e.type;
		      }
		      if (param === emptyArgument) {
		        fn = isFunction(e);
		        if (fn || (!fn && e.type === 'oneOf' && e.dCalled === false)) {
		          if (fn) {
		            must = e().type;
		          } else {
		            if (e.readable.length === 1) {
		              must = e.readable[0];
		            } else {
		              last = e.readable.pop();
		              must = e.readable.join(', ') + ' or ' + last;
		            }
		          }
		          num = i + 1;
		          throw new Error(num + count(num) + ' argument must be ' + must);
		        }
		        params[i] = e.d;
		      }
		    }
		    return params;
		  };
		
		  for (name in exportFunc) {
		    fn = exportFunc[name];
		    args[name] = fn;
		  }
		
		  module.exports = args;
		
		}).call(this);
		
	
	}, '/lib/pluralForms.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/pluralForms.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/pluralForms.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/pluralForms.json';
		var __dirname = '/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/pluralForms.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"ach": {"count": 2, "form": "(n > 1)"},
			"af": {"count": 2, "form": "(n != 1)"},
			"ak": {"count": 2, "form": "(n > 1)"},
			"am": {"count": 2, "form": "(n > 1)"},
			"an": {"count": 2, "form": "(n != 1)"},
			"ar": {"count": 2, "form": "(n==0 ? 0 : (n==1 ? 1 : (n==2 ? 2 : (n%100>=3 && n%100<=10 ? 3 : (n%100>=11 ? 4 : 5)))))"},
			"arn": {"count": 2, "form": "(n > 1)"},
			"ast": {"count": 2, "form": "(n != 1)"},
			"ay": {"count": 2, "form": "0"},
			"az": {"count": 2, "form": "(n != 1)"},
		
			"be": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"bg": {"count": 2, "form": "(n != 1)"},
			"bn": {"count": 2, "form": "(n != 1)"},
			"bo": {"count": 1, "form": "0"},
			"br": {"count": 2, "form": "(n > 1)"},
			"brx": {"count": 2, "form": "(n != 1)"},
			"bs": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
		
			"ca": {"count": 2, "form": "(n != 1)"},
			"cgg": {"count": 1, "form": "0"},
			"cs": {"count": 3, "form": "(n==1) ? 0 : ((n>=2 && n<=4) ? 1 : 2)"},
			"csb": {"count": 4, "form": "n==1 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)"},
			"cy": {"count": 4, "form": "(n==1) ? 0 : ((n==2) ? 1 : ((n != 8 && n != 11) ? 2 : 3))"},
		
			"da": {"count": 2, "form": "(n != 1)"},
			"de": {"count": 2, "form": "(n != 1)"},
			"doi": {"count": 2, "form": "(n != 1)"},
			"dz": {"count": 1, "form": "0"},
		
			"el": {"count": 2, "form": "(n != 1)"},
			"en": {"count": 2, "form": "(n != 1)"},
			"eo": {"count": 2, "form": "(n != 1)"},
			"es": {"count": 2, "form": "(n != 1)"},
			"es_AR": {"count": 2, "form": "(n != 1)"},
			"et": {"count": 2, "form": "(n != 1)"},
			"eu": {"count": 2, "form": "(n != 1)"},
		
			"fa": {"count": 1, "form": "0"},
			"ff": {"count": 2, "form": "(n != 1)"},
			"fi": {"count": 2, "form": "(n != 1)"},
			"fil": {"count": 2, "form": "(n > 1)"},
			"fo": {"count": 2, "form": "(n != 1)"},
			"fr": {"count": 2, "form": "(n > 1)"},
			"fur": {"count": 2, "form": "(n != 1)"},
			"fy": {"count": 2, "form": "(n != 1)"},
		
			"ga": {"count": 5, "form": "n==1 ? 0 : (n==2 ? 1 : (n<7 ? 2 : (n<11 ? 3 : 4)))"},
			"gd": {"count": 4, "form": "(n==1 || n==11) ? 0 : ((n==2 || n==12) ? 1 : ((n > 2 && n < 20) ? 2 : 3))"},
			"gl": {"count": 2, "form": "(n != 1)"},
			"gu": {"count": 2, "form": "(n != 1)"},
			"gun": {"count": 2, "form": "(n > 1)"},
		
			"ha": {"count": 2, "form": "(n != 1)"},
			"he": {"count": 2, "form": "(n != 1)"},
			"hi": {"count": 2, "form": "(n != 1)"},
			"hne": {"count": 2, "form": "(n != 1)"},
			"hy": {"count": 2, "form": "(n != 1)"},
			"hr": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"hu": {"count": 2, "form": "(n != 1)"},
		
			"ia": {"count": 2, "form": "(n != 1)"},
			"id": {"count": 1, "form": "0"},
			"is": {"count": 2, "form": "(n%10!=1 || n%100==11)"},
			"it": {"count": 2, "form": "(n != 1)"},
		
			"ja": {"count": 1, "form": "0"},
			"jbo": {"count": 1, "form": "0"},
			"jv": {"count": 2, "form": "(n != 0)"},
		
			"ka": {"count": 1, "form": "0"},
			"kk": {"count": 1, "form": "0"},
			"km": {"count": 1, "form": "0"},
			"kn": {"count": 2, "form": "(n != 1)"},
			"ko": {"count": 1, "form": "0"},
			"ku": {"count": 2, "form": "(n != 1)"},
			"kw": {"count": 4, "form": "(n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3"},
			"ky": {"count": 1, "form": "0"},
		
			"lb": {"count": 2, "form": "(n != 1)"},
			"ln": {"count": 2, "form": "(n > 1)"},
			"lo": {"count": 1, "form": "0"},
			"lt": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && (n%100<10 or n%100>=20) ? 1 : 2))"},
			"lv": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n != 0 ? 1 : 2))"},
		
			"mai": {"count": 2, "form": "(n != 1)"},
			"mfe": {"count": 2, "form": "(n > 1)"},
			"mg": {"count": 2, "form": "(n > 1)"},
			"mi": {"count": 2, "form": "(n > 1)"},
			"ml": {"count": 2, "form": "(n != 1)"},
			"mn": {"count": 2, "form": "(n != 1)"},
			"mni": {"count": 2, "form": "(n != 1)"},
			"mnk": {"count": 3, "form": "(n==0 ? 0 : (n==1 ? 1 : 2))"},
			"mr": {"count": 2, "form": "(n != 1)"},
			"ms": {"count": 1, "form": "0"},
			"mt": {"count": 4, "form": "(n==1 ? 0 : (n==0 || ( n%100>1 && n%100<11) ? 1 : ((n%100>10 && n%100<20 ) ? 2 : 3)))"},
			"my": {"count": 1, "form": "0"},
		
			"nah": {"count": 2, "form": "(n != 1)"},
			"nap": {"count": 2, "form": "(n != 1)"},
			"nb": {"count": 2, "form": "(n != 1)"},
			"ne": {"count": 2, "form": "(n != 1)"},
			"nl": {"count": 2, "form": "(n != 1)"},
			"se": {"count": 2, "form": "(n != 1)"},
			"nn": {"count": 2, "form": "(n != 1)"},
			"no": {"count": 2, "form": "(n != 1)"},
			"nso": {"count": 2, "form": "(n != 1)"},
		
			"oc": {"count": 2, "form": "(n > 1)"},
			"or": {"count": 2, "form": "(n != 1)"},
		
			"ps": {"count": 2, "form": "(n != 1)"},
			"pa": {"count": 2, "form": "(n != 1)"},
			"pap": {"count": 2, "form": "(n != 1)"},
			"pl": {"count": 3, "form": "(n==1 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"pms": {"count": 2, "form": "(n != 1)"},
			"pt": {"count": 2, "form": "(n != 1)"},
			"pt_BR": {"count": 2, "form": "(n != 1)"},
		
			"rm": {"count": 2, "form": "(n != 1)"},
			"ro": {"count": 3, "form": "(n==1 ? 0 : ((n==0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2))"},
			"ru": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"rw": {"count": 2, "form": "(n != 1)"},
		
			"sah": {"count": 1, "form": "0"},
			"sat": {"count": 2, "form": "(n != 1)"},
			"sco": {"count": 2, "form": "(n != 1)"},
			"sd": {"count": 2, "form": "(n != 1)"},
			"si": {"count": 2, "form": "(n != 1)"},
			"sk": {"count": 3, "form": "(n==1) ? 0 : ((n>=2 && n<=4) ? 1 : 2)"},
			"sl": {"count": 4, "form": "(n%100==1 ? 1 : (n%100==2 ? 2 : (n%100==3 || n%100==4 ? 3 : 0)))"},
			"so": {"count": 2, "form": "(n != 1)"},
			"son": {"count": 2, "form": "(n != 1)"},
			"sq": {"count": 2, "form": "(n != 1)"},
			"sr": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"su": {"count": 1, "form": "0"},
			"sw": {"count": 2, "form": "(n != 1)"},
			"sv": {"count": 2, "form": "(n != 1)"},
		
			"ta": {"count": 2, "form": "(n != 1)"},
			"te": {"count": 2, "form": "(n != 1)"},
			"tg": {"count": 2, "form": "(n > 1)"},
			"ti": {"count": 2, "form": "(n > 1)"},
			"th": {"count": 1, "form": "0"},
			"tk": {"count": 2, "form": "(n != 1)"},
			"tr": {"count": 2, "form": "(n > 1)"},
			"tt": {"count": 1, "form": "0"},
		
			"ug": {"count": 1, "form": "0"},
			"uk": {"count": 3, "form": "(n%10==1 && n%100!=11 ? 0 : (n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2))"},
			"ur": {"count": 2, "form": "(n != 1)"},
			"uz": {"count": 2, "form": "(n > 1)"},
		
			"vi": {"count": 1, "form": "0"},
		
			"wa": {"count": 2, "form": "(n > 1)"},
			"wo": {"count": 1, "form": "0"},
		
			"yo": {"count": 2, "form": "(n != 1)"},
		
			"zh": {"count": 1, "form": "0"}
		}
		}).call(this);
		
	
	}, '/lib/Loaders/Json.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/Loaders/Json.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Loaders/Json.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/Loaders/Json.js';
		var __dirname = '/lib/Loaders';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Loaders/Json.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Json, Loader, callsite, isWindow, path,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Loader = require('./Loader');
		
		  path = require('../node/path');
		
		  isWindow = typeof window !== 'undefined';
		
		  if (!isWindow) {
		    callsite = require('callsite');
		  }
		
		  Json = (function(_super) {
		    __extends(Json, _super);
		
		    Json.prototype.directory = '/app/lang';
		
		    function Json(directory) {
		      var stack;
		      this.directory = directory != null ? directory : this.directory;
		      if (this.directory.charAt(0) === '.' && isWindow) {
		        throw new Error('Relative paths to dictionaries is not supported in browser.');
		      }
		      if (this.directory.charAt(0) === '.') {
		        stack = callsite();
		        this.directory = path.dirname(stack[1].getFileName());
		      }
		      if (!isWindow) {
		        this.directory = path.normalize(this.directory);
		      }
		    }
		
		    Json.prototype.load = function(parent, name, language) {
		      var data, e, _path;
		      _path = this.getFileSystemPath(parent, name, language);
		      try {
		        data = require(_path);
		      } catch (_error) {
		        e = _error;
		        data = {};
		      }
		      return data;
		    };
		
		    Json.prototype.getFileSystemPath = function(parent, name, language) {
		      return this.directory + (parent !== '' ? '/' + parent : '') + ("/" + language + "." + name + ".json");
		    };
		
		    return Json;
		
		  })(Loader);
		
		  module.exports = Json;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/BrowserLocalStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/BrowserLocalStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/BrowserLocalStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/BrowserLocalStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/BrowserLocalStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var BrowserLocalStorage, Cache, Storage,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  Cache = require('../Cache');
		
		  BrowserLocalStorage = (function(_super) {
		    __extends(BrowserLocalStorage, _super);
		
		    BrowserLocalStorage.TEST_VALUE = '__--cache-storage--__';
		
		    BrowserLocalStorage.prototype.allData = null;
		
		    BrowserLocalStorage.prototype.data = null;
		
		    BrowserLocalStorage.prototype.meta = null;
		
		    function BrowserLocalStorage() {
		      if (!BrowserLocalStorage.isSupported()) {
		        throw new Error('Cache storage: Local storage is not supported');
		      }
		    }
		
		    BrowserLocalStorage.isSupported = function() {
		      var e;
		      try {
		        localStorage.setItem(BrowserLocalStorage.TEST_VALUE, BrowserLocalStorage.TEST_VALUE);
		        localStorage.getItem(BrowserLocalStorage.TEST_VALUE);
		        return true;
		      } catch (_error) {
		        e = _error;
		        return false;
		      }
		    };
		
		    BrowserLocalStorage.prototype.getName = function() {
		      return '__' + this.cache.namespace;
		    };
		
		    BrowserLocalStorage.prototype.loadData = function() {
		      var data;
		      if (this.allData === null) {
		        data = localStorage.getItem(this.getName());
		        if (data === null) {
		          this.allData = {
		            data: {},
		            meta: {}
		          };
		        } else {
		          this.allData = JSON.parse(data);
		        }
		      }
		      return this.allData;
		    };
		
		    BrowserLocalStorage.prototype.getData = function() {
		      if (this.data === null) {
		        this.data = this.loadData().data;
		      }
		      return this.data;
		    };
		
		    BrowserLocalStorage.prototype.getMeta = function() {
		      if (this.meta === null) {
		        this.meta = this.loadData().meta;
		      }
		      return this.meta;
		    };
		
		    BrowserLocalStorage.prototype.writeData = function(data, meta) {
		      this.data = data;
		      this.meta = meta;
		      localStorage.setItem(this.getName(), JSON.stringify({
		        data: this.data,
		        meta: this.meta
		      }));
		      return this;
		    };
		
		    return BrowserLocalStorage;
		
		  })(Storage);
		
		  module.exports = BrowserLocalStorage;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/DevNullStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/DevNullStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/DevNullStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/DevNullStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/DevNullStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var DevNullStorage, Storage, _ref,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  DevNullStorage = (function(_super) {
		    __extends(DevNullStorage, _super);
		
		    function DevNullStorage() {
		      _ref = DevNullStorage.__super__.constructor.apply(this, arguments);
		      return _ref;
		    }
		
		    DevNullStorage.prototype.getData = function() {
		      return {};
		    };
		
		    DevNullStorage.prototype.getMeta = function() {
		      return {};
		    };
		
		    DevNullStorage.prototype.writeData = function(data, meta) {
		      return this;
		    };
		
		    DevNullStorage.prototype.read = function(key) {
		      return null;
		    };
		
		    DevNullStorage.prototype.write = function(key, data, dependencies) {
		      if (dependencies == null) {
		        dependencies = {};
		      }
		      return this;
		    };
		
		    DevNullStorage.prototype.remove = function(key) {
		      return this;
		    };
		
		    return DevNullStorage;
		
		  })(Storage);
		
		  module.exports = DevNullStorage;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/FileStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/FileStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/FileStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/FileStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/FileStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Cache, FileStorage, Storage, fs, path,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  Cache = require('../Cache');
		
		  fs = null;
		
		  path = null;
		
		  FileStorage = (function(_super) {
		    __extends(FileStorage, _super);
		
		    FileStorage.prototype.directory = null;
		
		    FileStorage.prototype.allData = null;
		
		    FileStorage.prototype.data = null;
		
		    FileStorage.prototype.meta = null;
		
		    function FileStorage(directory) {
		      this.directory = directory;
		      if (typeof window !== 'undefined') {
		        throw new Error('FileStorage: Can not use this storage in browser');
		      }
		      fs = require('fs');
		      path = require('path');
		      this.directory = path.resolve(this.directory);
		      if (!fs.existsSync(this.directory)) {
		        throw new Error('FileStorage: directory ' + this.directory + ' does not exists');
		      }
		      if (!fs.statSync(this.directory).isDirectory()) {
		        throw new Error('FileStorage: path ' + this.directory + ' must be directory');
		      }
		    }
		
		    FileStorage.prototype.getFileName = function() {
		      return this.directory + '/__' + this.cache.namespace + '.json';
		    };
		
		    FileStorage.prototype.loadData = function() {
		      var file;
		      if (this.allData === null) {
		        file = this.getFileName();
		        if (fs.existsSync(file)) {
		          this.allData = JSON.parse(fs.readFileSync(file, {
		            encoding: 'utf8'
		          }));
		        } else {
		          this.allData = {
		            data: {},
		            meta: {}
		          };
		        }
		      }
		      return this.allData;
		    };
		
		    FileStorage.prototype.getData = function() {
		      if (this.data === null) {
		        this.data = this.loadData().data;
		      }
		      return this.data;
		    };
		
		    FileStorage.prototype.getMeta = function() {
		      if (this.meta === null) {
		        this.meta = this.loadData().meta;
		      }
		      return this.meta;
		    };
		
		    FileStorage.prototype.writeData = function(data, meta) {
		      var file;
		      this.data = data;
		      this.meta = meta;
		      file = this.getFileName();
		      fs.writeFileSync(file, JSON.stringify({
		        data: this.data,
		        meta: this.meta
		      }));
		      return this;
		    };
		
		    return FileStorage;
		
		  })(Storage);
		
		  module.exports = FileStorage;
		
		}).call(this);
		
	
	}, 'cache-storage/lib/Storage/MemoryStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/lib/Storage/MemoryStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/lib/Storage/MemoryStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/lib/Storage/MemoryStorage.js';
		var __dirname = 'cache-storage/lib/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/lib/Storage/MemoryStorage.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var MemoryStorage, Storage, _ref,
		    __hasProp = {}.hasOwnProperty,
		    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
		
		  Storage = require('./Storage');
		
		  MemoryStorage = (function(_super) {
		    __extends(MemoryStorage, _super);
		
		    function MemoryStorage() {
		      _ref = MemoryStorage.__super__.constructor.apply(this, arguments);
		      return _ref;
		    }
		
		    MemoryStorage.prototype.data = null;
		
		    MemoryStorage.prototype.meta = null;
		
		    MemoryStorage.prototype.getData = function() {
		      if (this.data === null) {
		        this.data = {};
		      }
		      return this.data;
		    };
		
		    MemoryStorage.prototype.getMeta = function() {
		      if (this.meta === null) {
		        this.meta = {};
		      }
		      return this.meta;
		    };
		
		    MemoryStorage.prototype.writeData = function(data, meta) {
		      this.data = data;
		      this.meta = meta;
		      return this;
		    };
		
		    return MemoryStorage;
		
		  })(Storage);
		
		  module.exports = MemoryStorage;
		
		}).call(this);
		
	
	}, '/lib/Translator.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/lib/Translator.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Translator.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/lib/Translator.js';
		var __dirname = '/lib';
		var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Translator.js'], env: {}};
	
		/** code **/
		// Generated by CoffeeScript 1.6.3
		(function() {
		  var Args, Cache, JsonLoader, Loader, Storage, Translator, callsite, isWindow, path, pluralForms;
		
		  Cache = require('cache-storage');
		
		  Storage = require('cache-storage/Storage/Storage');
		
		  Args = require('normalize-arguments');
		
		  path = require('./node/path');
		
		  pluralForms = require('./pluralForms');
		
		  Loader = require('./Loaders/Loader');
		
		  JsonLoader = require('./Loaders/Json');
		
		  isWindow = typeof window !== 'undefined';
		
		  if (!isWindow) {
		    callsite = require('callsite');
		  }
		
		  Translator = (function() {
		    Translator.prototype.loader = null;
		
		    Translator.prototype.language = null;
		
		    Translator.prototype.plurals = null;
		
		    Translator.prototype.replacements = null;
		
		    Translator.prototype.data = null;
		
		    Translator.prototype.cache = null;
		
		    function Translator(pathOrLoader) {
		      var configPath, data, language, stack;
		      this.plurals = {};
		      this.replacements = {};
		      this.data = {};
		      if (!pathOrLoader) {
		        throw new Error('You have to set path to base directory or to config file or loader.');
		      }
		      if (typeof pathOrLoader === 'string') {
		        if (pathOrLoader.charAt(0) === '.' && isWindow) {
		          throw new Error('Relative paths to dictionaries is not supported in browser.');
		        }
		        if (pathOrLoader.charAt(0) === '.') {
		          stack = callsite();
		          pathOrLoader = path.join(path.dirname(stack[1].getFileName()), pathOrLoader);
		        }
		        pathOrLoader = path.normalize(pathOrLoader);
		        if (pathOrLoader.match(/\.json$/) !== null) {
		          configPath = pathOrLoader;
		          pathOrLoader = require(configPath).path;
		          if (pathOrLoader.charAt(0) === '.') {
		            pathOrLoader = path.join(path.dirname(configPath), pathOrLoader);
		          }
		        }
		        pathOrLoader = new JsonLoader(pathOrLoader);
		      }
		      this.setLoader(pathOrLoader);
		      for (language in pluralForms) {
		        data = pluralForms[language];
		        this.addPluralForm(language, data.count, data.form);
		      }
		    }
		
		    Translator.prototype.setLoader = function(loader) {
		      if (!(loader instanceof Loader)) {
		        throw new Error('Loader must be an instance of translator/Loaders/Loader.');
		      }
		      return this.loader = loader;
		    };
		
		    Translator.prototype.invalidate = function() {
		      return this.data = {};
		    };
		
		    Translator.prototype.setCacheStorage = function(cacheStorage) {
		      if (!cacheStorage instanceof Storage) {
		        throw new Error('Cache storage must be an instance of cache-storage/Storage/Storage.');
		      }
		      return this.cache = new Cache(cacheStorage, 'translator');
		    };
		
		    Translator.prototype.addPluralForm = function(language, count, form) {
		      this.plurals[language] = {
		        count: count,
		        form: form
		      };
		      return this;
		    };
		
		    Translator.prototype.addReplacement = function(search, replacement) {
		      this.replacements[search] = replacement;
		      return this;
		    };
		
		    Translator.prototype.removeReplacement = function(search) {
		      if (typeof this.replacements[search] === 'undefined') {
		        throw new Error('Replacement ' + search + ' was not found.');
		      }
		      delete this.replacements[search];
		      return this;
		    };
		
		    Translator.prototype.loadCategory = function(_path, name) {
		      var categoryName, conds, data, file;
		      categoryName = _path + '/' + name;
		      if (typeof this.data[categoryName] === 'undefined') {
		        if (this.cache === null) {
		          data = this.loader.load(_path, name, this.language);
		          data = this.normalizeTranslations(data);
		        } else {
		          data = this.cache.load(this.language + ':' + categoryName);
		          if (data === null) {
		            data = this.loader.load(_path, name, this.language);
		            data = this.normalizeTranslations(data);
		            conds = {};
		            if (typeof window === 'undefined' || (typeof window !== 'undefined' && window.require.simq === true && typeof window.require.version !== 'undefined' && parseInt(window.require.version.replace(/\./g, '')) >= 510)) {
		              _path = this.loader.getFileSystemPath(_path, name, this.language);
		              if (_path !== null) {
		                conds.files = [_path];
		              }
		            }
		            this.cache.save(this.language + ':' + categoryName, data, conds);
		          } else {
		            file = this.loader.load(_path, name, this.language);
		            data = this.normalizeTranslations(file);
		          }
		        }
		        this.data[categoryName] = data;
		      }
		      return this.data[categoryName];
		    };
		
		    Translator.prototype.normalizeTranslations = function(translations) {
		      var buf, list, match, name, result, sub, t, translation, _i, _j, _len, _len1;
		      result = {};
		      for (name in translations) {
		        translation = translations[name];
		        list = false;
		        if ((match = name.match(/^--\s(.*)/)) !== null) {
		          name = match[1];
		          list = true;
		        }
		        if (typeof translation === 'string') {
		          result[name] = [translation];
		        } else if (Object.prototype.toString.call(translation) === '[object Array]') {
		          result[name] = [];
		          for (_i = 0, _len = translation.length; _i < _len; _i++) {
		            t = translation[_i];
		            if (typeof t === 'object') {
		              buf = [];
		              for (_j = 0, _len1 = t.length; _j < _len1; _j++) {
		                sub = t[_j];
		                if (/^\#.*\#$/.test(sub) === false) {
		                  buf.push(sub);
		                }
		              }
		              result[name].push(buf);
		            } else {
		              if (/^\#.*\#$/.test(t) === false) {
		                if (list === true && typeof t !== 'object') {
		                  t = [t];
		                }
		                result[name].push(t);
		              }
		            }
		          }
		        }
		      }
		      return result;
		    };
		
		    Translator.prototype.findTranslation = function(message) {
		      var data, info;
		      info = this.getMessageInfo(message);
		      data = this.loadCategory(info.path, info.category);
		      if (typeof data[info.name] === 'undefined') {
		        return null;
		      } else {
		        return data[info.name];
		      }
		    };
		
		    Translator.prototype.translate = function(message, count, args) {
		      var match, num, params, translation;
		      if (count == null) {
		        count = null;
		      }
		      if (args == null) {
		        args = {};
		      }
		      if (this.language === null) {
		        throw new Error('You have to set language');
		      }
		      params = Args(arguments, [Args.any, Args.number(null), Args.object({})]);
		      message = params[0];
		      count = params[1];
		      args = params[2];
		      if (typeof message !== 'string') {
		        return message;
		      }
		      if (count !== null) {
		        args.count = count;
		      }
		      if ((match = message.match(/^\:(.*)\:$/)) !== null) {
		        message = match[1];
		      } else {
		        num = null;
		        if ((match = message.match(/(.+)\[(\d+)\]$/)) !== null) {
		          message = match[1];
		          num = parseInt(match[2]);
		        }
		        message = this.applyReplacements(message, args);
		        translation = this.findTranslation(message);
		        if (num !== null) {
		          if (!this.isList(translation)) {
		            throw new Error('Translation ' + message + ' is not a list.');
		          }
		          if (typeof translation[num] === 'undefined') {
		            throw new Error('Item ' + num + ' was not found in ' + message + ' translation.');
		          }
		          translation = translation[num];
		        }
		        if (translation !== null) {
		          message = this.pluralize(message, translation, count);
		        }
		      }
		      message = this.prepareTranslation(message, args);
		      return message;
		    };
		
		    Translator.prototype.translatePairs = function(message, key, value, count, args) {
		      var i, k, result, _i, _len;
		      if (count == null) {
		        count = null;
		      }
		      if (args == null) {
		        args = {};
		      }
		      key = "" + message + "." + key;
		      value = "" + message + "." + value;
		      key = this.translate(key, count, args);
		      value = this.translate(value, count, args);
		      if (Object.prototype.toString.call(key) !== '[object Array]' || Object.prototype.toString.call(value) !== '[object Array]') {
		        throw new Error('Translations are not arrays.');
		      }
		      if (key.length !== value.length) {
		        throw new Error('Keys and values translations have not got the same length.');
		      }
		      result = {};
		      for (i = _i = 0, _len = key.length; _i < _len; i = ++_i) {
		        k = key[i];
		        result[k] = value[i];
		      }
		      return result;
		    };
		
		    Translator.prototype.translateMap = function(list, count, args, base) {
		      var i, k, m, params, type, _i, _len;
		      if (count == null) {
		        count = null;
		      }
		      if (args == null) {
		        args = {};
		      }
		      if (base == null) {
		        base = null;
		      }
		      type = Object.prototype.toString.call(list);
		      if (type !== '[object Array]' && type !== '[object Object]') {
		        throw new Error('Translate map is only for arrays and objects.');
		      }
		      params = Args(arguments, [Args.oneOf([Args.array, Args.object]), Args.number(null), Args.object({}), Args.string(null)]);
		      list = params[0];
		      count = params[1];
		      args = params[2];
		      base = params[3];
		      base = base !== null ? base + '.' : '';
		      if (type === '[object Array]') {
		        for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
		          m = list[i];
		          list[i] = this.translate(base + m, count, args);
		        }
		      } else {
		        for (k in list) {
		          m = list[k];
		          list[k] = this.translate(base + m, count, args);
		        }
		      }
		      return list;
		    };
		
		    Translator.prototype.isList = function(translation) {
		      return Object.prototype.toString.call(translation[0]) === '[object Array]';
		    };
		
		    Translator.prototype.pluralize = function(message, translation, count) {
		      var n, plural, pluralForm, result, t, _i, _j, _len, _len1;
		      if (count == null) {
		        count = null;
		      }
		      if (count !== null) {
		        if (typeof translation[0] === 'string') {
		          pluralForm = 'n=' + count + ';plural=+(' + this.plurals[this.language].form + ');';
		          n = null;
		          plural = null;
		          eval(pluralForm);
		          message = plural !== null && typeof translation[plural] !== 'undefined' ? translation[plural] : translation[0];
		        } else {
		          result = [];
		          for (_i = 0, _len = translation.length; _i < _len; _i++) {
		            t = translation[_i];
		            result.push(this.pluralize(message, t, count));
		          }
		          message = result;
		        }
		      } else {
		        if (typeof translation[0] === 'string') {
		          message = translation[0];
		        } else {
		          message = [];
		          for (_j = 0, _len1 = translation.length; _j < _len1; _j++) {
		            t = translation[_j];
		            message.push(t[0]);
		          }
		        }
		      }
		      return message;
		    };
		
		    Translator.prototype.prepareTranslation = function(message, args) {
		      var m, result, _i, _len;
		      if (args == null) {
		        args = {};
		      }
		      if (typeof message === 'string') {
		        message = this.applyReplacements(message, args);
		      } else {
		        result = [];
		        for (_i = 0, _len = message.length; _i < _len; _i++) {
		          m = message[_i];
		          result.push(this.prepareTranslation(m, args));
		        }
		        message = result;
		      }
		      return message;
		    };
		
		    Translator.prototype.applyReplacements = function(message, args) {
		      var name, pattern, replacements, value;
		      if (args == null) {
		        args = {};
		      }
		      replacements = this.replacements;
		      for (name in args) {
		        value = args[name];
		        replacements[name] = value;
		      }
		      for (name in replacements) {
		        value = replacements[name];
		        if (value !== false) {
		          pattern = new RegExp('%' + name + '%', 'g');
		          message = message.replace(pattern, value);
		        }
		      }
		      return message;
		    };
		
		    Translator.prototype.getMessageInfo = function(message) {
		      var category, name, num, result, _path;
		      num = message.lastIndexOf('.');
		      _path = message.substr(0, num);
		      name = message.substr(num + 1);
		      num = _path.lastIndexOf('.');
		      category = _path.substr(num + 1);
		      _path = _path.substr(0, num).replace(/\./g, '/');
		      result = {
		        path: _path,
		        category: category,
		        name: name
		      };
		      return result;
		    };
		
		    return Translator;
		
		  })();
		
		  module.exports = Translator;
		
		}).call(this);
		
	
	}, '/test/browser/tests/Translator.coffee': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/browser/tests/Translator.coffee');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Translator.coffee';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/browser/tests/Translator.coffee';
		var __dirname = '/test/browser/tests';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Translator.coffee'], env: {}};
	
		/** code **/
		(function() {
		  var BrowserLocalStorage, Cache, Translator, dir, translator;
		
		  Translator = require('/lib/Translator');
		
		  BrowserLocalStorage = require('cache-storage/Storage/BrowserLocalStorage');
		
		  Cache = require('cache-storage');
		
		  dir = '/test/data';
		
		  translator = null;
		
		  describe('Translator', function() {
		    beforeEach(function() {
		      translator = new Translator(dir);
		      return translator.language = 'en';
		    });
		    afterEach(function() {
		      return translator = null;
		    });
		    describe('#constructor()', function() {
		      it('should contain some plural forms', function() {
		        return expect(translator.plurals).not.to.be.eql({});
		      });
		      return it('should create translator from path in config file', function() {
		        translator = new Translator(dir + '/config.json');
		        return expect(translator.loader.directory).to.be.equal(dir);
		      });
		    });
		    describe('#normalizeTranslations()', function() {
		      it('should return normalized object with dictionary', function() {
		        return expect(translator.normalizeTranslations({
		          car: 'car',
		          bus: ['bus']
		        })).to.be.eql({
		          car: ['car'],
		          bus: ['bus']
		        });
		      });
		      it('should return normalized translations without comments', function() {
		        return expect(translator.normalizeTranslations({
		          one: ['# hello #', 'car', '# house #', 'something']
		        })).to.be.eql({
		          one: ['car', 'something']
		        });
		      });
		      it('should return normalized translations for list with comments', function() {
		        return expect(translator.normalizeTranslations({
		          one: [['first'], '# comment #', ['second', '# comment #'], ['third']]
		        })).to.be.eql({
		          one: [['first'], ['second'], ['third']]
		        });
		      });
		      return it('should return normalized translations for list with new syntax', function() {
		        return expect(translator.normalizeTranslations({
		          '-- list': ['first', 'second', 'third']
		        })).to.be.eql({
		          list: [['first'], ['second'], ['third']]
		        });
		      });
		    });
		    describe('#getMessageInfo()', function() {
		      return it('should return information about dictionary from message to translate', function() {
		        return expect(translator.getMessageInfo('web.pages.homepage.promo.title')).to.be.eql({
		          path: 'web/pages/homepage',
		          category: 'promo',
		          name: 'title'
		        });
		      });
		    });
		    describe('#loadCategory()', function() {
		      it('should load parsed dictionary', function() {
		        return expect(translator.loadCategory('web/pages/homepage', 'simple')).to.be.eql({
		          title: ['Title of promo box']
		        });
		      });
		      return it('should return empty object if dictionary does not exists', function() {
		        return expect(translator.loadCategory('some/unknown', 'translation')).to.be.eql({});
		      });
		    });
		    describe('#findTranslation()', function() {
		      it('should return english translations from dictionary', function() {
		        return expect(translator.findTranslation('web.pages.homepage.promo.title')).to.be.eql(['Title of promo box']);
		      });
		      return it('should return null when translation does not exists', function() {
		        return expect(translator.findTranslation('some.unknown.translation')).to.be["null"];
		      });
		    });
		    describe('#pluralize()', function() {
		      return it('should return right version of translation(s) by count', function() {
		        var cars, fruits;
		        cars = ['1 car', '%count% cars'];
		        expect(translator.pluralize('car', cars, 1)).to.be.equal('1 car');
		        expect(translator.pluralize('car', cars, 4)).to.be.equal('%count% cars');
		        fruits = [['1 apple', '%count% apples'], ['1 orange', '%count% oranges']];
		        expect(translator.pluralize('list', fruits, 1)).to.be.eql(['1 apple', '1 orange']);
		        return expect(translator.pluralize('list', fruits, 4)).to.be.eql(['%count% apples', '%count% oranges']);
		      });
		    });
		    describe('#prepareTranslation()', function() {
		      return it('should return expanded translation with arguments', function() {
		        translator.addReplacement('item', 'car');
		        return expect(translator.prepareTranslation('%item% has got %count% %append%.', {
		          count: 5,
		          append: 'things'
		        })).to.be.equal('car has got 5 things.');
		      });
		    });
		    describe('#applyReplacements()', function() {
		      return it('should add replacements to text', function() {
		        return expect(translator.applyReplacements('%one% %two% %three%', {
		          one: 1,
		          two: 2,
		          three: 3
		        })).to.be.equal('1 2 3');
		      });
		    });
		    describe('#translate()', function() {
		      it('should return translated text from dictionary', function() {
		        return expect(translator.translate('web.pages.homepage.promo.title')).to.be.equal('Title of promo box');
		      });
		      it('should return original text if text is eclosed in \':\'', function() {
		        return expect(translator.translate(':do.not.translate.me:')).to.be.equal('do.not.translate.me');
		      });
		      it('should return array of list', function() {
		        return expect(translator.translate('web.pages.homepage.promo.list')).to.be.eql(['1st item', '2nd item', '3rd item', '4th item', '5th item']);
		      });
		      it('should return translation for plural form', function() {
		        return expect(translator.translate('web.pages.homepage.promo.cars', 3)).to.be.equal('3 cars');
		      });
		      it('should return translation of list for plural form', function() {
		        return expect(translator.translate('web.pages.homepage.promo.fruits', 3)).to.be.eql(['3 bananas', '3 citrons', '3 oranges']);
		      });
		      it('should return translation with replacement in message', function() {
		        translator.addReplacement('one', 1);
		        translator.addReplacement('dictionary', 'promo');
		        return expect(translator.translate('web.pages.homepage.%dictionary%.%name%', null, {
		          two: 2,
		          name: 'advanced'
		        })).to.be.equal('1 2');
		      });
		      it('should translate with parameters in place of count argument', function() {
		        return expect(translator.translate('web.pages.homepage.promo.advanced', {
		          one: '1',
		          two: 2
		        })).to.be.equal('1 2');
		      });
		      it('should translate one item from list in translate method', function() {
		        expect(translator.translate('web.pages.homepage.promo.newList[0]')).to.be.equal('first');
		        expect(translator.translate('web.pages.homepage.promo.newList[1]')).to.be.equal('second');
		        return expect(translator.translate('web.pages.homepage.promo.newList[2]')).to.be.equal('third');
		      });
		      it('should throw an error when translating one item from non-list', function() {
		        return expect(function() {
		          return translator.translate('web.pages.homepage.promo.title[5]');
		        })["throw"](Error);
		      });
		      return it('should throw an error when translating one item which does not exists', function() {
		        return expect(function() {
		          return translator.translate('web.pages.homepage.promo.newList[5]');
		        })["throw"](Error);
		      });
		    });
		    describe('#translatePairs()', function() {
		      it('should throw an error if message to translate are not arrays', function() {
		        return expect(function() {
		          return translator.translatePairs('web.pages.homepage.promo', 'title', 'list');
		        })["throw"](Error);
		      });
		      it('should throw an error if keys and values have not got the same length', function() {
		        return expect(function() {
		          return translator.translatePairs('web.pages.homepage.promo', 'list', 'keys');
		        })["throw"](Error);
		      });
		      return it('should return object with keys and values translations', function() {
		        return expect(translator.translatePairs('web.pages.homepage.promo', 'keys', 'values')).to.be.eql({
		          '1st title': '1st text',
		          '2nd title': '2nd text',
		          '3rd title': '3rd text',
		          '4th title': '4th text'
		        });
		      });
		    });
		    describe('#translateMap()', function() {
		      it('should throw an error if object is not array or object', function() {
		        return expect(function() {
		          return translator.translateMap(new Date);
		        }).to["throw"](Error);
		      });
		      it('should translate array', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.title', 'web.pages.homepage.promo.info'])).to.be.eql(['Title of promo box', 'Some info text']);
		      });
		      it('should translate object', function() {
		        var t;
		        t = {
		          title: 'web.pages.homepage.promo.title',
		          info: 'web.pages.homepage.promo.info'
		        };
		        return expect(translator.translateMap(t)).to.be.eql({
		          title: 'Title of promo box',
		          info: 'Some info text'
		        });
		      });
		      it('should translate array with plural forms translations', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.cars', 'web.pages.homepage.promo.mobile'], 6)).to.be.eql(['6 cars', '6 mobiles']);
		      });
		      it('should translate array with arguments', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.advanced'], {
		          one: 1,
		          two: 2
		        })).to.be.eql(['1 2']);
		      });
		      it('should translate array with base path', function() {
		        return expect(translator.translateMap(['title', 'info'], 'web.pages.homepage.promo')).to.be.eql(['Title of promo box', 'Some info text']);
		      });
		      return it('should translate array with list', function() {
		        return expect(translator.translateMap(['web.pages.homepage.promo.fruits'], 4)).to.be.eql([['4 bananas', '4 citrons', '4 oranges']]);
		      });
		    });
		    return describe('#setCacheStorage()', function() {
		      it('should throw an exception if storage is not the right type', function() {
		        return expect(function() {
		          return translator.setCacheStorage(new Array);
		        })["throw"](Error);
		      });
		      return it('should create cache instance', function() {
		        translator.setCacheStorage(new BrowserLocalStorage);
		        return expect(translator.cache).to.be.an["instanceof"](Cache);
		      });
		    });
		  });
		
		}).call(this);
		
	
	}, '/test/data/config.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/config.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/config.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/config.json';
		var __dirname = '/test/data';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/config.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"path": "."
		}
		}).call(this);
		
	
	}, '/test/data/en.first.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/en.first.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/en.first.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/en.first.json';
		var __dirname = '/test/data';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/en.first.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"test": "hello"
		}
		}).call(this);
		
	
	}, '/test/data/web/pages/homepage/en.cached.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/web/pages/homepage/en.cached.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/web/pages/homepage/en.cached.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/web/pages/homepage/en.cached.json';
		var __dirname = '/test/data/web/pages/homepage';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/web/pages/homepage/en.cached.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {"variable": "1"}
		}).call(this);
		
	
	}, '/test/data/web/pages/homepage/en.promo.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/web/pages/homepage/en.promo.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/web/pages/homepage/en.promo.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/web/pages/homepage/en.promo.json';
		var __dirname = '/test/data/web/pages/homepage';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/web/pages/homepage/en.promo.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"title": "Title of promo box",
			"info": "Some info text",
			"list": [
				["1st item"],
				["2nd item"],
				["3rd item"],
				["4th item"],
				["5th item"]
			],
			"cars": [
				"1 car",
				"%count% cars"
			],
			"mobile": [
				"1 mobile",
				"%count% mobiles"
			],
			"fruits": [
				"# this is some random comment #",
				[
					"1 banana",
					"%count% bananas"
				],
				[
					"1 citron",
					"# another comment #",
					"%count% citrons"
				],
				[
					"1 orange",
					"%count% oranges"
				]
			],
			"keys": [
				["1st title"],
				["2nd title"],
				["3rd title"],
				["4th title"]
			],
			"values": [
				["1st text"],
				["2nd text"],
				["3rd text"],
				["4th text"]
			],
			"advanced": "%one% %two%",
			"-- newList": [
				"first",
				"second",
				"third"
			]
		}
		}).call(this);
		
	
	}, '/test/data/web/pages/homepage/en.simple.json': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, '/test/data/web/pages/homepage/en.simple.json');};
		require.resolve = function(name, parent) {if (parent === null) {parent = '/test/data/web/pages/homepage/en.simple.json';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = '/test/data/web/pages/homepage/en.simple.json';
		var __dirname = '/test/data/web/pages/homepage';
		var process = {cwd: function() {return '/';}, argv: ['node', '/test/data/web/pages/homepage/en.simple.json'], env: {}};
	
		/** code **/
		module.exports = (function() {
		return {
			"title": "Title of promo box"
		}
		}).call(this);
		
	
	}, 'cache-storage/Storage/BrowserLocalStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/BrowserLocalStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/BrowserLocalStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/BrowserLocalStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/BrowserLocalStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/BrowserLocalStorage');
	
	}, 'cache-storage/Storage/DevNullStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/DevNullStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/DevNullStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/DevNullStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/DevNullStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/DevNullStorage');
	
	}, 'cache-storage/Storage/FileStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/FileStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/FileStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/FileStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/FileStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/FileStorage');
	
	}, 'cache-storage/Storage/MemoryStorage.js': function(exports, module) {
	
		/** node globals **/
		var require = function(name) {return __r__c__.require(name, 'cache-storage/Storage/MemoryStorage.js');};
		require.resolve = function(name, parent) {if (parent === null) {parent = 'cache-storage/Storage/MemoryStorage.js';} return __r__c__.require.resolve(name, parent);};
		require.define = function(bundle) {__r__c__.require.define(bundle);};
		require.cache = __r__c__.require.cache;
		var __filename = 'cache-storage/Storage/MemoryStorage.js';
		var __dirname = 'cache-storage/Storage';
		var process = {cwd: function() {return '/';}, argv: ['node', 'cache-storage/Storage/MemoryStorage.js'], env: {}};
	
		/** code **/
		module.exports = require('../lib/Storage/MemoryStorage');
	
	}, 'callsite': function(exports, module) { module.exports = __r__c__.require('callsite/index.js'); }
	, 'cache-storage': function(exports, module) { module.exports = __r__c__.require('cache-storage/lib/Cache.js'); }
	, 'moment': function(exports, module) { module.exports = __r__c__.require('moment/moment.js'); }
	, 'normalize-arguments': function(exports, module) { module.exports = __r__c__.require('normalize-arguments/lib/Args.js'); }
	
	});
	__r__c__.require.version = '5.6.3';
	
	window.require = __r__c__.require;
	
	/** run section **/
	
	/** /test/browser/tests/Translator **/
	__r__c__.require('/test/browser/tests/Translator');
}).call({});